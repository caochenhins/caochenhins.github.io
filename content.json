{"meta":{"title":"曹辰的博客","subtitle":"隐士，一枚88年的java程序员，好奇心比较强，目前是一个码农，从事Java方向的研究和开发。-- hins","description":"码农，程序猿，未来的昏析狮","author":"曹辰","url":"https://caochenhins.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-03-20T14:09:51.000Z","updated":"2019-03-20T16:32:04.617Z","comments":true,"path":"categories/index.html","permalink":"https://caochenhins.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-20T14:10:00.000Z","updated":"2019-03-20T16:32:14.113Z","comments":true,"path":"tags/index.html","permalink":"https://caochenhins.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-03-20T14:10:04.000Z","updated":"2019-03-20T16:32:47.232Z","comments":true,"path":"about/index.html","permalink":"https://caochenhins.github.io/about/index.html","excerpt":"","text":"分享所思, 所得。 如此而已 Write By CaoChen 我是[香港脚台湾人]，这个GitPage的定位是自我提升，范围主要包括学习方法、注意力、习惯等等，同时不定期分享一些五花八门的读书笔记和影评。 欢迎点击文章标题下方的作者关注。 由于水平有限，不足和错误之处在所难免，希望大家能够批评指出。 我的博客：http://www.cnblogs.com/hins/ 我的GitHub：https://github.com/caochenhins 我的微信公共号：曹辰的思考笔记"}],"posts":[{"title":"README","slug":"README","date":"2020-03-21T14:42:55.000Z","updated":"2019-03-27T13:37:07.347Z","comments":true,"path":"2020/03/21/README/","link":"","permalink":"https://caochenhins.github.io/2020/03/21/README/","excerpt":"智者必怀仁，时刻学习总结博客定位说明： 以下笔记都是自己学习实践后总结出来的，其中不可避免存在笔误或者有理解错误的地方，欢迎指出。 以下列举的笔记都可以在项目中的文件夹中找到。 笔记中有格式显现错误，原因是早期总结对markdown语法不是很熟练，如果你需要原版文件，请提出。 项目中有一个文件夹存放一些优质的常用API，如果你有资源，且有心想分享，请提出。 笔记重点在于记录学习过程，对技术使用的总结笔记在我的个人博客上：曹辰博客 这个项目会持续更新，欢迎start,以资鼓励，感谢 这个GitPage的定位是自我提升，范围主要包括学习方法、注意力、习惯等等，同时不定期分享一些五花八门的读书笔记和影评。","text":"智者必怀仁，时刻学习总结博客定位说明： 以下笔记都是自己学习实践后总结出来的，其中不可避免存在笔误或者有理解错误的地方，欢迎指出。 以下列举的笔记都可以在项目中的文件夹中找到。 笔记中有格式显现错误，原因是早期总结对markdown语法不是很熟练，如果你需要原版文件，请提出。 项目中有一个文件夹存放一些优质的常用API，如果你有资源，且有心想分享，请提出。 笔记重点在于记录学习过程，对技术使用的总结笔记在我的个人博客上：曹辰博客 这个项目会持续更新，欢迎start,以资鼓励，感谢 这个GitPage的定位是自我提升，范围主要包括学习方法、注意力、习惯等等，同时不定期分享一些五花八门的读书笔记和影评。 欢迎点击每篇文章下方的作者关注。 欢迎赞赏,评论每篇文章。 由于水平有限，不足和错误之处在所难免，希望大家能够批评指出。 我的博客：http://www.cnblogs.com/hins/ 我的GitHub：https://github.com/caochenhins 我的微信公共号：曹辰的思考笔记 记录自己的学习轨迹 2018年07月05日学习记录 JavaEE进阶知识学习—–Mybatis知识总结 JavaEE进阶知识学习—–SpringCloud学习总结 前端基础知识学习—Vue.js学习总结 JavaEE基础知识学习—–Mysql学习总结 2018年07月06日学习记录 JavaEE日常工作经验总结系列（一）—–Java8优雅去重 JavaEE日常工作经验总结系列（二）—–代码规范 CentOS7的安装 CentOS7常用命令 CentOS7安装JDK1.8 CentOS7负载均衡服务器Nginx centos7网卡配置 nginx使用ssl模块配置HTTPS支持 CentOS7安装Jexus CentOS7安装MariaDB CentOS7安装Mono CentOS7安装Redis CentOS7安装Tomcat CentOS7安装防火墙 2018年07月08日学习记录 JavaEE进阶知识学习—–Java8新特性学习总结 JavaEE进阶知识学习—–PostgreSQL学习总结 大数据基础知识学习—–Hive学习笔记 JavaEE基础知识学习—-装饰者模式 JavaEE基础知识学习—–正则表达式学习 JavaEE基础知识学习—-异常 JavaEE基础知识学习—-数据结构 JavaEE基础知识学习—-前端框架react-1 JavaEE基础知识学习—-前端规范ES6 JavaEE基础知识学习—-集合之LinkList JavaEE基础知识学习—-集合之HashMap JavaEE基础知识学习—-继承 JavaEE基础知识学习—-集合之LinkList JavaEE基础知识学习—-集合之HashMap JavaEE基础知识学习—-集合之ConcurrentHashMap JavaEE基础知识学习—-集合之ArrayList JavaEE基础知识学习—-集合 JavaEE基础知识学习—-观察者模式 2018年07月09日学习记录 JavaEE基础知识学习—-抽象类和接口 JavaEE基础知识学习—-多态 JavaEE基础知识学习—-泛型 JavaEE基础知识学习—-前端规范ES5 JavaEE基础知识学习—-Static关键字 JavaEE基础知识学习—–Typora常用快捷键 JavaEE基础知识学习—–Webstrom常用快捷键 JavaEE基础知识学习—-单例模式 JavaEE基础知识学习—-MyBatis（一）简介 JavaEE基础知识学习—-MyBatis（二）全局配置文件 JavaEE基础知识学习—-MyBatis（三）映射文件 JavaEE基础知识学习—-MyBatis（四）动态SQL JavaEE基础知识学习—-MyBatis（五）缓存机制 JavaEE基础知识学习—-MyBatis（六）MBG逆向工程 JavaEE基础知识学习—-MyBatis（七）插件开发 2018年07月10日学习记录 JavaEE基础知识学习—MySql数据库（一）数据库简介 JavaEE基础知识学习—MySql数据库（二）DQL语言 JavaEE基础知识学习—MySql数据库（三）DML语言 JavaEE基础知识学习—MySql数据库（四）DDL语言 JavaEE基础知识学习—MySql数据库（五）数据库事务 JavaEE基础知识学习—MySql数据库（六）数据库视图 JavaEE基础知识学习—MySql数据库（七）数据库存储过程 JavaEE基础知识学习—-PostgreSQL数据库（一）基础部分 JavaEE基础知识学习—-PostgreSQL数据库（二）查询工具 JavaEE基础知识学习—-PostgreSQL数据库（三）条件查询 JavaEE基础知识学习—-PostgreSQL数据库（四）连接 JavaEE基础知识学习—-PostgreSQL数据库（五）高级部分 JavaEE基础知识学习—-Final关键字 JavaEE基础知识学习—-Object类 JavaEE基础知识学习—–P3C问题总结 JavaEE进阶知识学习—-Java8-1-Lambda表达式 JavaEE进阶知识学习—-Java8-2-函数式接口 JavaEE进阶知识学习—-Java8-3-方法引用和构造器引用 2018年07月11日学习记录 JavaEE进阶知识学习—-Java8-4-1-StreamAPI JavaEE进阶知识学习—-Java8-4-2-StreamAPI JavaEE进阶知识学习—-Java8-6-时间API 2018年07月12日学习记录 CSS 3.0参考手册 JavaScript核心参考手册 jQuery1.7 中文手册 jQuery1.11.3 中文手册 W3School手册 2018年07月14日学习记录 前端基础知识学习—CSS3总结（一）选择器 前端基础知识学习—CSS3总结（二）新增UI方案 前端基础知识学习—CSS3总结（三）渐变实例发廊灯 前端基础知识学习—CSS3总结（四）渐变实例光斑动画 2018年07月15日学习记录 JavaEE进阶知识学习—-JavaNIO-1-缓冲区-通道 JavaEE进阶知识学习—-JavaNIO-2-分散读取和聚集写入-阻塞网络通信 JavaEE进阶知识学习—-JavaNIO-3-非阻塞式-DatagramChannel JavaEE进阶知识学习—-JavaNIO-4-NIO2-File类 2018年07月17日学习记录 前端基础知识学习—CSS3学习总结 2018年07月19日学习记录 前端知识日常总结系列（三）—–CSS浮动理解 2018年07月20日学习记录 JavaEE进阶知识学习—-Quartz-1-HelloWord JavaEE进阶知识学习—-Quartz-2-触发器Trigger JavaEE进阶知识学习—-Quartz-3-Scheduler函数 JavaEE进阶知识学习—-Quartz-4-Quartz整合 JavaEE进阶知识学习—-SpringBoot-1-项目初始化知识 JavaEE进阶知识学习—-SpringBoot-2-配置文件知识 JavaEE进阶知识学习—-SpringBoot-3-控制类知识 JavaEE进阶知识学习—-SpringBoot-4-数据库知识 JavaEE进阶知识学习—-SpringBoot-5-事务管理知识 JavaEE进阶知识学习—-SpringBoot-6-表单验证知识 JavaEE进阶知识学习—-SpringBoot-7-AOP处理请求知识 JavaEE进阶知识学习—-SpringBoot-8-异常处理知识 JavaEE进阶知识学习—-SpringBoot-9-单元测试知识 JavaEE进阶知识学习—-SpringBoot-10-配置文件 JavaEE进阶知识学习—-SpringBoot-11-日志框架 JavaEE进阶知识学习—-SpringBoot-12-web 2018年07月21日学习记录 JavaEE进阶知识学习—-SpringBoot高级（二）SpringBoot使用缓存 JavaEE进阶知识学习—-SpringBoot高级（六）SpringBoot整合RabbitMQ JavaEE进阶知识学习—-SpringBoot高级（三）缓存注解 JavaEE进阶知识学习—-SpringBoot高级（四）SpringBoot整合Redis JavaEE进阶知识学习—-SpringBoot高级（五）SpringBoot与消息 JavaEE进阶知识学习—-SpringBoot高级（一）JSR107缓存 JavaEE进阶知识学习—–SpringCloud（八）Hystrix断路器 JavaEE进阶知识学习—–SpringCloud（二）实践准备 JavaEE进阶知识学习—–SpringCloud（九）Zuul路由网关 JavaEE进阶知识学习—–SpringCloud（六）Ribbon负载均衡 JavaEE进阶知识学习—–SpringCloud（七）Feign负载均衡 JavaEE进阶知识学习—–SpringCloud（三）Eureka服务注册与发现 JavaEE进阶知识学习—–SpringCloud（十）SpringCloudConfig配置中心 JavaEE进阶知识学习—–SpringCloud（四）Eureka集群配置 JavaEE进阶知识学习—–SpringCloud（五）Eureka和Zookeeper区别 JavaEE进阶知识学习—–SpringCloud（一）概述 2018年07月22日学习记录 CSS3脑图总结学习笔记 2018年07月30日学习记录 jQuery学习笔记 JavaScript学习笔记 Javascript高级学习笔记 2018年07月31日学习记录 MybatisPlus学习笔记","categories":[{"name":"README","slug":"README","permalink":"https://caochenhins.github.io/categories/README/"}],"tags":[{"name":"README","slug":"README","permalink":"https://caochenhins.github.io/tags/README/"}]},{"title":"2018年个人总结","slug":"2018年个人总结","date":"2019-03-27T13:28:28.000Z","updated":"2019-03-27T13:33:28.721Z","comments":true,"path":"2019/03/27/2018年个人总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/27/2018年个人总结/","excerpt":"文章目录： 1、关于创业 2、关于个人 3、复盘：年初的目标完成情况 4、2019年的目标 5、个人的Milestone","text":"文章目录： 1、关于创业 2、关于个人 3、复盘：年初的目标完成情况 4、2019年的目标 5、个人的Milestone 关于创业前言：稍微解释下，我这里说的创业，并非传统意义上的“辞职”单干或合伙创办公司的那种，而是将职业生涯的种种心路历程，以一种创业的心态去面对，因为我一直坚信，当你始终抱着一颗“将为公司打工看待为自己的事业”，那你工作的思维高度，角度，态度，心态这些，都将变的更加积极。 2017年5月从广州回到成都，到2018年底，在现有公司已经足足一年半了，业务上的梳理的已经非常清晰了，但真的要去回顾2018，发现居然没有什么可以回顾的，这让我一下子焦虑了起来，因为你走过的路，居然没有可以总结的，这样会进入一个没有迭代、没有增长、没有改变的死循环。1月12日，周六，没有按期回家，而呆在公司度过了一整天的焦虑，为了自己不去多想，就把2018年MTSC在腾讯上公开的视频，全部看了一遍。庆幸的是，看到了小猿搜题的产品技术负责人-唐巧的视频，从视频中获悉了一些知识，最后接触到了他的个人博客。对我冲击很大，唐巧原本是网易的iOS开发者，后来和同事一起创业做粉笔网，后来做成了现在的小猿搜题。他个人将工作总结、对个人成长的思考、对管理能力的思考等的总结，都从12年开始一直坚持，并且每年都在前进、改变，真的让人由衷的敬佩。截此，心态恢复到了平静，无论是否焦虑，我都需要跨出这一步。 临危受命：第一、2017年部门从架构上虽然存在，但犹如散沙，部门同事之间无过多的交集，同为QA岗位，却有着对质量、测试的不同理解。第二、能力高低不一，且都处于偏低阶层，测试过的产品均出现各种漏测问题发生，导致线上大小事故频繁第三、公司内部，对质量文化、质量工作的认同普遍偏低第四、员工心态散漫、对质量把控无深刻的自我责任意识第五、新产品要上线，无明确质量纬度和质量标准去衡量，所谓的质量仅仅只是bug数量 面对问题，17年深入思考的很少，都是在忙着救火，哪里需要什么、哪里缺什么我们就补什么，全凭个人的经验去应对所有的需求。没有工作文档的，我直接改版以前的或重新设计. 执行的同事不知道如何做，我就直接亲自上阵教，甚至在时间非常赶的情况下，临时教再运用以及很慢了，我就自己上，把测试结果反过来汇报给执行的同事，让执行同事去反馈，然后再回到正常的轨道，这个状态大概持续了17年的下半年. 基本都是几年的老同事，部分同事面对工作要求高了，工作“规则”变了，无法胜任，也不愿改变，情绪上变得浮躁，工作上频繁出错。这样不得不在给予充分机会的情况下，劝退了部分同事，尽快补上新的血液. 17年之前，公司部分测试需求，是没有测试人员跟进和把控的，18年初，这部分工作主动被我拿了回来，但人手上不得不面临紧张。原本一直对用外包员工保持慎用，但现在不得不利用外包同事来快速填充业务需求就这样“熬过”了17年，这一年最大的收获就是为18年工作打下了一个基础。18年，继续干了如下几件事情，在业务、管理上探索. 1、确立自有+外包同事，建立起符合现有公司人才制度的团队结构模式 2、建立培训、分享机制，将工作中常用的设计思维拿出来讨论和分享，快速进行思维的碰撞，尽快发现哪些地方是不对称的，及时纠正和学习 3、梳理总结业务纬度，针对每个纬度制定说明和标准，让部门同事知道要做什么，如何做，也同步全公司，让所有产品知道有什么标准必须要过的 4、建立可以check的结果，不断改进在测试过程覆盖程度、测试结果反馈的清晰度。这个过程我们改进了不止3版，最后做到了统一必要的测试验收过程、测试报告形式。 5、用testlink进行用例管理，让测试用例规范起来，和每个版本对应，在测试结果上清晰的反应出测试的覆盖，针对每个产品梳理一版必过冒烟用例，加入周维护版本中 6、引入bugly和Tscancode，前者监控crash崩溃情况，后者检查代码级别的问题。 关于个人：读书2018年，遇到当当五折优惠，疯狂的购进了当年的一些经典书籍，例如《刻意练习》《金字塔原理》《德鲁克给经理人的第一堂课》《高效能人士的7个习惯》等等，差不多20多本。可恨自己，中了买了书即放弃读书的恶魔，最终只完成了几本书的阅读，书单如下，也可以点击查看书籍总结 《德鲁克给经理人的第一堂课》《终生成长》《0秒思考》《带团队懂得如何说话》《刻意练习》《给你一个团队你应该怎么管》《不懂得带团队只有累死自己》 以上管理类书籍偏多，2018年在团队快速增长的过程中，明细感觉到自己缺乏系统的管理知识，相反技术能力还能应付当前的需求，这方面补习暂时不多，但也存在很多收获 技术devops理解更加深入了持续集成理解AI智能测试知识增长图像视频相关知识有所增长，并结合测试知识扩展这方面的验收标准这些新知识，目前掌握的还是太基础，并不能主动的去把控图像、算法、视频拍摄方面的质量情况，也暂时做不到主动去推进这些研究项 网课《用的着的商学课》-腾讯课题《软件测试》-极客帮茹炳晟《python基础》-网易mooc大学 健康2018年的跑步次数寥寥无几，还不足以前两年的一个月的量，但很庆幸身体还什么大问题，一直以来还是激情满满的 复盘2018定的目标，主要为测试纬度梳理和标准产出，管理方面搭建起自己的核心能力班子，将团队打造成一个持续的学习的团队。目前来看，这些都已经完成，但在2018年中，这些目标实现的不太顺利，且有部分的目标已经在临近年末才算彻底的想通和找到答案，因此整体来看，只能给自己打65分，比及格好一点点。 2019年的目标：另一篇文章，详细列出了2019年要达到的目标，笼统的来概括为：改变自己，让自己提高效率，讲究落地效益改变团队，让学习成为我们最佳的筹码，为团队争取一年的稳定增加能力改变公司，增加技术投入建设，带动公司内部其它岗位一起改变，重新认识QA以上三点，坚持做好，可以为未来3~5年搭好一个平台，争取更多的机会 个人的Milestone：管理能力，慢慢摸索出了带团队的节奏","categories":[{"name":"总结","slug":"总结","permalink":"https://caochenhins.github.io/categories/总结/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://caochenhins.github.io/tags/总结/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（十）SpringCloudConfig配置中心","slug":"JavaEE进阶知识学习-----SpringCloud（十）SpringCloudConfig配置中心","date":"2019-03-23T02:44:04.000Z","updated":"2019-03-22T13:35:28.573Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（十）SpringCloudConfig配置中心/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（十）SpringCloudConfig配置中心/","excerpt":"SpringCloudConfig配置中心概述就前面项目而言，分布面临的问题是配置问题，每一个项目都有一个yml文件，不好运维管理，所有需要一套集中式，动态的配置管理设施，SpringCloud提供了ConfigServer来解决这个问题。 SpringCloud Config是为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为 各个不同的微服务应用的环境提供了一个 中心化的外部配置。SpringCloud Config分为客户端和服务端，服务端也称 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密和解密信息等访问接口，客户端是通过指定的配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具管理和访问配置内容。","text":"SpringCloudConfig配置中心概述就前面项目而言，分布面临的问题是配置问题，每一个项目都有一个yml文件，不好运维管理，所有需要一套集中式，动态的配置管理设施，SpringCloud提供了ConfigServer来解决这个问题。 SpringCloud Config是为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为 各个不同的微服务应用的环境提供了一个 中心化的外部配置。SpringCloud Config分为客户端和服务端，服务端也称 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密和解密信息等访问接口，客户端是通过指定的配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具管理和访问配置内容。 作用 集中管理配置文件 不同环境下不同配置，动态化的配置更新，分环境部署等 运行期间动态调整配置，不需要在每一个服务部署的机器编码上编写文件，服务会向配置中心拉取自己的配置信息 当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置 将配置信息以REST接口的形式暴露 config服务端与GitHub通信GitHUb上新建一个microservicecloud-config的Repository 本地硬盘目录新建git仓库并clone 在D:\\workspace2018\\micorservicecloude-config\\microservicecloud-config新建application.yml文件 1234567891011121314Spring: profiles: active: - dev---Spring: profiles: dev application: name: micorservicecloud-config-luo-dev---Spring: profiles: test application: name: micorservicecloud-config-luo-test 注意保存为utf-8的文件格式 将yml文件推送到GitHub上 123git add .git commit -m&quot;&quot;git push origin master 新建项目microservicecloud-config-3344 POM.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-config-3344&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- springCloud Config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 避免Config的Git插件报错：org/eclipse/jgit/api/TransportConfigCallback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt; &lt;version&gt;4.10.0.201712302008-r&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 图形化监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 熔断 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件 1234567891011server: port: 3344 spring: application: name: microservicecloud-config cloud: config: server: git: uri: git@github.com:luokangyuan/microservicecloud-config.git #GitHub上面的git仓库名字 主启动类 1234567@SpringBootApplication@EnableConfigServerpublic class Config_3344_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(Config_3344_StartSpringCloudApp.class, args); &#125;&#125; 修改host文件 1127.0.0.1 config-3344.com 测试通过config微服务从GitHub上获取配置内容 启动服务3344，访问http://config-3344.com:3344/application-dev.yml，http://config-3344.com:3344/application-test.yml config客户端获取github配置本地新建microservicecloud-config-client.yml文件,并推送到github 123456789101112131415161718192021server: port: 8201spring: profiles: dev application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-dev.com:7001/eureka/---server: port: 8202spring: profiles: test application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-test.com:7001/eureka/ 新建项目microservicecloud-config-client-3355，pom.xml文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringCloud Config客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建bootstrap.yml文件 1234567spring: cloud: config: name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名 profile: test #本次访问的配置项 label: master uri: http://config-3344.com:3344 #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址 application.yml是用户级的资源配置文件，bootstrap.yml是系统级，优先级更高，保证不会被本地配置文件所覆盖 修改host文件，增加映射 1127.0.0.1 client-config.com 新建测试controller，从github读取配置信息 123456789101112131415161718192021222324252627package com.luo.springcloud.rest;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ConfigClientRest&#123; @Value(\"$&#123;spring.application.name&#125;\") private String applicationName; @Value(\"$&#123;eureka.client.service-url.defaultZone&#125;\") private String eurekaServers; @Value(\"$&#123;server.port&#125;\") private String port; @RequestMapping(\"/config\") public String getConfig() &#123; String str = \"applicationName: \" + applicationName + \"\\t eurekaServers:\" + eurekaServers + \"\\t port: \" + port; System.out.println(\"******str: \" + str); return \"applicationName: \" + applicationName + \"\\t eurekaServers:\" + eurekaServers + \"\\t port: \" + port; &#125;&#125; 新建主启动类 123456@SpringBootApplicationpublic class ConfigClient_3355_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClient_3355_StartSpringCloudApp.class, args); &#125;&#125; 测试 启动3344服务，启动3355服务，bootstrap.yml中的profile值是什么，决定从github上读取什么,ruguo 访问http://client-config.com:8201/config得到是github上的microservicecloud-config-client.yml文件中dev相关的配置信息 访问http://client-config.com:8202/config得到是github上的microservicecloud-config-client.yml文件中test相关的配置信息","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（九）Zuul路由网关","slug":"JavaEE进阶知识学习-----SpringCloud（九）Zuul路由网关","date":"2019-03-23T01:44:04.000Z","updated":"2019-03-22T13:34:58.077Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（九）Zuul路由网关/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（九）Zuul路由网关/","excerpt":"Zuul路由网关概述Zuul包含了对请求的路由和过滤两个主要的功能，其中路由的功能是负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤功能是负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础，Zuul和Eureka进行整合，将Zuul自身注册近Eureka服务治理的应用，同时从Eureka中获取其他微服务的消息，也及时以后的访问服务都是通过Zuul跳转后获得， 注意的是Zuul服务最终还是会注册近Eureka中","text":"Zuul路由网关概述Zuul包含了对请求的路由和过滤两个主要的功能，其中路由的功能是负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤功能是负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础，Zuul和Eureka进行整合，将Zuul自身注册近Eureka服务治理的应用，同时从Eureka中获取其他微服务的消息，也及时以后的访问服务都是通过Zuul跳转后获得， 注意的是Zuul服务最终还是会注册近Eureka中 路由基本配置新建项目microservicecloud-zuul-gateway-9527，添加依赖如下 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-zuul-gateway-9527&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- zuul路由网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix容错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日常标配 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678910111213141516171819202122232425server: port: 9527 spring: application: name: microservicecloud-zuul-gateway eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka,http://eureka7003.com:7003/eureka instance: instance-id: gateway-9527.com prefer-ip-address: true zuul: #ignored-services: microservicecloud-dept prefix: /luo ignored-services: \"*\"info: app.name: luo-microcloud company.name: www.luo.com build.artifactId: $project.artifactId$ build.version: $project.version$ 修改host文件1127.0.0.1 myzuul.com 主启动类Zuul_9527_StartSpringCloudApp1234567@SpringBootApplication@EnableZuulProxypublic class Zuul_9527_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(Zuul_9527_StartSpringCloudApp.class, args); &#125;&#125; 启动三个集群，一个服务提供类microservicecloud-provider-dept-8001，一个路由 测试不使用路由：http://localhosat:8001/dept/get/2 使用路由：http://myzuul.com:9527/microservicecloud-dept/dept/get/2 Zuul路由访问映射在前面的测试中我们可以使用http://myzuul.com:9527/microservicecloud-dept/dept/get/2访问我们的接口，这样就暴露我们的微服务名称，需要做安全加固，就用到了路由访问映射，修改路由项目的yml文件,添加 mydept.path: /mydept/** 1234567zuul: #ignored-services: microservicecloud-dept #忽略真实地址，只让虚拟地址访问 prefix: /luo #访问地址前缀 ignored-services: \"*\"#忽略真实地址，只让虚拟地址访问 routes: mydept.serviceId: microservicecloud-dept ##真实地址 mydept.path: /mydept/** # 虚拟地址 访问连接：http://lyzuul.com:9527/luo/mydept/dept/get/1","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（八）Hystrix断路器","slug":"JavaEE进阶知识学习-----SpringCloud（八）Hystrix断路器","date":"2019-03-23T00:44:04.000Z","updated":"2019-03-22T13:34:41.199Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（八）Hystrix断路器/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（八）Hystrix断路器/","excerpt":"Hystrix断路器概述Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多的依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下， 不会导致整体服务的失败，避免级联故障，以提高分布式系统的弹性。断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方法返回一个预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法异常无法处理的异常，这样就保证服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延。","text":"Hystrix断路器概述Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多的依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下， 不会导致整体服务的失败，避免级联故障，以提高分布式系统的弹性。断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方法返回一个预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法异常无法处理的异常，这样就保证服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延。 服务熔断熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某一个微服务不可用或者响应时间太长，会进行服务的降级， 进而熔断该节点微服务的调用，快速返回“错误”的响应信息，当检测到该节点微服务调用响应正常后恢复调用链路，在SpringCloud框架中熔断机制使用Hystrix实现，Hystrix会监控微服务调用情况，当失败达到一定阈值。就会启动熔断机制，熔断机制的注解是 @HystrixCommand Hystrix实操参照microservicecloud-provider-dept-8001建立microservicecloud-provider-dept-hystrix-8001项目pom.xml文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-provider-dept-hystrix-8001&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址 1234567891011121314151617181920212223242526272829303132333435363738server: port: 8001 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间 eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址 info: app.name: luokangyuan-microservicecloud company.name: www.luokangyuan.com build.artifactId: $project.artifactId$ build.version: $project.version$ 修改DeptControllerHystrix的作用就是当调用服务出现异常时如何解决，模拟根据id查部门信息，查到null，人为抛出运行时异常，让Hystrix处理这种情况。 123456789101112131415@RequestMapping(value=\"dept/get/&#123;id&#125;\",method=RequestMethod.GET)@HystrixCommand(fallbackMethod = \"processHystrix_GET\")public Dept get(@PathVariable(\"id\") Long id)&#123; Dept dept = service.get(id); if(null == dept)&#123; throw new RuntimeException(\"该ID:\"+id+\"没有对应的部门信息\"); &#125; return dept;&#125;public Dept processHystrix_GET(@PathVariable(\"id\") Long id)&#123; return new Dept().setDeptno(id) .setDname(\"该ID：\"+id+\"没有对应的信息，null--@HystrixCommand\") .setDb_source(\"no this database in Mysql\");&#125; 修改主启动类添加Hystrix支持123456789@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心@EnableDiscoveryClient // 服务发现@EnableCircuitBreaker //对Hystrix熔断机制的支持public class DeptProvider8001_Hystrix_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_Hystrix_App.class, args); &#125;&#125; 测试熔断机制启动三个Eureka集群，启动服务主启动类DeptProvider8001_Hystrix_App，客户端启动microservicecloud-consumer-dept-80，页面访问http://localhost/consumer/dept/get/112 服务降级服务降级处理是在客户端完成的，与服务端没有关系，在前面的服务熔断中，我们发现每一个业务方法都要写一个processHystrix_方法，这样就造成了很大耦合，根据Spring的学习，我们可将processHystrix_改写一个异常通知。 修改microservicecloud-api工程根据已有的DeptClientService接口，新建一个实现了FallbackFactory接口的类DeptClientServiceFallbackFactory 123456789101112131415161718192021222324252627282930313233343536package com.luo.springcloud.service;import java.util.List;import org.springframework.stereotype.Component;import com.luo.springcloud.entities.Dept;import feign.hystrix.FallbackFactory;@Componentpublic class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt;&#123; @Override public DeptClientService create(Throwable arg0) &#123; return new DeptClientService() &#123; @Override public List&lt;Dept&gt; list() &#123; return null; &#125; @Override public Dept get(long id) &#123; return new Dept().setDeptno(id) .setDname(\"该ID：\"+id+\"没有对应的信息，Consumer客户端提供的降级信息，此服务暂停使用\") .setDb_source(\"no this database in Mysql\"); &#125; @Override public boolean add(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; 注意：不要忘记新类上添加@Component注解 修改microservicecloud-api在DeptClientService接口在注解@FeignClient(value = “MICROSERVICECLOUD-DEPT”)添加fallbackFactory属性值 1@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class) 1234567891011@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class)public interface DeptClientService &#123; @RequestMapping(value = \"/dept/get/&#123;id&#125;\",method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\",method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 修改microservicecloud-consumer-dept-feign的Application.yml文件1234567891011server: port: 80 feign: hystrix: enabled: trueeureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 测试服务降级启动三个Eureka集群，microservicecloud-provider-dept-8001启动，microservicecloud-consumer-dept-feign启动，正常访问http://localhost/consumer/dept/get/1测试，故意关停microservicecloud-provider-dept-8001，客户端自己调用提示 服务监控Hystrix DashboardHystrix还提供了准实时的调用监控Hystrix Dashboard，Hystx会持续的记录所有通过Hystrix发起的请求的执行信息，并以统计报表的图形的形式展示给用户，包括每秒执行多少次请求多少成功多少失败等，对监控内容转换为可视化界面。 新建microservicecloud-consumer-hystrix-dashboard监控的一个微服务工程 POM.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-hystrix-dashboard&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- 自己定义的api --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix和 hystrix-dashboard相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12server: port: 9001 主启动类DeptConsumer_DashBoard_App1234567@SpringBootApplication@EnableHystrixDashboardpublic class DeptConsumer_DashBoard_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer_DashBoard_App.class, args); &#125;&#125; 微服务提供者添加监控依赖配置所有的Provider微服务提供类（8001,8002,8003）都需要监控依赖配置，也就是pom文件添加如下依赖 12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 监控页面测试启动microservicecloud-consumer-hystrix-dashboard，访问http://localhost:9001/hystrix,出现豪猪页面 全部测试启动3个Eureka集群，启动microservicecloud-provider-dept-hystrix-8001，启动了microservicecloud-consumer-hystrix-dashboard用来监控8001服务提供者，访问http://localhost:8001/hystrix.stream 观察监控窗口访问http://localhost:9001/hystrix，填写监控地址http://localhost:8001/hystrix.stream,时间2000，title:demo01,点击按钮 实心圆：两种含义，它通过颜色的变化代表了实例的健康程度，健康色是从绿色&lt;黄色&lt;橙色&lt;红色递减，该实心圆除了颜色的变化之外，他的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大，所以通过实心圆的展示就可以在大量实例中快速的发现 故障实例和高压力测试。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（七）Feign负载均衡","slug":"JavaEE进阶知识学习-----SpringCloud（七）Feign负载均衡","date":"2019-03-22T23:44:04.000Z","updated":"2019-03-22T13:35:16.026Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（七）Feign负载均衡/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（七）Feign负载均衡/","excerpt":"Feign负载均衡Feign是一个声明式WebService客户端，使用Feign能够让编写Web Service客户端变得更简单，它的使用方法就是定义一个接口，然后在上面添加注解。SpringCloud对Feign进行了封装，支持SpringMVC注解和HTTPMessageConverters，Feign可以与Eureka和Ribbon组合使用以支持负载均衡。简单讲，只需要创建一个接口，然后在上面使用注解即可。","text":"Feign负载均衡Feign是一个声明式WebService客户端，使用Feign能够让编写Web Service客户端变得更简单，它的使用方法就是定义一个接口，然后在上面添加注解。SpringCloud对Feign进行了封装，支持SpringMVC注解和HTTPMessageConverters，Feign可以与Eureka和Ribbon组合使用以支持负载均衡。简单讲，只需要创建一个接口，然后在上面使用注解即可。 Feign使用步骤参考项目microservicecloud-consumer-dept-80新建microservicecloud-consumer-dept-feign,拷贝相应的包和配置文件，去掉IRule等信息，修改pom.xml文件，添加对Feign的支持 pom.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-feign&lt;/artifactId&gt;&lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 由于Feign是面向接口编程，为方便接口的互相调用，将接口和公共的方向在项目microservicecloud-api中，因此修改为： 修改microservicecloud-api工程的pom.xml文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 新建DeptClientService接口1234567891011@FeignClient(value = \"MICROSERVICECLOUD-DEPT\")public interface DeptClientService &#123; @RequestMapping(value = \"/dept/get/&#123;id&#125;\",method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\",method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 修改microservicecloud-consumer-dept-feign中Controller添加新建的DeptClientService1234567891011121314151617181920@RestControllerpublic class DeptController_Consumer &#123; @Autowired private DeptClientService service; @RequestMapping(value = \"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id)&#123; return this.service.get(id); &#125; @RequestMapping(value = \"/consumer/dept/list\") public List&lt;Dept&gt; list()&#123; return this.service.list(); &#125; @RequestMapping(value = \"/consumer/dept/add\") public Object add(Dept dept)&#123; return this.add(dept); &#125;&#125; 修改microservicecloud-consumer-dept-feign主启动类,添加注解123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients(basePackages = &#123;\"com.luo.springcloud\"&#125;)@ComponentScan(\"com.luo.springcloud\")public class DeptConsumer80_Feign_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_Feign_App.class, args); &#125;&#125; 测试启动3个Eureka集群，启动三个部门微服务提供者，启动Feign，访问http://localhost/consumer/dept/list即可 总结说明Feign集成了Ribbon，利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并通过轮询的方式实现了客户端的复杂均衡，与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式法人方法，优雅而简单的实现服务调用。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（六）Ribbon负载均衡","slug":"JavaEE进阶知识学习-----SpringCloud（六）Ribbon负载均衡","date":"2019-03-22T22:44:04.000Z","updated":"2019-03-22T13:35:04.979Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（六）Ribbon负载均衡/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（六）Ribbon负载均衡/","excerpt":"Ribbon负载均衡Ribbon概述Spring Cloude Ribbon是基于Netfilx Ribbon实现的一套客户端 负载均衡的工具，简单说，Ribbon是Netfilix发布的开源项目，主要功能就是提供 客户端的软件负载均衡算法，将Netfilix的中间层服务连接在一起，Ribbon客户端组件提供了一系列完善的配置项如连接超时，重试等，简单说，就是在配置文件中列出Load Balance后面的所有机器，Ribbon会自动的帮助你基于某种算法规则（简单轮询，随机连接等）去连接这些机器，也可以使用Ribbon自定义负载均衡算法。LB，即负载均衡，在微服务或者分布式集群中常用的一种应用。负载均衡就是将用户的请求平摊的分配到多个服务上，从而达到HA，常见的负载均衡软件有Nginx，LVS，硬件F5等","text":"Ribbon负载均衡Ribbon概述Spring Cloude Ribbon是基于Netfilx Ribbon实现的一套客户端 负载均衡的工具，简单说，Ribbon是Netfilix发布的开源项目，主要功能就是提供 客户端的软件负载均衡算法，将Netfilix的中间层服务连接在一起，Ribbon客户端组件提供了一系列完善的配置项如连接超时，重试等，简单说，就是在配置文件中列出Load Balance后面的所有机器，Ribbon会自动的帮助你基于某种算法规则（简单轮询，随机连接等）去连接这些机器，也可以使用Ribbon自定义负载均衡算法。LB，即负载均衡，在微服务或者分布式集群中常用的一种应用。负载均衡就是将用户的请求平摊的分配到多个服务上，从而达到HA，常见的负载均衡软件有Nginx，LVS，硬件F5等 Ribbon配置初步由于Ribbon是客户端的负载均衡工具，所以我们需要修改的是客户端项目microservicecloud-consumer-dept-80 POM.xml文件1234567891011121314151617&lt;!-- Ribbon相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml文件，添加Eureka的服务注册地址1234567server: port: 80eureka: client: register-with-eureka: false #自己不能注册 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 修改客户端配置类由于客户端使用restTemplate访问服务端中的数据接口，restTemplate配置在服务端的配置类中，所以修改如下 12345678@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改客户端主程序启动类1234567@SpringBootApplication@EnableEurekaClientpublic class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 修改客户端访问类DeptController_Consumer.java1private static final String REST_URL_PREFIX = \"http://MICROSERVICECLOUD-DEPT\"; 测试启动7001,7002,7003三个服务注册中心，启动8001服务提供者，启动80客户端，使用http://localhost/consumer/dept/list可以渠道对应的数据，在DeptController_Consumer使用的是http://MICROSERVICECLOUD-DEPT服务名称来调用服务的接口，相比之前的http://localhost:8001，Ribbon和Eureka整合后，Consumer可以直接通过服务名称来调用服务，而不再关心地址和端口号。 Ribbon负载均衡 目前只有一个microservicecloud-provider-dept-8001服务提供者，为了实现Ribbon的负载均衡，所以我们需要多个服务提供者实例，新建microservicecloud-provider-dept-8002，microservicecloud-provider-dept-8003两个Module。参考8001的pom.xml文件修改8002,8003的pom.xml文件。拷贝8001中的所以类和配置文件mybatis和application.yml文件，将主启动类修改为对应的名字 microservicecloud-provider-dept-8002服务提供者使用的数据库SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB02 ;CREATE DATABASE cloudDB02 CHARACTER SET UTF8 ;USE cloudDB02 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); Application.yml文件1234567891011121314151617181920212223server: port: 8002 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB02 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 microservicecloud-provider-dept-8003服务提供者使用的数据库SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB03 ;CREATE DATABASE cloudDB03 CHARACTER SET UTF8 ;USE cloudDB03 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); Application.yml文件1234567891011121314151617181920212223server: port: 8003 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB03 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 微服务提供者说明三个微服务提供者连接不同的数据库，因此在application.yml文件中，我们需要修改端口号和连接的数据库，注意的是三个微服务提供者的微服务名字保持一样，也就是如下的配置信息 123spring: application: name: microservicecloud-dept 负载均衡自测访问连接http://localhost:8001/dept/list，http://localhost:8002/dept/list，http://localhost:8003/dept/list得到不同数据库数据，当我们启动服务注册中心7001,7002,7003,再启动80客户端，这个时候访问localhost/consumer/dept/list，每次刷新就会得到不同数据库的数据。这就是Ribbon默认的轮询算法的负载均衡。 Ribbon核心组件IRuleRibbon负载均衡算法Ribbon默认提供的是轮询的负载均衡算法，完整了还有如下 RoundRobinRule 轮询 RandomRule 随机 AvaliabilityFilteringRule 会先过滤由于多次访问故障而处于断路器跳闸的状态的服务和并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略 WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大 RetryRule 先按照RoundRobinRule策略获取服务，如果获取服务失败会在指定时间内重试 BestAvailableRule 会先过滤掉由于多次访问故障二处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 ZoneAvoidanceRule 默认规则，复合判断server所在的区域的性能和server的可用性选择服务器 Ribbon负载均衡算法使用方法在客户端的配置类ConfigBean.java中添加IRule的实现 123456789101112@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public IRule myRule()&#123; return new RandomRule(); &#125;&#125; Ribbon自定义如果不使用Ribbon默认的七种负载均衡算法，这个时候就需要使用自定义负载均衡算法 客户端主启动类使用注解@RibbonClient12345678@SpringBootApplication@EnableEurekaClient@RibbonClient(name=\"MICROSERVICECLOUD-DEPT\",configuration=MySelfRule.class)public class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 特此说明 RibbonClient注解中的MySelfRule类使我们自定义负载均衡算法的类，但是，这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们这个自定义的配置类会被所有的Ribbon客户端所共享，也就说，达不到我们特殊化定制的目的。举例说明，自定义配置类不能放在项目主启动类所有的包以及子包下，因为主启动类使用注解@SpringBootApplication，这个注解点进去使用@ComponentScan注解 自定义负载均衡算法轮询算法中每一个服务轮询一次，现在需求是每一个服务调用五次后在轮询下一个服务 自定义配置类12345678910111213package com.luo.myrule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.netflix.loadbalancer.IRule;@Configurationpublic class MySelfRule &#123; @Bean public IRule myRule()&#123; return new RandomRule_lky(); &#125;&#125; 自定义算法类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.luo.myrule;import java.util.List;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;public class RandomRule_lky extends AbstractLoadBalancerRule&#123; // total = 0 // 当total==5以后，我们指针才能往下走， // index = 0 // 当前对外提供服务的服务器地址， // total需要重新置为零，但是已经达到过一个5次，我们的index = 1 // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？ private int total = 0; // 总共被调用的次数，目前要求每台被调用5次 private int currentIndex = 0; // 当前提供服务的机器号 public Server choose(ILoadBalancer lb, Object key)&#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; return null; &#125;// private int total = 0; // 总共被调用的次数，目前要求每台被调用5次// private int currentIndex = 0; // 当前提供服务的机器号 if(total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125;else &#123; total = 0; currentIndex++; if(currentIndex &gt;= upList.size()) &#123; currentIndex = 0; &#125; &#125; if (server == null) &#123; Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key)&#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig)&#123;&#125;&#125; #","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（五）Eureka和Zookeeper区别","slug":"JavaEE进阶知识学习-----SpringCloud（五）Eureka和Zookeeper区别","date":"2019-03-22T21:44:04.000Z","updated":"2019-03-22T13:34:34.129Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（五）Eureka和Zookeeper区别/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（五）Eureka和Zookeeper区别/","excerpt":"Eureka和Zookeeper区别遵循原则不同Eureka遵循AP原则，Zookeeper遵循CP原则，C：强一致性，A：可用性，P：分区容错性 著名的CAP理论中提出，一个分布式系统不可能同时满足C(一致性)A(可用性)P(分区容错性)，由于分区容错性p是分布式系统中必须保证，因此只能在A和C之间权衡","text":"Eureka和Zookeeper区别遵循原则不同Eureka遵循AP原则，Zookeeper遵循CP原则，C：强一致性，A：可用性，P：分区容错性 著名的CAP理论中提出，一个分布式系统不可能同时满足C(一致性)A(可用性)P(分区容错性)，由于分区容错性p是分布式系统中必须保证，因此只能在A和C之间权衡 Zookeeper保证CP在Zookeeper中存在一种情况下，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是，选举leader的时间太长，且选举过程中这个Zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪，在云部署的环境中，因为网络问题使得Zookeeper集群失去master节点的可能性较大，虽然服务最终能够恢复，但是在漫长的选举时间导致的注册时间不可用是不能容忍的，当我们向注册中心查询注册列表时，可以忍受注册中心返回的是几分钟以前的注册信息，但是不能接收服务直接down不可用，也就是说，服务注册对可用性的要求高于一致性。 Eureka保证APEureka知道Zookeeper的不足，所以设计最初就保证可用性，Eureka各个节点都是平等的，几个节点的挂点不会影响其他正常节点的工作，剩余的节点仍然可以提供注册和查询服务，只不过不能保证查询的信息是最新的，除此之外，Eureka还有一种自我保护机制，当过多的节点没有正常的心跳时，那么Eureka就会认为客户端出现了网络故障，此时Eureka会 Eureka不会从注册表中移除因为长时间没有收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点上（保证当前节点可用） 当网络稳定时，当前实例新的注册信息会被同步到其他节点上","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（四）Eureka集群配置","slug":"JavaEE进阶知识学习-----SpringCloud（四）Eureka集群配置","date":"2019-03-22T20:44:04.000Z","updated":"2019-03-22T13:34:19.262Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（四）Eureka集群配置/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（四）Eureka集群配置/","excerpt":"Eureka集群配置microservicecloud-eureka-7001使EurekaServer服务注册中心，一旦这个出现问题，那么微服务就不能正常的工作，为防止这种情况，所以出现了集群，就是建立多个microservicecloud-eureka-7002，microservicecloud-eureka-7003等服务注册中心。 新建microservicecloud-eureka-7002，microservicecloud-eureka-7003服务注册中心 根据microservicecloud-eureka-7001的pom.xml修改7002和7003的pom.xml文件 复制7001的主程序启动类，并修改为7002,7003即可","text":"Eureka集群配置microservicecloud-eureka-7001使EurekaServer服务注册中心，一旦这个出现问题，那么微服务就不能正常的工作，为防止这种情况，所以出现了集群，就是建立多个microservicecloud-eureka-7002，microservicecloud-eureka-7003等服务注册中心。 新建microservicecloud-eureka-7002，microservicecloud-eureka-7003服务注册中心 根据microservicecloud-eureka-7001的pom.xml修改7002和7003的pom.xml文件 复制7001的主程序启动类，并修改为7002,7003即可 修改映射配置 在7001注册中的application.yml文件中hostname，不能与7002,7003相同，所以要做映射配置 123eureka: instance: hostname: localhost #eureka服务端的实例名称 修改C:\\Windows\\System32\\drivers\\etc\\host文件,让127.0.0.1有三个别名 123127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com127.0.0.1 eureka7003.com microservicecloud-eureka-7001中的yml修改123456789101112server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ microservicecloud-eureka-7002中的yml修改123456789101112server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ microservicecloud-eureka-7003中的yml修改123456789101112server: port: 7003eureka: instance: hostname: eureka7003.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 修改dept微服务的yml文件dept微服务会同时注册到7001,7002,7003服务注册中心 12345eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 测试 访问eureka7001.com:7001 访问eureka7002.com:7002 访问eureka7003.com:7003","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（三）Eureka服务注册与发现","slug":"JavaEE进阶知识学习-----SpringCloud（三）Eureka服务注册与发现","date":"2019-03-22T19:44:04.000Z","updated":"2019-03-22T13:35:22.081Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（三）Eureka服务注册与发现/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（三）Eureka服务注册与发现/","excerpt":"Eureka服务注册与发现Eureka三大角色 Eureka Server提供服务注册和发现 Service Provider服务提供方将自身服务注册到Eureka， 从而使服务消费者能够找到 Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费","text":"Eureka服务注册与发现Eureka三大角色 Eureka Server提供服务注册和发现 Service Provider服务提供方将自身服务注册到Eureka， 从而使服务消费者能够找到 Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费 1.Eureka Server注册 在上述项目的父工程中新建microservicecloud-eureka-7001，这个module是Eureka的服务中心 POM.xml文件123456789101112131415161718192021222324252627&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-eureka-7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-server服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件1234567891011server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ EurekaServer主启动类1234567@SpringBootApplication@EnableEurekaServer// EurekaServer服务器端启动类，接收其它微服务注册进来public class EurekaServer7001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7001_App.class, args); &#125;&#125; 测试EurekaServer浏览器输入http://localhost:7001/，看到Spring Eureka界面表示成功，这个访问链接和程序中的application.yml配置吻合。 2.微服务注册将microservicecloud-provider-dept-8001微服务注册到microservicecloud-eureka-7001中 修改microservicecloud-provider-dept-8001的POM.xml文件123456789&lt;!-- 将微服务provider侧注册进eureka --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 修改microservicecloud-provider-dept-8001的application.yml文件1234eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka 说明：defaultZone的地址对应Eureka Server服务注册中心的application.yml中的defaultZone路径 microservicecloud-provider-dept-8001主程序类使用注解1234567@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心public class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 测试是否注册成功先启动Eureka服务注册中心microservicecloud-eureka-7001，启动微服务microservicecloud-provider-dept-8001，打开浏览器输入http://localhost:7001/，Application下出现**MICROSERVICECLOUD-DEPT**微服务名称，这个名称来源于microservicecloud-provider-dept-8001中application.ym文件中的配置属性，如下 123spring: application: name: microservicecloud-dept 3.微服务常用设置主机名称和服务名称修改在Eureka中注册的微服务的Status的名称显示localhost或者显示电脑主机名，所以要修改服务的主机名称，修改方法如下，修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 12instance: instance-id: microservicecloud-dept8001 访问信息有IP信息提示修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 123instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #访问路径可以显示IP地址 微服务info内容详细信息增加microservicecloud-provider-dept-8001中POM.xml文件 12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 总的父工程microservicecloud修改pom.xml添加构建build信息 12345678910111213141516171819202122&lt;build&gt; &lt;finalName&gt;microservicecloud&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 说明在src/main/resources目录下的配置文件 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;!-- 表示以$开始和以$结束的表示方法 --&gt; &lt;delimit&gt;$&lt;/delimit&gt; &lt;/delimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 12345info: app.name: luokangyuan-microservicecloud company.name: www.luokangyuan.com build.artifactId: $project.artifactId$ build.version: $project.version$ 4.Eureka的自我保护机制导致的原因默认情况下，如果EurekaServer在一定的时间内没有接收到某一个微服务实例的心跳，EurekaServer将会注销该实例，页面就会看见一串红色提示，但是当网络分区发生故障时，微服务与EurekaServer无法进行正常的通信，此时本不应该注销这个微服务实例，这个时候，Eureka的自我保护机制就可以解决这个问题，当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式，一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务），当网络故障恢复后，该EurekaServer节点就会自动退出自我保护模式。 总结在自我保护模式下，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例，当它收到的心跳数重新到阈值以上，该EurekaServer就会自动退出自我保护模式，也就是宁可保留错误的服务注册信息，也不盲目的删除任何可能健康的服务实例。 5.服务发现对于注册近Eureka里面的微服务，可以通过服务发现来获取该服务的信息 修改microservicecloud-provider-dept-8001的DeptController12345678910111213141516@Autowiredprivate DiscoveryClient client;@RequestMapping(value = \"/dept/discovery\", method = RequestMethod.GET)public Object discovery()&#123; List&lt;String&gt; list = client.getServices();//得到Eureka中所有的微服务 System.out.println(\"**********\" + list); List&lt;ServiceInstance&gt; srvList = client.getInstances(\"MICROSERVICECLOUD-DEPT\"); for (ServiceInstance element : srvList) &#123; System.out.println(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); &#125; return this.client;&#125; microservicecloud-provider-dept-8001主启动类添加注解12345678@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心@EnableDiscoveryClient // 服务发现public class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 自测试启动服务注册中心microservicecloud-eureka-7001，再启动microservicecloud-provider-dept-8001，访问http://localhost:8001/dept/discovery可以得到这个服务的info信息，/dept/discovery接口就是microservicecloud-provider-dept-8001这个服务暴露给外部访问的接口。使用http://localhost:8001/dept/discovery测试，就是自己测试能不能使用 外部访服务暴露的接口microservicecloud-consumer-dept-80调用microservicecloud-provider-dept-8001服务暴露在外的接口，修改microservicecloud-consumer-dept-80中的DeptController_Consumer，如下 12345// 测试@EnableDiscoveryClient,消费端可以调用服务发现@RequestMapping(value = \"/consumer/dept/discovery\")public Object discovery()&#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/discovery\", Object.class);&#125; 消费者访问接口测试启动microservicecloud-consumer-dept-80访问http://localhost/consumer/dept/discovery得到8001微服务信息 总结 microservicecloud-provider-dept-8001注册到EurekaServer服务中心 microservicecloud-provider-dept-8001将Controller中的某一个方法暴露出去（提供服务发现） microservicecloud-consumer-dept-80中的Controller就可以调用微服务暴露出来的接口","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（二）实践准备","slug":"JavaEE进阶知识学习-----SpringCloud（二）实践准备","date":"2019-03-22T18:44:04.000Z","updated":"2019-03-22T13:34:52.401Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（二）实践准备/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（二）实践准备/","excerpt":"SpringCloud实践准备项目技术版本SpringCloud版本：Dalston.SR1，SpringBoot版本：1.5.9 项目说明项目是使用SpringCloud将四个工程进行整合，microservicecloud整体父工程Project，microservicecloud-api公共子模块Module，microservicecloud-provider-dept-8001部门微服务提供者Module，microservicecloud-consumer-dept-80部门微服务消费者Module。","text":"SpringCloud实践准备项目技术版本SpringCloud版本：Dalston.SR1，SpringBoot版本：1.5.9 项目说明项目是使用SpringCloud将四个工程进行整合，microservicecloud整体父工程Project，microservicecloud-api公共子模块Module，microservicecloud-provider-dept-8001部门微服务提供者Module，microservicecloud-consumer-dept-80部门微服务消费者Module。 1.父类项目创建在逻辑视图中选择new-Maven Project-勾上创建简单项目-选择pom方式 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 2.公共组件项目创建在父项目上创建microservicecloud-api项目，注意是在microservicecloud上new一个maven module，packaging选择jar POM.xml文件12345678910111213141516171819&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Dept实体类123456789101112131415161718192021222324252627282930313233343536public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称、 private String db_source; // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 public Dept() &#123; super(); &#125; public Dept(Long deptno, String dname, String db_source) &#123; super(); this.deptno = deptno; this.dname = dname; this.db_source = db_source; &#125; public Long getDeptno() &#123; return deptno; &#125; public void setDeptno(Long deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getDb_source() &#123; return db_source; &#125; public void setDb_source(String db_source) &#123; this.db_source = db_source; &#125; @Override public String toString() &#123; return \"Dept [deptno=\" + deptno + \", dname=\" + dname + \", db_source=\" + db_source + \"]\"; &#125; 当我们每次都需要创建一个实体类的getter，setter，toString和构造器等方法时，如果增加一个字段就要重新生成方法，为了简化这种重复的操作，我们在前面的pom中引入了lombok，同样的实体类，使用方法如下 1234567891011@SuppressWarnings(\"serial\")@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain=true)public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称 // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 private String db_source; &#125; lombok安装方法拷贝lombok-1.16.18.jar到Eclipse目录下，执行java -jar D:\\javasoft\\eclipse-jee-neon-3-win32-x86_64\\eclipse\\ombok-1.16.18.jar，然后，弹框中选择Eclipse安装目录，选择install即可。 lombok注解使用1234567@Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual@Setter：注解在属性上；为属性提供 setting 方法@Getter：注解在属性上；为属性提供 getting 方法@Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象@NoArgsConstructor：注解在类上；为类提供一个无参的构造方法@AllArgsConstructor：注解在类上；为类提供一个全参的构造方法@Accessors(chain=true)：可以使用链式写法 lombok测试123456789101112131415@SuppressWarnings(\"serial\")@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain=true)public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称、 private String db_source; // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 public static void main(String[] args) &#123; Dept dept = new Dept(); dept.setDeptno(12L).setDname(\"开发部\").setDb_source(\"DB01\"); &#125;&#125; 注意内容实体类必须实现Serializable接口 打包使用公共组件模块写好后可以点击run as 选择maven clean ，然后在选择maven install。其他模块引用的方法如下 123&lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;&lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 3.部门微服务提供者首先现在父类项目上new一个maven module,microservicecloud-provider-dept-8001修改pom.xml文件 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-provider-dept-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678910111213141516171819202122232425262728server: port: 8001 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间 eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka mybatis下mybatis.cfg.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt;&lt;!-- 二级缓存开启 --&gt; &lt;/settings&gt;&lt;/configuration&gt; SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB01 ;CREATE DATABASE cloudDB01 CHARACTER SET UTF8 ;USE cloudDB01 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); dao接口12345678@Mapperpublic interface DeptDao &#123; public boolean addDept(Dept dept); public Dept findById(Long id); public List&lt;Dept&gt; findAll();&#125; DeptMapper.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.luo.springcloud.dao.DeptDao\"&gt; &lt;select id=\"findById\" resultType=\"Dept\" parameterType=\"Long\"&gt; select deptno,dname,db_source from dept where deptno=#&#123;deptno&#125;; &lt;/select&gt; &lt;select id=\"findAll\" resultType=\"Dept\"&gt; select deptno,dname,db_source from dept; &lt;/select&gt; &lt;insert id=\"addDept\" parameterType=\"Dept\"&gt; INSERT INTO dept(dname,db_source) VALUES(#&#123;dname&#125;,DATABASE()); &lt;/insert&gt;&lt;/mapper&gt; DeptService12345public interface DeptService &#123; public boolean add(Dept dept); public Dept get(Long id); public List&lt;Dept&gt; list();&#125; DeptServiceImpl1234567891011121314151617181920@Servicepublic class DeptServiceImpl implements DeptService&#123; @Autowired private DeptDao dao; @Override public boolean add(Dept dept) &#123; return dao.addDept(dept); &#125; @Override public Dept get(Long id) &#123; return dao.findById(id); &#125; @Override public List&lt;Dept&gt; list() &#123; return dao.findAll(); &#125;&#125; DeptController1234567891011121314151617181920@RestControllerpublic class DeptController &#123; @Autowired private DeptService service; @RequestMapping(value=\"/dept/add\",method=RequestMethod.POST) public boolean add(@RequestBody Dept dept)&#123; return service.add(dept); &#125; @RequestMapping(value=\"dept/get/&#123;id&#125;\",method=RequestMethod.GET) public Dept get(@PathVariable(\"id\") Long id)&#123; return service.get(id); &#125; @RequestMapping(value=\"dept/list\",method=RequestMethod.GET) public List&lt;Dept&gt; list()&#123; return service.list(); &#125;&#125; 创建主启动类DeptProvider8001_App123456@SpringBootApplicationpublic class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 测试结果输入http://localhost:8001/dept/list以JSON的方式返回数据 4.部门微服务消费者首先现在父类项目上new一个maven module,microservicecloud-consumer-dept-80修改pom.xml文件 POM.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-80&lt;/artifactId&gt; &lt;description&gt;部门微服务消费者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12server: port: 80 ConfigBean注解类1234567@Configurationpublic class ConfigBean &#123; @Bean public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125;&#125; RestTemplateRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单高效便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具类集，使用方法如下 （url,requestMap,ResponseBean.class）三个参数分别代表Rest请求地址，请求参数，HTTP响应转换被转换的对象类型 DeptController_Consumer123456789101112131415161718192021@RestControllerpublic class DeptController_Consumer &#123; private static final String REST_URL_PREFIX = \"http://localhost:8001\"; @Autowired private RestTemplate restTemplate; @RequestMapping(value=\"/consumer/dept/add\") public boolean add(Dept dept)&#123; return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\", dept, Boolean.class); &#125; @RequestMapping(value=\"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id)&#123; return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/get/\"+id, Dept.class); &#125; @RequestMapping(value=\"/consumer/dept/list\") public Dept list()&#123; return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/list/\", Dept.class); &#125;&#125; DeptConsumer80_App主类123456@SpringBootApplicationpublic class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 测试结果http://localhost/consumer/dept/list http://localhost/consumer/dept/get/2 http://localhost/consumer/dept/add?dname=AI","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud（一）概述","slug":"JavaEE进阶知识学习-----SpringCloud（一）概述","date":"2019-03-22T17:44:04.000Z","updated":"2019-03-22T13:34:47.476Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习-----SpringCloud（一）概述/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习-----SpringCloud（一）概述/","excerpt":"SpringCloud概述SpringCloud是什么SpringCloud，基于SpringBoot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，等组件。换句话说是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。 SpringBoot和SpringCloud SpringBoot专注于快速方便的开发单个个体微服务 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的单体微服务整合并管理，为各个微服务之间提供配置管理，服务发现，路由，分布式会话等集成服务 SpringBoot可以离开SpringCloud独立的开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系 SpringBoot专注于快速，方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架","text":"SpringCloud概述SpringCloud是什么SpringCloud，基于SpringBoot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，等组件。换句话说是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。 SpringBoot和SpringCloud SpringBoot专注于快速方便的开发单个个体微服务 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的单体微服务整合并管理，为各个微服务之间提供配置管理，服务发现，路由，分布式会话等集成服务 SpringBoot可以离开SpringCloud独立的开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系 SpringBoot专注于快速，方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架 Double和SpringCloud 首先可以在GitHub上看到二者的活跃度，其次是比较各功能组件的支持情况，最大的区别在于SpringCloud抛弃了Dubbo的RPC通信，采用的是HTTP的REST方式，如下： Dobbo SpringCloud 服务注册中心 Zookeeper SpringCloud Netflix Eureka 服务调用方式 RPC Rest API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netflix Hystrix 服务网关 无 Spring Cloud Netflix Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task SpringCloud资料SpringCloud各个组件的文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud中文API：https://springcloud.cc/spring-cloud-dalston.html","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习----SpringBoot高级（六）SpringBoot整合RabbitMQ","slug":"JavaEE进阶知识学习----SpringBoot高级（六）SpringBoot整合RabbitMQ","date":"2019-03-22T17:06:04.000Z","updated":"2019-03-22T13:36:20.770Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot高级（六）SpringBoot整合RabbitMQ/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot高级（六）SpringBoot整合RabbitMQ/","excerpt":"SpringBoot整合RabbitMQ 引入spring-boot-starter-amqp application.yml配置 测试RabbitMQ AmqpAdmin：管理组件 RabbitTemplate：消息发送处理组件","text":"SpringBoot整合RabbitMQ 引入spring-boot-starter-amqp application.yml配置 测试RabbitMQ AmqpAdmin：管理组件 RabbitTemplate：消息发送处理组件 整合前提是在Linux虚拟主机中的docker中安装rabbitmq镜像，并启动镜像。 新建项目，加入RabbitMQ依赖，SpringBoot的自动配置RabbitAutoConfiguration，有自动配置连接工厂ConnectionFactory，在RabbitProperties中封装了RabbitMQ的配置 在Application.properties文件中配置RabbitMQ 123spring.rabbitmq.host=118.24.44.169 #配置虚拟主机的地址spring.rabbitmq.username=guestspring.activemq.password=guest RabbitTemplate给RabbitMQ发送和接收消息 AmqpAdmin,是RabbitMQ中系统管理功能组件 测试使用RabbitTemplate发送消息1234567891011121314151617181920212223242526272829@Autowiredprivate RabbitTemplate rabbitTemplate;/** * 单播模式发送消息 */@Testpublic void contextLoads() &#123; //message需要自己构造一个，定义消息体内容和消息头 //rabbitTemplate.send(exchange,routeKey,message); //只需要传入要发送的对象，自动序列化发送给RabbitMQ //rabbitTemplate.convertAndSend(exchange,routeKey,object); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"msg\",\"这是第一个消息\"); map.put(\"data\", Arrays.asList(\"hello\",123,true)); //对象默认序列化以后被发送出去 rabbitTemplate.convertAndSend(\"exchange.direct\",\"luo.news\",map);&#125;/** * 接收数据,如何将数据转为JSON数据格式 */@Testpublic void receive()&#123; Object o = rabbitTemplate.receiveAndConvert(\"luo.news\"); System.out.println(o.getClass()); System.out.println(o);&#125; 如何将数据转为JSON数据格式定义MyAMQConfig配置类 12345678@Configurationpublic class MyAMQConfig &#123; @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; RabbitMQ中的监听service层中的代码如下1234567891011@Servicepublic class BookService &#123; /** * 注解的作用就是监听luo.new消息队列，一旦这个队列中有消息就会调用这个方法 * @param book */ @RabbitListener(queues = \"luo.new\") public void receive(Book book)&#123; System.out.println(\"收到消息，消息是；\"+book); &#125;&#125; 主配置类添加开启注解的RabbitMQ模式12345678@EnableRabbit@SpringBootApplicationpublic class SpringbootRabbitmqApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootRabbitmqApplication.class, args); &#125;&#125; AmqpAdmin的使用使用AmqpAdmin创建和删除Queue和Exchange等 测试如下123456789101112@Autowiredprivate AmqpAdmin amqpAdmin;@Testpublic void createExchange()&#123; amqpAdmin.declareExchange(new DirectExchange(\"amqpadmin.exchange\")); System.out.println(\"创建完成\"); amqpAdmin.declareQueue(new Queue(\"amqpadmin.queue\",true)); //创建绑定规则 amqpAdmin.declareBinding(new Binding(\"amqpadmin.queue\",Binding.DestinationType.QUEUE,\"amqpadmin.exchange\",\"amqp.test\",null));&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot高级（五）SpringBoot与消息","slug":"JavaEE进阶知识学习----SpringBoot高级（五）SpringBoot与消息","date":"2019-03-22T17:05:04.000Z","updated":"2019-03-22T13:36:03.891Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot高级（五）SpringBoot与消息/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot高级（五）SpringBoot与消息/","excerpt":"SpringBoot与消息概述 在大多数应用中，可以通过消息服务来提升系统异步通信，扩展解耦能力。 在消息服务中存在两个重要的概念：消息代理（message broker）和目的地（destination），当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地 消息队列主要有两种形式的目的地：队列（queue:点对点消息通信），主题（topic:发布/订阅消息通信）","text":"SpringBoot与消息概述 在大多数应用中，可以通过消息服务来提升系统异步通信，扩展解耦能力。 在消息服务中存在两个重要的概念：消息代理（message broker）和目的地（destination），当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地 消息队列主要有两种形式的目的地：队列（queue:点对点消息通信），主题（topic:发布/订阅消息通信） 点对点式 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 发布订阅式 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 JMS（JAva消息服务） 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 AMQP 高级消息队列协议，也是一个消息代理的规范，兼容JMS RabbitMQ是AMQP的实现 JMS和AMQP区别 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型：Peer-2-Peer和Pub/Sub 提供了五种消息模型：1.direct exchange2.fanout exchange3.topic change4.headers exchange5.system sxchange 支持消息类型 多种消息类型TextMessageMapMessageByteMessageStreamMessageObjectMessageMessage（只有消息和头和属性） byte[]当实际应用中，有复杂的消息，可以将消息序列化后发送 总体区别 JMS定义了Java API层面的标准，在java体系中，多个客户端 均可以使用JMS进行交互，不需要修改代码，对跨平台支持性较差。AMPQ定义了wirte-levelc层的协议标准，天然具有跨平台，跨语言的特性。 Spring支持 spring-jms提供了对JMS的支持 spring-rabbit提供了对AMQP的支持 需要ConnectionFactory的实现来连接消息代理 提供JmsTemplate、RabbitTemplate来发送消息 @JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息 @EnableJms、@EnableRabbit开启支持 RabbitMQ简介RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现 核心概念Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储） Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。 Connection 网络连接，比如一个TCP连接。 Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP 连接。 Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost 本质上就是一个mini 版的RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的vhost 是/ 。 Broker 表示消息队列服务器实体 整体简单流程 RabbitMQ运行机制AMQP 中的消息路由 AMQP 中消息的路由过程和Java 开发者熟悉的JMS 存在一些差别，AMQP 中增加了Exchange和Binding的角色。生产者把消息发布到Exchange 上，消息最终到达队列并被消费者接收，而Binding 决定交换器的消息应该发送到那个队列。 Exchange 类型 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配AMQP 消息的header 而不是路由键，headers 交换器和direct 交换器完全一致，但性能差很多，目前几乎用不到了,下面将对这三种进行说明。 direct Exchange 消息中的路由键（routing key）如果和Binding 中的binding key 一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。 fanout Exchange 每个发到fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。 topic Exchange topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配一个单词。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot高级（四）SpringBoot整合Redis","slug":"JavaEE进阶知识学习----SpringBoot高级（四）SpringBoot整合Redis","date":"2019-03-22T17:04:04.000Z","updated":"2019-03-22T13:36:31.402Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot高级（四）SpringBoot整合Redis/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot高级（四）SpringBoot整合Redis/","excerpt":"整合redis实现缓存Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 在虚拟机中安装使用docker,使用SmarTTY-2.2客户端连接虚拟机 安装redis使用的docker国内镜像 引入redis的starter","text":"整合redis实现缓存Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 在虚拟机中安装使用docker,使用SmarTTY-2.2客户端连接虚拟机 安装redis使用的docker国内镜像 引入redis的starter pom.xml文件 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.properties文件1spring.redis.host=118.24.44.169 # 配置Linux的主机地址 测试Redis1234567891011121314151617181920212223242526272829@AutowiredStringRedisTemplate stringRedisTemplate; //操作k-v都是字符串的@AutowiredRedisTemplate redisTemplate; //k-v都是对象的/*** Redis常见的五大基本数据类型* String（字符串），list（列表），set（集合），Hash（散列），ZSet（有序集合）* stringRedisTemplate.opsForValue()操作字符串的* stringRedisTemplate.opsForList()操作列表* stringRedisTemplate.opsForSet()操作集合* stringRedisTemplate.opsForHash()操作散列*stringRedisTemplate.opsForZSet()操作有序集合*/@Testpublic void test01()&#123; stringRedisTemplate.opsForValue().append(\"msg\",\"hello\");//给redis中key为msg追加一个hello字符串&#125;/*** 测试保存对象*/@Testpublic void test01()&#123; Employee emp = employeeMapper.getEmpById(1); //默认保存对象，使用的是jdk序列化机制，序列化后的数据保存到redis中 redisTemplate.opsForValue().set(\"emp-01\",emp);&#125; 在上述中保存对象到redis中使用的是jdk的序列化机制，如果我们需要将employee对象以JSON的方式保存到redis中，可以使用将对象转为JSON,也可以改变默认的序列化规则，如下 序列化配置类 123456789101112@Configurationpublic class MyRedisTemplate &#123; @Bean public RedisTemplate&lt;Object,Employee&gt; empRedisTemplate( RedisConnectionFactory redisConnectionFactory)throws UnknownHostException&#123; RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;Object,Employee&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; ser = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); return template; &#125;&#125; 测试 123456789@AutowiredRedisTemplate&lt;Object,Employee&gt; empRedisTemplate;@Testpublic void test03()&#123; Employee emp = employeeMapper.getEmpById(1); //保存对象，使用的是Json序列化机制，序列化后的数据保存到redis中 empRedisTemplate.opsForValue().set(\"emp-01\",emp);&#125; 测试Redis缓存当我们引入redis的starter后，容器中保存的是RedisCacheManager，RedisCacheManager会创建一个RedisCache来作为缓存组件，RedisCache就是操作redis来缓存数据，这个时候执行上述的缓存测试就以默认的序列化保存到redis中。如何让保存的数据是json格式，就需要自定义CacheManager","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot高级（三）缓存注解","slug":"JavaEE进阶知识学习----SpringBoot高级（三）缓存注解","date":"2019-03-22T17:03:04.000Z","updated":"2019-03-22T13:36:26.633Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot高级（三）缓存注解/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot高级（三）缓存注解/","excerpt":"注解@CachePut使用 既调用方法，又更新缓存数据，当修改了数据库的某一个数据，同时更新缓存","text":"注解@CachePut使用 既调用方法，又更新缓存数据，当修改了数据库的某一个数据，同时更新缓存service层代码如下 12345@CachePut(value = \"emp\")public Employee updateEmp(Employee employee)&#123; employeeMapper.updateEmp(employee); return employee;&#125; Controller层代码如下 12345@GetMapping(\"emp\")public Employee update(Employee employee)&#123; Employee emp = employeeService.updateEmp(employee); return emp;&#125; 测试说明 先查询id为1的员工信息，第一次请求将查询数据库，然后放入缓存中 在执行更新id为1的员工信息，再查询id为1的员工信息，返回的是更新之前缓存中的员工信息 原因在于 @Cacheable中的key默认是参数，值是返回结果，查询缓存key是1，value是employee对象，更新方法中的@CachePut注解key是传入的employee对象，value是返回的employee对象， 更新之后查询应该返回的是更新的数据，也就是缓存中的数据没有更新，原因在于两次的key不一样导致，修改如下 12345 @CachePut(value = \"emp\" ,key = \"#employee.id\")public Employee updateEmp(Employee employee)&#123; employeeMapper.updateEmp(employee); return employee;&#125; 注解@CacheEvict的使用 注解@CacheEvict清除缓存，通过使用value，key属性清除指定缓存中指定key的缓存数据,有一个allEntries属性，默认是false，意思就是是否删除指定缓存中的所有key的缓存数据。beforeInvocation = false属性表示缓存的清除是否在方法执行之前执行，默认是在方法之后执行，如果出现异常就不会清除缓存，如果在方法之前执行，就是不管方法是否执行成功都会清除缓存数据 services层代码如下 1234@CacheEvict(value = \"emp\",key = \"#id\")public void deleteEmpById(Integer id)&#123; employeeMapper.deleteEmpById(id);&#125; controller层代码如下 1234@GetMapping(\"/delemp/&#123;id&#125;\")public void deleteEmp(@PathVariable(\"id\")Integer id)&#123; employeeService.deleteEmpById(id);&#125; @Cacheable，@CachePut，@CacheEvict的区别 注解@Cacheable是先调用缓存中的数据，如果没有在调用@Cacheable注解的方法 注解@CachePut是先调用目标方法，然后再将目标方法的返回结果放入缓存数据中 注解@CacheEvict的执行先后可以谁用属性配置改变 注解@Caching复杂缓存配置的使用 Mapper层代码如下 12@Select(\"select * from employee where lastName = #&#123;lastName&#125;\")Employee getEmpByLastName(String lastName); service层代码如下 12345678910111213 @Caching( cacheable = &#123; @Cacheable(value = \"emp\",key = \"#lastName\") &#125;, put = &#123; @CachePut(value = \"emp\",key = \"#result.id\"), @CachePut(value = \"emp\",key = \"#result.email\") &#125; )public Employee getEmpByLastName(String lastName)&#123; Employee emp = employeeMapper.getEmpByLastName(lastName); return emp;&#125; 上述定义的复杂缓存规则简单讲就是使用名字查询后，缓存中有了key为id的缓存信息，key为email的缓存信息 Controller层代码如下 1234@GetMapping(\"/emp/lastName/&#123;lastName&#125;\")public Employee getEmpByLastName(@PathVariable(\"lastName\") String lastName)&#123; return employeeService.getEmpByLastName(lastName);&#125; 注解@CacheConfig的使用 在前面中我们对每一个方法都写了@CacheEvict(value = “emp”,key = “#id”)中的value属性，指定缓存到哪里。我们可以使用@CacheConfig注解指明一个类的所有方法都缓存到哪里，用什么key等信息 123@Service@CacheConfig(cacheNames = \"emp\")public class EmployeeService &#123; 总结 缓存默认使用的ConcurrentMapCacheManager == ConcurrentMapCache，将数据保存在ConcurrentMap,但是在开发中我们经常使用的缓存中间件：redis，memcached.ehcahe等","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot高级（二）SpringBoot使用缓存","slug":"JavaEE进阶知识学习----SpringBoot高级（二）SpringBoot使用缓存","date":"2019-03-22T17:02:04.000Z","updated":"2019-03-22T13:36:12.572Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot高级（二）SpringBoot使用缓存/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot高级（二）SpringBoot使用缓存/","excerpt":"缓存使用1.使用IDEA创建SpringBoot项目，引入cache模块，web模块，mysql模块，Mybatis模块 2.创建mysql数据库spring_cache","text":"缓存使用1.使用IDEA创建SpringBoot项目，引入cache模块，web模块，mysql模块，Mybatis模块 2.创建mysql数据库spring_cache123456789101112131415161718192021222324SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for employee-- ----------------------------DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `gender` int(2) DEFAULT NULL, `d_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3.创建JavaBean封装数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.springboot.cache.bean;public class Employee &#123; private Integer id; private String lastName; private String email; private Integer gender; //性别 1男 0女 private Integer dId; public Employee() &#123; super(); &#125; public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.dId = dId; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Integer getdId() &#123; return dId; &#125; public void setdId(Integer dId) &#123; this.dId = dId; &#125; @Override public String toString() &#123; return \"Employee [id=\" + id + \", lastName=\" + lastName + \", email=\" + email + \", gender=\" + gender + \", dId=\" + dId + \"]\"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.springboot.cache.bean;public class Department &#123; private Integer id; private String departmentName; public Department() &#123; super(); // TODO Auto-generated constructor stub &#125; public Department(Integer id, String departmentName) &#123; super(); this.id = id; this.departmentName = departmentName; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; @Override public String toString() &#123; return \"Department [id=\" + id + \", departmentName=\" + departmentName + \"]\"; &#125;&#125; 4.整合Mybatis Application.properties中配置数据源 1234567spring.datasource.url=jdbc:mysql://localhost:3306/spring_cachespring.datasource.username=rootspring.datasource.password=1234spring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.configuration.map-underscore-to-camel-case=truelogging.level.com.springboot.cache.mapper = debug 使用注解版的Mybatis 使用@MapperScan指定需要扫描的Mapper接口所在的包 1234567@MapperScan(\"com.springboot.cache.mapper\")@SpringBootApplicationpublic class CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CacheApplication.class, args); &#125;&#125; 编写Employee接口和DepartmentMapper接口 123456789101112131415@Mapperpublic interface EmployeeMapper &#123; @Select(\"select * from employee where id = #&#123;id&#125;\") public Employee getEmpById(Integer id); @Update(\"update employee set lastName = #&#123;lastName&#125;,email = #&#123;email&#125;,gender = #&#123;gender&#125;,d_id = #&#123;did&#125; where id = #&#123;id&#125;\") public void updateEmp(Employee employee); @Delete(\"delete from employee where id = #&#123;id&#125;\") public void deleteEmpById(Integer id); @Insert(\"insert into employee(lastName.email,gender,d_id) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;did&#125;)\") public void insertEmployee(Employee employee);&#125; 编写service层代码 12345678910@Servicepublic class EmployeeService &#123; @Autowired private EmployeeMapper employeeMapper; public Employee getEmp(Integer id)&#123; return employeeMapper.getEmpById(id); &#125;&#125; 编写controller层代码 123456789101112@RestControllerpublic class EmployeeController &#123; @Autowired private EmployeeService employeeService; @GetMapping(\"/emp/&#123;id&#125;\") public Employee getEmployee(@PathVariable(\"id\") Integer id)&#123; Employee emp = employeeService.getEmp(id); return emp; &#125;&#125; 5.开启基于注解@EnableCaching的缓存 123456789@MapperScan(\"com.springboot.cache.mapper\")@SpringBootApplication@EnableCachingpublic class CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CacheApplication.class, args); &#125;&#125; 6.标注缓存注解即可 12345678910111213141516@Servicepublic class EmployeeService &#123; @Autowired private EmployeeMapper employeeMapper; /** * 将方法结果进行缓存，以后再要相同的数据，就直接从缓存中去 * @param id * @return */ @Cacheable(cacheNames = \"emp\" , key = \"#id\") public Employee getEmp(Integer id)&#123; return employeeMapper.getEmpById(id); &#125;&#125; 注解@Cacheable说明： 将方法结果进行缓存，以后再要相同的数据，就直接从缓存中去 属性说明： cacheNames/value:指定缓存组件的名字，CacheManager管理多个cache组件，对缓存的真正CRUD操作在Cache中，每一个缓存都有自己唯一的一个名字 key:缓存数据使用的key,可以使用这个属性来指定，默认是使用方法参数的值1，方法的返回值 1@Cacheable(cacheNames = \"emp\" , key = \"#id\") 缓存的名字是emp，key是方法中参数id的值，这种写法还有如下可以取到其他参数 | 名字 | 描述 | 示例 || ———– | ———————————————————— | ——————– || methodName | 当前被调用的方法名 | #root.methodName || method | 当前被调用的方法 | #root.method.name || target | 当前被调用的目标对象 | #root.target || targetClass | 当前被调用的目标对象类 | #root.targetClass || args | 当前被调用的方法的参数列表 | #root.args[0] || caches | 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”,”cache2”})），则有两个cache | #root.caches[0].name || result | 方法执行后的返回值 | #result | CacheManager属性：指定缓存管理器 condition:指定符合条件的才进入缓存 1@Cacheable(cacheNames = \"emp\",condition = \"#id &gt; 0\") unless：否定缓存，当unless指定的条件为true,该方法的返回值就不会被缓存，可以获取结果进行判断 12// 使用unless判断结果为null就不缓存@Cacheable(cacheNames = \"emp\",condition = \"#id &gt; 0\",unless = \"#result == null \")","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-12-web","slug":"JavaEE进阶知识学习----SpringBoot-12-web","date":"2019-03-22T17:01:12.000Z","updated":"2019-03-22T13:37:22.590Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-12-web/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-12-web/","excerpt":"SpringBootWeb开发1.SpringBoot静态资源映射规则","text":"SpringBootWeb开发1.SpringBoot静态资源映射规则 1234567891011121314151617public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/META-INF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; &#125; 1、所有的/webjars/**,都去classpath:/META-INF/resources/webjars/找资源 webjars:以jar包的方式引入资源，网页搜索webjars,选择maven的方式引入，例如引入jquery 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 访问jQuery.js的路径为：localhost:8080/webjars/jquery/3.3.1/jquery.js 2.“/**”访问当前项目的任何资源，（静态资源的文件夹） 12345\"classpath:/META-INF/resources/\",\"classpath:/resources/\",\"classpath:/static/\",\"classpath:/public/\"\"/\":当前项目的根路径 访问l路径：localhost:8080/asserts/js/bootstrap.min.js 3.欢迎页面映射 1234 @Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125; 静态资源文件夹下的index.html,例如访问localhost:8080 4.映射网页小图标，在静态资源文件夹下找 123456789101112@Configuration@ConditionalOnProperty( value = &#123;\"spring.mvc.favicon.enabled\"&#125;, matchIfMissing = true)public static class FaviconConfiguration implements ResourceLoaderAware &#123; private final ResourceProperties resourceProperties; private ResourceLoader resourceLoader; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; 项目结构如下图： 2.SpringBoot引入thymeleaf1、pom.xml文件中引入thymeleaf 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2、默认使用的thymeleaf版本低，修改版本 123456789&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 3.Thymeleaf基本使用123456789101112@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; //只要我们将HTML页面存放在classpath:/templates/目录中，thymeleaf就能自动渲染 注意：thymeleaf能渲染html页面，在Controller使用注解@Controller，不能使用@RestController注解。 使用thymeleaf方法如下： html页面引入thymeleaf域名空间 Controller类中收发请求和传递数据 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功页面&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为指定的值--&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789@Controllerpublic class HelloController &#123; @RequestMapping(\"/success\") public String success(Map&lt;String,Object&gt; map)&#123; map.put(\"hello\",\"你好\"); return \"success\"; &#125;&#125; 4.Thymeleaf语法1、th:text:改变当前元素的文本内容的；可以使用th:任意html属性：来替换原生属性的值 1&lt;div id=\"test\" class=\"test\" th:id=\"$&#123;hello&#125;\" th:class=\"$&#123;hello&#125;\" th:text=\"$&#123;hello&#125;\"&gt;&lt;/div&gt; 1&lt;div id=\"你好\" class=\"你好\"&gt;你好&lt;/div&gt; Order Feature Attributes 1 片段包含 th:insert`th:replace` 2 遍历 th:each 3 条件判断 th:if`th:unlessth:switchth:case` 4 声明变量 th:object`th:with` 5 任意属性修改 th:attr`th:attrprependth:attrappend` 6 修改指定属性默认值 th:value`th:hrefth:src…` 7 修改标签体内容 th:text（转义特殊字符）th:utext（不转义） 8 声明片段 th:fragment 9 移除片段 th:remove 2、表达式语法（参考thymeleaf官方文档第四章） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Simple expressions:(表达式语法) 一、Variable Expressions: $&#123;...&#125;:获取变量值，OGNL 1、获取对象的属性，调用方法 $&#123;person.father.name&#125; $&#123;person[&apos;father&apos;][&apos;name&apos;]&#125; $&#123;countriesByCode.ES&#125; $&#123;personsByName[&apos;Stephen Zucchini&apos;].age&#125; $&#123;personsArray[0].name&#125; $&#123;person.createCompleteName()&#125; $&#123;person.createCompleteNameWithSeparator(&apos;-&apos;)&#125; 2、使用内置的对象（使用方法参见官方文档第四章的附录） #ctx: the context object. #vars: the context variables. #locale: the context locale. #request: (only in Web Contexts) the HttpServletRequest object. #response: (only in Web Contexts) the HttpServletResponse object. #session: (only in Web Contexts) the HttpSession object. #servletContext: (only in Web Contexts) the ServletContext object. 3、内置工具对象（使用方法参见官方文档第四章的附录） #execInfo: #messages: #uris: #conversions: #dates: #calendars: #numbers: methods for formatting numeric objects. #strings: #objects: methods for objects in general. #bools: methods for boolean evaluation. #arrays: methods for arrays. #lists: methods for lists. #sets: methods for sets. #maps: methods for maps. #aggregates: #ids: 二、 Selection Variable Expressions: *&#123;...&#125;：选择表达式，功能和$&#123;&#125;一样 &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; 配合 th:object=&quot;$&#123;session.user&#125;&quot;使用，*相当于th:object 三、Message Expressions: #&#123;...&#125;：获取国际化内容 四、Link URL Expressions: @&#123;...&#125;：定义URL链接 @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; 五、Fragment Expressions: ~&#123;...&#125;：片段引用Literals（字面量） Text literals: &apos;one text&apos;, &apos;Another one!&apos;,… Number literals: 0, 34, 3.0, 12.3,… Boolean literals: true, false Null literal: null Literal tokens: one, sometext, main,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: +, -, *, /, % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and, or Boolean negation (unary operator): !, notComparisons and equality:（比较运算）Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)Equality operators: ==, != (eq, ne)Conditional operators:（条件运算，三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 5.thymeleaf基本使用controller数据准备如下： 123456@RequestMapping(\"/success\") public String success(Map&lt;String,Object&gt; map)&#123; map.put(\"hello\",\"&lt;h1&gt;你好&lt;/h1&gt;\"); map.put(\"list\" , Arrays.asList(\"张三\",\"李四\",\"王五\")); return \"success\"; &#125; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功页面&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为指定的值--&gt; &lt;div id=\"test\" class=\"test\" th:id=\"$&#123;hello&#125;\" th:class=\"$&#123;hello&#125;\" th:text=\"$&#123;hello&#125;\"&gt;&lt;/div&gt; &lt;span th:text=\"$&#123;#locale.country&#125;\"&gt;US&lt;/span&gt; &lt;hr&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;&lt;/div&gt;&lt;!--会转义输出&lt;h1&gt;你好&lt;/h1&gt;--&gt; &lt;div th:utext=\"$&#123;hello&#125;\"&gt;&lt;/div&gt;&lt;!--不会转义--&gt; &lt;hr&gt; &lt;!--th:each每次遍历都会生成当前这个标签，三个h4标签--&gt; &lt;h4 th:text=\"$&#123;li&#125;\" th:each=\"li:$&#123;list&#125;\"&gt;&lt;/h4&gt; &lt;hr&gt; &lt;h4&gt; &lt;!--高级写法：行内写法：[[...]] or [(...)]相当于th:text和th:utext--&gt; &lt;span th:each=\"user:$&#123;list&#125;\"&gt;[[$&#123;user&#125;]]&lt;/span&gt;&lt;!--三个span标签--&gt; &lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 6.扩展SpringMVC例如需要扩展如下SpringMVC功能： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--将hello请求也解析到success页面--&gt; &lt;mvc:view-controller path=\"/hello\" view-name=\"success\" /&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 编写一配置类（@Configuration），继承WebMvcConfigurationSupport，不能标注@EnableWebMvc注解，需要扩展什么功能，就重写什么方法 12345678910//使用WebMvcConfigurationSupport扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurationSupport &#123; @Override protected void addViewControllers(ViewControllerRegistry registry) &#123; //浏览器发送luo请求就直接来到success页面 registry.addViewController(\"luo\").setViewName(\"success\"); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-11-日志框架","slug":"JavaEE进阶知识学习----SpringBoot-11-日志框架","date":"2019-03-22T17:01:11.000Z","updated":"2019-03-22T13:37:18.049Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-11-日志框架/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-11-日志框架/","excerpt":"SpringBoot中的日志框架学习日志框架中我们选择的是SLF4J日志门面。日志实现选择的是Logback。调用日志记录的方法，不应该直接调用实现类，而是调用日志抽象层里面的方法。 1.使用slf4j的方法","text":"SpringBoot中的日志框架学习日志框架中我们选择的是SLF4J日志门面。日志实现选择的是Logback。调用日志记录的方法，不应该直接调用实现类，而是调用日志抽象层里面的方法。 1.使用slf4j的方法 给系统导入slf4j包和日志实现Logback包，如果要使用log4j,就导入slf4j和slf4j-log4、log4j包 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件，使用slf4j以后，配置文件还是写日志实现框架的配置文件。 2.统一日志记录统一日志框架官方图示 统一日志框架方法总结1、将系统中的其他日志框架先排除出去。 2、用中间包来替换原有的日志框架。 3、我们导入slf4j其他的实现 3.SpringBoot中的日志关系123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; SpringBoot使用下面的日志 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; SpringBoot日志依赖图示 SpringBoot底层使用slf4j+logback的方式进行日志记录。同时将其他日志框架也装换为slf4框架。 如果我们使用其他框架，就先把这个框架的默认日志框架给排除，例如我们使用Spring，就先排除Spring默认的commons-logging日志框架。 4.SpringBoot中使用slf4jSpringBoot默认配置了日志框架，我们直接就可以使用，如下 12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootConfigApplicationTests &#123; //日志记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; //日志级别，由低到高，可以调整输入的日志级别，日志就只会在这个级别和更高的级别生效 logger.trace(\"这是trace日志\"); logger.debug(\"这是debug日志\"); //SpringBoot默认使用的是info级别的，即trace和debug不会被打印输出 logger.info(\"这是自定义的info日志\"); logger.warn(\"这是警告日志\"); logger.error(\"这是错误日志\"); &#125;&#125; 修改日志级别的方法，添加配置文件 12logging: level: debug 指定日志文件输出位置 logging.file logging.path Example Desciption (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的spring.log文件中 logging.file不指定路径在当前项目下生成springboot.log文件，也可以指定路径D:/springboot.log logging.path指定为/spring/log就会在当前磁盘的根路径下创建一个spring文件夹和log文件夹，使用spring.log为日志文件。 5.使用自己的配置文件如果使用logback配置文件，就吧logback.xml放在项目resources目录下即可， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan=\"false\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name=\"LOG_HOME\" value=\"/app/log\" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name=\"appName\" value=\"atguigu-springboot\"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name=\"appLogAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式： --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出， false：表示只用当前logger的appender-ref，true： 表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;logger name=\"com.atguigu\" level=\"debug\" /&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name=\"org.springframework\" level=\"debug\" additivity=\"false\"&gt;&lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\" /&gt; &lt;appender-ref ref=\"appLogAppender\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 如果将logback.xml更改为logback-spring.xml就是有SpringBoot解析日志配置，就可以使用SpringBoot的Profile功能，指定在某种开发环境下才生效。 12345678&lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-10-配置文件","slug":"JavaEE进阶知识学习----SpringBoot-10-配置文件","date":"2019-03-22T17:01:10.000Z","updated":"2019-03-22T13:37:54.851Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-10-配置文件/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-10-配置文件/","excerpt":"一、Spring Boot学习笔记-配置文件1.yaml语法基本语法：k:(空格)v ：表示一对键值对，注意的是空格不能省略，以空格的缩进来控制层级关系，左对齐的一列数据就是同一个层级的。注意的是属性和值也是大小写敏感的。例如","text":"一、Spring Boot学习笔记-配置文件1.yaml语法基本语法：k:(空格)v ：表示一对键值对，注意的是空格不能省略，以空格的缩进来控制层级关系，左对齐的一列数据就是同一个层级的。注意的是属性和值也是大小写敏感的。例如1234567891011spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/swrhdemo1 username: root password: 1234 jpa: database: mysql show-sql: trueserver: port: 8080 2.值的写法值为普通的值（数字，字符串，布尔）：k: v ：就直接写值，注意，字符串默认不用添加单引号和双引号。 “”:双引号：不会转义字符串里面的特殊字符；特殊字符会作为本身想表达的意思 ‘’:单引号：会转义字符串里面的特殊字符，特殊字符最终就是一个普通的字符 值为对象，Map使用k: 下一行写对象的属性和值 值为集合，使用k: 下一行使用-(空格)值来书写。所有数据结构的书写方法如下所示， 1234567891011person: name: \"张三\\n李四\" age: 14 map: &#123;k1: V1,k2: V2&#125; list: - cat - dog - pig cat: name: '小猫\\n小狗' age: 4 上述yaml文件锁对应的Javabean如下所示： 12345678910111213@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private int age; private Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); private List&lt;String&gt; list = new ArrayList&lt;&gt;(); private Cat cat; 说明： @ConfigurationProperties(prefix = “person”)注解是获取yaml文件中的配置 其中prefix = “person”表示获取yaml中前缀为person的值 要使用ConfigurationProperties注解，最好在pom.xml文件中做如下配置 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 3.配置文件注入从前面我们可以知道将配置文件中属性和值注入到bean实体类中，我们可以使@ConfigurationProperties注解，除此之外，我们还可以使用@Value注解，使用方法如下： 123456789101112@Componentpublic class Person &#123; @Value(\"$&#123;person.name&#125;\") private String name; @Value(\"#&#123;11*2&#125;\") private int age; private Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); private List&lt;String&gt; list = new ArrayList&lt;&gt;(); private Cat cat; 注意的是：@Value注解只能用于基本类型的值注入，与@ConfigurationProperties注解的区别如下： @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 单个指定 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 使用JSR303进行字段校验的同时，在bean类上使用@Validated注解。 4.外部配置文件使用@PropertySource(value ={“classpath: person.properties”})加载指定的配置文件 其中person.properties书写如下： 123456789person.last-name=\\u674E\\u56DBperson.age=12person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=dogperson.dog.age=15 使用@ImportResource(locations = {“classpath: beans.xml”})注解加载Spring配置文件。如下 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; 但是，在SpringBoot中不推荐再继续使用xml配置文件来启动项目，推进使用全注解的方式来给容器添加组件，使用@bean注解和@Configuration注解，如下： 说明： @Configuration注解指明当前类是一个配置类，就是用来代替之前的Spring.xml配置文件 在Spring.xml文件中，使用标签来添加组件，在配置类中使用@bean注解 @bean注解标记在方法中就是将方法的返回值添加到容器中，容器中这个组件的默认id就是方法名 1234567@Configurationpublic class APPConfig &#123; @Bean public HelloServices helloServices()&#123; return new HelloServices(); &#125;&#125; 5.配置文件中的占位符配置文件中可以使用随机数：${random.value/int/long}等。 也可以在配置文件中引用前面已经配置了的属性：${app.name:默认值} 1234567891011person: name: \"张三\\n李四$&#123;random.int&#125;\" age: 14 map: &#123;k1: V1,k2: V2&#125; list: - cat - dog - pig cat: name: '$&#123;person.name&#125;小猫\\n小狗' age: 4 6.Profile多环境支持 使用多Profile文件的方法，在编写配置文件名时带上不同环境的标识，文件名application-{profile}.yml 使用yaml多文档块的方式 激活指定的profile 第一种方法就是在建立不同的配置文件application.yml、application-dev.yml、application-pro.yml。程序默认使用application.yml，在application.yml中使用spring.profiles.active=dev来激活指定的配置文件。 第二种配置方法如下 123456789101112131415server: port: 8080Spring: profiles: active: dev---server: port: 8081spring: profiles: dev---server: port: 8084spring: profiles: pro 激活指定环境也可以在项目打成jar包的时候使用命令的形式java -jar jar名 –spring.profiles.active=dev 7.配置文件加载位置SpringBoot启动的时候会扫描以下位置的application.yml文件作为SpringBoot的默认配置文件 file:./config/ 项目根目录下的config文件 file:./ 项目根目录下 classpath:/config/ 项目src/main/resources/config目录下 classpath:/ 项目src/main/resources/目录下 以上是按照优先级从高到底的顺序，所有位置的文件都会被加载，高优先级配置会覆盖低优先级配置的内容。 可以通过spring.config.location来改变默认配置，使用方法就是在项目打包后使用的命令的形式将外在配置文件和项目的配置文件形成互补， java -jar jar名 –spring.config.location=D:/application.yml 8.自动配置原理application.yml文件中到底都能配置什么，详情参考SpringBoot官方文档 SpringBoot启动的时候加载主配置类，在主配置类中使用了@SpringBootApplication注解，点进去发现会开启@EnableAutoConfiguration注解自动配置。 @EnableAutoConfiguration的作用：利用@Import({AutoConfigurationImportSelector.class})给容器中导入一些组件，点进去找到selectImports方法中List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); SpringFactoriesLoader.loaFactoryNames()扫描所有jar包类路径下WETN_INF/Spring.factories,把扫描到的这些文件的内容包装成一个properties对象，从properties中获取EnableAutoConfiguration.class类（类名）对应的值，然后将他们添加到容器中 总结将类路径下WETA-INF/Spring.factories里面配置的所有EnableAutoConfiguration的值加入到容器中 以HttpEncodingAutoConfiguration为例解释自动配置原理 12345678910111213@Configuration //表示这是一个配置类@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)//启动指定类的ConfigurationProperties功能@ConditionalOnWebApplication(//Spring底层有@conditiona注解，根据不同的条件，如果满足指定的条件才会让配置类中的配置就会生效，判断当前应用是否为web应用。 type = Type.SERVLET)@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断当前项目中有没有CharacterEncodingFilter这个类@ConditionalOnProperty(//判断配置文件中是否存在某个配置spring.http.encoding prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true) 根据当前不同的条件判断，决定这个配置类是否生效。 所有可以在配置文件中能配置的属性都是在xxxProperties类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties( prefix = \"spring.http.encoding\")//从配置文件中获取指定的值和bean的属性进行绑定，也就是说在yaml文件中可以配置spring.http.encodingpublic class HttpEncodingProperties &#123; 9.SpringBoot自动配置的精髓SpringBoot在启动的时候就会加载大量的自动配置类 我们看我们需要的功能有没有在SpringBoot默认写好的自动配置文件类中，如果自动配置文件类中有我们需要的组件，就不在需要我们配置。 1、快捷键Alt+Shift+N打开自动搜索，输入*AutoConfiguration，选择自己需要的配置文件类 2、在配置文件类中选择注解xxxProperties.class 3、在ConfigurationProperties注解后面就是可以配置的属性名，字段名就是属性值 自动配置文件类只有满足条件才能生效，如何知道那些自动配置类生效，使用方法如下： 1debug: true 在yaml文件中配置应用以debug模式来启动，在控制台就会打印那些自动配置类已经生效了。其中Negative matches就是没有生效的配置类。Positive matches就是生效的自动配置。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-9-单元测试知识","slug":"JavaEE进阶知识学习----SpringBoot-9-单元测试知识","date":"2019-03-22T17:01:09.000Z","updated":"2019-03-22T13:37:08.083Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-9-单元测试知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-9-单元测试知识/","excerpt":"###单元测试 ####1.先测试Services中的方法","text":"###单元测试 ####1.先测试Services中的方法 /** * 根据id查询一个用户 * @param id * @return */ public User findOne(Integer id){ return userRepository.findOne(id); } ####2.在项目目录中的test/java/com.study.springbootdemo中新建测试类 import com.study.springbootdemo.domain.User; import com.study.springbootdemo.services.UserService; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class UserServicesTest { @Autowired private UserService userService; @Test public void findOneTest(){ User user = userService.findOne(1); //使用断言 Assert.assertEquals(new Integer(15),user.getAge()); } } 说明：断言是指我们的预期结果是否程序的执行结果是否一致，其中使用了@RunWith(SpringRunner.class)注解、@SpringBootTest注解。 ####3.运行UserServicesTest，测试结果 ####IDEA简单方法进行测试 #####第一步选中要测试的方法 #####第二步选择新建一个测试类 #####第三步选择要测试的方法 #####第四步结果如下 ####3.测试API(controller中的方法这里使用IDEA生成API测试类和方法，这里是要模仿发送请求的测试，如下所示： @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mvc; @Test public void userList() throws Exception { mvc.perform(MockMvcRequestBuilders.get(&quot;/users&quot;)) .andExpect(MockMvcResultMatchers.status().isOk()); } } 说明： 这里比Services测试多了一个注解@AutoConfigureMockMvc。 MockMvcRequestBuilders.get(“/users”)表示发送的是get请求，当然还有put等请求 andExpect表示使用断言 MockMvcResultMatchers.status()表示获取的是状态","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-8-异常处理知识","slug":"JavaEE进阶知识学习----SpringBoot-8-异常处理知识","date":"2019-03-22T17:01:08.000Z","updated":"2019-03-22T13:37:00.084Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-8-异常处理知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-8-异常处理知识/","excerpt":"###SpringBoot中对异常的统一处理异常处理也可以说成是一种数据传输方式，简单来讲，可以在Services中抛出异常信息，在controller中接收异常信息，然后就可以返回到页面显示了。","text":"###SpringBoot中对异常的统一处理异常处理也可以说成是一种数据传输方式，简单来讲，可以在Services中抛出异常信息，在controller中接收异常信息，然后就可以返回到页面显示了。 ####异常处理实例如果我们需要获取用户的年龄，并根据年龄进行判断，并作出不同的响应。 #####1.首先我们会定义返回结果数据的通用类，如下： public class Msg { //状态码100-成功，200-失败 private int code; //提示信息 private String msg; //具体提示消息 private String message; //用户要返回给浏览器的数据 private Map&lt;String, Object&gt; extend = new HashMap&lt;String, Object&gt;(); public static Msg success(String message){ Msg result = new Msg(); result.setCode(100); result.setMsg(&quot;处理成功&quot;); return result; } public static Msg fail(String message){ Msg result = new Msg(); result.setCode(200); result.setMsg(&quot;处理失败&quot;); result.setMessage(message); return result; } public Msg add(String key,Object value){ this.getExtend().put(key, value); return this; } public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMsg() { return msg; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public void setMsg(String msg) { this.msg = msg; } public Map&lt;String, Object&gt; getExtend() { return extend; } public void setExtend(Map&lt;String, Object&gt; extend) { this.extend = extend; } } #####2.修改Controller中的添加一个用户的方法 @PostMapping(value = &quot;/users&quot;) public Msg addUser(@Valid User user, BindingResult bindingResult){ if(bindingResult.hasErrors()){ return Msg.fail(bindingResult.getFieldError().getDefaultMessage()); } user.setUserName(user.getUserName()); user.setAge(user.getAge()); return Msg.success().add(&quot;user&quot;,userRepository.save(user)); } #####3.测试我们先测试失败的时候，我们开始做了一个年龄age的检验，不满足校验就会报错，如下： 我们再来测试成功的时候，如下： 可以看出我们写的通用的返回类，返回给客户端的数据格式是一致的。上面仅仅是测试一下我们写的通用返回类，下面我们将继续完成对用户年龄的判断。 #####4.Services中添加方法 public void getAge(Integer id){ User user = userRepository.findOne(id); Integer age = user.getAge(); if(age &lt; 20){ //返回你还在上大学吧 }else if(age &gt; 20 &amp;&amp; age &lt; 30){ //返回你刚工作不久吧 } } #####5.userController中根据年龄获取用户 @GetMapping(value = “users/getAge/{id}”) public void getAge(@PathVariable(“id”) Integer id){ userService.getAge(id); }但是，在controller中怎么获取Services中的返回的值，可能有的或说将Services的返回值改为String，如果我们要做其他操作，要返回一个对象或者其他呢，当然还有很多方式可以实现，但是随着业务的复杂，我们最好的使用统一异常的方式较为好些。 #####6.修改Services中的getAge方法 public void getAge(Integer id) throws Exception{ User user = userRepository.findOne(id); Integer age = user.getAge(); if(age &lt; 20){ //返回你还在上大学吧 throw new Exception(&quot;你还在上大学吧!!!&quot;); }else if(age &gt; 20 &amp;&amp; age &lt; 30){ //返回你刚工作不久吧 throw new Exception(&quot;你刚工作不久吧!!!&quot;); } } #####7.增加一个统一异常处理类 import com.study.springbootdemo.domain.Msg; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice public class ExceptionHandle { //使用注解说明要捕获哪一个异常类,Exception是我们抛出异常使用的类 @ExceptionHandler(value = Exception.class) @ResponseBody public Msg handle(Exception e){ return Msg.fail(e.getMessage()); } } #####8.测试首先先看我数据库中表的信息测试年龄小于20d的异常捕获和返回测试年龄大于20小于30的异常捕获和返回 #####9.自定义异常类使用Exception异常类只能抛出一个异常信息，throw new Exception(“你还在上大学吧!!!”);，如果我们要抛出其他的信息就要自定义异常类。 public class UserException extends RuntimeException{ private String mes; public UserException(String msg,String message){ super(message); this.mes = msg; } public String getMes() { return mes; } public void setMes(String mes) { this.mes = mes; } } #####10.修改Services类，抛出自定义异常类 public void getAge(Integer id) throws Exception{ User user = userRepository.findOne(id); Integer age = user.getAge(); if(age &lt; 20){ //返回你还在上大学吧 throw new UserException(&quot;年龄小于20的异常&quot;,&quot;你还在上大学吧!!!&quot;); }else if(age &gt; 20 &amp;&amp; age &lt; 30){ //返回你刚工作不久吧 throw new UserException(&quot;年龄大于20且小于30的异常&quot;,&quot;你刚工作不久吧!!!&quot;); } } #####11.异常捕获类 @ControllerAdvice public class ExceptionHandle { //使用注解说明要捕获哪一个异常类,Exception是我们抛出异常使用的类 @ExceptionHandler(value = Exception.class) @ResponseBody public Msg handle(Exception e){ if(e instanceof UserException){ UserException userException = (UserException) e; userException.getMes();//自定义异常的第一个信息 userException.getMessage();//自定义异常的第二个信息 return Msg.fail(userException.getMes()); } return Msg.fail(e.getMessage()); } } #####12优化Services如果有很多的异常信息在各个类中抛出，修改和维护就特别困难，所以我们使用枚举来统一管理，新建一个枚举 public enum ResultEnum { ERROR_ONE(&quot;101&quot;,&quot;你还在上大学吧!!!&quot;), ERRON_TWO(&quot;102&quot;,&quot;你刚工作不久吧!!!&quot;) ; private String mes; private String message; public String getMes() { return mes; } ResultEnum(String msg,String message){ this.mes = msg; this.message = message; } public String getMessage() { return message; } } 然后修改我们自定义异常类 public class UserException extends RuntimeException{ private String mes; public UserException(ResultEnum resultEnum){ super(resultEnum.getMessage()); this.mes = mes; } public String getMes() { return mes; } public void setMes(String mes) { this.mes = mes; } } 修改我们的Services public void getAge(Integer id) throws Exception{ User user = userRepository.findOne(id); Integer age = user.getAge(); if(age &lt; 20){ //返回你还在上大学吧 throw new UserException(ResultEnum.ERROR_ONE); }else if(age &gt; 20 &amp;&amp; age &lt; 30){ //返回你刚工作不久吧 throw new UserException(ResultEnum.ERRON_TWO); } }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-7-AOP处理请求知识","slug":"JavaEE进阶知识学习----SpringBoot-7-AOP处理请求知识","date":"2019-03-22T17:01:07.000Z","updated":"2019-03-22T13:37:50.585Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-7-AOP处理请求知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-7-AOP处理请求知识/","excerpt":"###AOP统一处理请求日志AOP是一种编程范式，与编程语言无关，是一种程序设计思想。AOP:面向切面编程，OOP：面向对象编程，POP:面向过程编程，还有函数式编程等等。","text":"###AOP统一处理请求日志AOP是一种编程范式，与编程语言无关，是一种程序设计思想。AOP:面向切面编程，OOP：面向对象编程，POP:面向过程编程，还有函数式编程等等。 ###AOP实例-记录每一个HTTP请求 ####1.添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; ####2.编写切面，切入点类 import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; @Aspect @Component public class HttpAspect { //使用log打印日志 private final static Logger logger = LoggerFactory.getLogger(HttpAspect.class); @Pointcut(&quot;execution(public * com.study.springbootdemo.controller.UserController.*(..))&quot;) public void log(){} @Before(&quot;log()&quot;) public void doBefore(JoinPoint joinPoint){ //记录Http请求 ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //记录URL logger.info(&quot;url={}&quot;,request.getRequestURL()); //记录请求方法 logger.info(&quot;method={}&quot;,request.getMethod()); //记录请求ip logger.info(&quot;ip={}&quot;,request.getRemoteAddr()); //记录请求类的类方法 logger.info(&quot;class_method={}&quot;,joinPoint.getSignature().getDeclaringTypeName()+&quot;.&quot;+joinPoint.getSignature().getName()); //记录参数 logger.info(&quot;args={}&quot;,joinPoint.getArgs()); } @After(&quot;log()&quot;) public void doAfter(){ logger.info(&quot;2222222222222222&quot;); } } 说明： @Pointcut(“execution(public com.study.springbootdemo.controller.UserController.(..))”)是一个切入点，表示UserController类中的所有方法。 @Aspect注解表示这是一个该类是一个切面类 @Component注解表示将该类交于Spring来管理， @Before(“log()”)注解表示UserController类中的方法被访问前执行的方法 @After(“log()”)注解表示UserController类中的方法被访问后要执行的方法 ####3.启动程序，使用postman进行测试 #####3.1测试查询用户列表 #####测试结果为： #####3.2测试添加一个用户 #####测试结果为：","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-6-表单验证知识","slug":"JavaEE进阶知识学习----SpringBoot-6-表单验证知识","date":"2019-03-22T17:01:06.000Z","updated":"2019-03-22T13:37:41.537Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-6-表单验证知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-6-表单验证知识/","excerpt":"下面是接着基础知识的代码整理后，如下所示：","text":"下面是接着基础知识的代码整理后，如下所示：在前面的学习中，我们写了一个插入用户的方法，如下： @PostMapping(value = &quot;/users&quot;) public User addUser(@RequestParam(&quot;userName&quot;)String userName,@RequestParam(&quot;age&quot;)Integer age){ User user = new User(); user.setUserName(userName); user.setAge(15); return userRepository.save(user); } 从上述代码中，我们可以看出随着用户的属性增多时，代码量就会变得很多，我们可以做如下的修改： @PostMapping(value = &quot;/users&quot;) public User addUser(User user){ user.setUserName(user.getUserName()); user.setAge(user.getAge()); return userRepository.save(user); } 当我们进行表单验证时，使用注解的方式在实体类中，例如年龄必须大于18岁，如下： @Min(value = 18,message = &quot;未成年人禁止注册&quot;) private Integer age; 控制类中的方法修改如下： @PostMapping(value = &quot;/users&quot;) public User addUser(@Valid User user, BindingResult bindingResult){ if(bindingResult.hasErrors()){ System.out.print(bindingResult.getFieldError().getDefaultMessage()); return null; } user.setUserName(user.getUserName()); user.setAge(user.getAge()); return userRepository.save(user); } 说明： 使用了@Min(value = 18,message = “未成年人禁止注册”)进行表单字段校验 使用@Valid注解表示校验user这个对象 校验结果存在在BindingResult bindingResult这个对象中 ####SpringBoot采用的是Hibernate-validator校验规则，常用的校验规则如下所示： @AssertTrue 用于Boolean字段，该字段只能为true @AssertFalse 用于Boolean字段，该字段只能为false @CreditCardNumber 对信用卡进行一个大致的验证 @DecimalMax(“5”) 只能小于或等于该值 @DecimalMin(“48”)只能大于和等于该值 @Digits(integer = 2,fraction = 20) 检查是否是一种数字的整数，分数，小数位数的数字 @Email 对邮箱进行校验 @Future 检查该字段的日期是否是一个将来的日期 @Length(min = 12,max = 45) 检查所属字段的长度是否在min和max之间，只能用于字符串 @Max(value = 15) 该字段的值只能小于或者等于该值 @Min(value = 1) 该字段的值只能大于或者等于该值 @NotNull 不能为null @NotBlank 不能为空，检查的时候会将空格忽略 @NotEmpty 不能为空，这里指的是空字符串 @Null 检查该字段是否为空 @Past 检查该字段的是日期在过去 @Size(min = 12,max = 51) 检查该字段的size是否在min和max之间，包括字符串，数组，集合，Map等 @URL(protocol = “1”,host = “”,port = 51) 检查是否是一个有效的URL @Valid 该注解只能用于字段为一个包含其他对象的集合或map或数组的字段。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-5-事务管理知识","slug":"JavaEE进阶知识学习----SpringBoot-5-事务管理知识","date":"2019-03-22T17:01:05.000Z","updated":"2019-03-22T13:37:46.536Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-5-事务管理知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-5-事务管理知识/","excerpt":"####事务管理事务就是多条操作同时成功或者失败。例如同时新增两个用户，同时插入成功才插入到数据库表中，否则不插入。","text":"####事务管理事务就是多条操作同时成功或者失败。例如同时新增两个用户，同时插入成功才插入到数据库表中，否则不插入。 ####1.新增了一个Services类，如下所示： @Service public class UserService { @Autowired private UserRepository userRepository; @Transactional public void insertUserTwo(){ User userA = new User(); userA.setUserName(&quot;B&quot;); userA.setAge(52); userRepository.save(userA); User userB = new User(); userB.setUserName(&quot;陈七&quot;); userB.setAge(25); userRepository.save(userB); } } 说明:为了让测试方便，也就是模拟第二次插入会失败，我们将数据库表中的user_name字段的大小设置为1个字节，那么第一次插入就会成功，第二次插入就会报错， ####2.控制类中的方法如下所示： @PostMapping(value = &quot;/users/two&quot;) public void addTwoUser(){ userService.insertUserTwo(); } 这个时候即使第一条数据可以插入成功，也不会被插入进数据库表中，这就是 @Transactional的事务管理。 ####总结SpringBoot的基础知识包括了如下部分 开发环境的安转和配置 简单的介绍了SpringBoot的配置文件中的 Controller的使用 数据库的基本使用的事务管理","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot高级（一）JSR107缓存","slug":"JavaEE进阶知识学习----SpringBoot高级（一）JSR107缓存","date":"2019-03-22T17:01:04.000Z","updated":"2019-03-22T13:36:37.352Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot高级（一）JSR107缓存/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot高级（一）JSR107缓存/","excerpt":"SpringBoot与缓存JSR107","text":"SpringBoot与缓存JSR107 Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry和Expiry。 CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 Entry是一个存储在Cache中的key-value对。 Expiry每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 使用JSR107需要导入如下包 1234&lt;dependency&gt; &lt;groupId&gt;javax.cache&lt;/groupId&gt; &lt;artifactId&gt;cache-api&lt;/artifactId&gt;&lt;/dependency&gt; Spring缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 重要概念和缓存注解 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 简要说明： @Cacheable注解加载方法中，那么该方法第一次会查询数据库，然后就会吧数据放在缓存中，使用Cache 进行数据的读取等操作。 @CacheEvict删除缓存，例如根据id删除用户，那么也要删除缓存中的用户信息 @CachePut更新缓存，例如更新用户信息后，同时也要更新缓存中的用户信息","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-4-数据库知识","slug":"JavaEE进阶知识学习----SpringBoot-4-数据库知识","date":"2019-03-22T17:01:04.000Z","updated":"2019-03-22T13:37:36.761Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-4-数据库知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-4-数据库知识/","excerpt":"下面学习的是数据库相关知识数据库使用的是MySQL，持久化技术使用的就是spring-data-jpa,RESTFul API如下","text":"下面学习的是数据库相关知识数据库使用的是MySQL，持久化技术使用的就是spring-data-jpa,RESTFul API如下 1.pom文件中添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 2.application.yml文件中配置数据库信息和jpaspring: profiles: active: prod datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbspringboot username: root password: 123456 jpa: hibernate: ddl-auto: create show-sql: true 其中的 ddl-auto: create表示每次都会删除原先存在的表，就是说如果表中存在数据，运行程序数据就不存在了。也可以是 update：会创建表，如果表中有数据，不会删除表。 ####3.创建一个实体类User，如下所示 @Entity public class User { @Id @GeneratedValue private Integer id; private String userName; private Integer age; public User(){ } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 当我们再次启动程序的时候时候，dbspringboot数据库中就会多一个user表，其中表字段就是实体类所对应的字段，这是jpa相关的知识，具体将在以后仔细学习和记录。 ####4.创建UserController @RestController public class UserController { @Autowired private UserRepository userRepository; @GetMapping(value = &quot;/users&quot;) public List&lt;User&gt; userList(){ return userRepository.findAll(); } } ####5.UserRepository接口的代码如下 public interface UserRepository extends JpaRepository&lt;User,Integer&gt; { } ####6.访问使用http://localhost:8082/gire/users访问，如下： ####7.restful风格的完整代码如下： @RestController public class UserController { @Autowired private UserRepository userRepository; /** * 查询用户列表 * @return */ @GetMapping(value = &quot;/users&quot;) public List&lt;User&gt; userList(){ return userRepository.findAll(); } /** * 添加一个用户 * @param userName * @param age * @return */ @PostMapping(value = &quot;/users&quot;) public User addUser(@RequestParam(&quot;userName&quot;)String userName,@RequestParam(&quot;age&quot;)Integer age){ User user = new User(); user.setUserName(userName); user.setAge(15); return userRepository.save(user); } /** * 根据id查询用户 * @return */ @GetMapping(value = &quot;/users/{id}&quot;) public User getUserById(@PathVariable(&quot;id&quot;) Integer id){ return userRepository.findOne(id); } /** * 根基id修改用户 * @param id * @param userName * @param age * @return */ @PutMapping(value = &quot;/users/{id}&quot;) public User updateUserById(@PathVariable(&quot;id&quot;) Integer id,@RequestParam(&quot;userName&quot;)String userName,@RequestParam(&quot;age&quot;)Integer age){ User user = new User(); user.setId(id); user.setAge(age); user.setUserName(userName); return userRepository.save(user); } /** * 根据id删除用户 * @param id */ @DeleteMapping(value = &quot;/users{id}&quot;) public void deleteUserById(@PathVariable(&quot;id&quot;) Integer id){ userRepository.delete(id); } @GetMapping(value = &quot;users/age/{age}&quot;) public List&lt;User&gt; listUserByAge(@PathVariable(&quot;age&quot;) Integer age){ return userRepository.findByAge(age); } } 上述代码中我们也扩展了使用年龄来查询用户，在UserRepository接口中我们扩展了这个方法如下所示： //通过年龄查询，方法名有规定 public List&lt;User&gt; findByAge(Integer age);","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-3-控制类知识","slug":"JavaEE进阶知识学习----SpringBoot-3-控制类知识","date":"2019-03-22T17:01:03.000Z","updated":"2019-03-22T13:37:32.376Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-3-控制类知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-3-控制类知识/","excerpt":"####下面将简单介绍一下controller类的相关用法在上一篇博客中，我们也使用的Controller相关的注解，下面我们来简单的总结一下： @RestController处理Http请求，返回JSON格式的数据。 @RequestMapping(value = “/hello”,method = RequestMethod.GET)配置URL映射","text":"####下面将简单介绍一下controller类的相关用法在上一篇博客中，我们也使用的Controller相关的注解，下面我们来简单的总结一下： @RestController处理Http请求，返回JSON格式的数据。 @RequestMapping(value = “/hello”,method = RequestMethod.GET)配置URL映射 如果使用多个URL访问同一个的方法，可以将URL映射配置为一个集合，如下所示： @RestController public class HelloSpringBoot { @Autowired private UserProperties userProperties; @RequestMapping(value = {&quot;/hello&quot;,&quot;/hi&quot;},method = RequestMethod.GET) public String hello(){ return userProperties.getCupSize(); } }RequestMapping类注解如下： @RestController @RequestMapping(“demo”) public class HelloSpringBoot { @Autowired private UserProperties userProperties; @RequestMapping(value = {&quot;/hello&quot;,&quot;/hi&quot;},method = RequestMethod.GET) public String hello(){ return userProperties.getCupSize(); } }访问链接为http://localhost:8082/gire/demo/hello###如何获取参数 @PathVariable获取URL中的数据 @RequestParam获取请求参数的值 @GetMapping组合注解 ####@PathVariable注解使用 @RestController @RequestMapping(&quot;demo&quot;) public class HelloSpringBoot { @Autowired private UserProperties userProperties; @RequestMapping( value = &quot;/hello/{id}&quot;,method = RequestMethod.GET) public String hello(@PathVariable(&quot;id&quot;) Integer id){ return &quot;id:&quot;+id; } } 访问链接如下：http://localhost:8082/gire/demo/hello/5， ####@RequestParam注解使用如果使用传统的传参数http://localhost:8082/gire/demo/hello?id=5那么获取方式如下所示： @RestController @RequestMapping(&quot;demo&quot;) public class HelloSpringBoot { @Autowired private UserProperties userProperties; @RequestMapping( value = &quot;/hello&quot;,method = RequestMethod.GET) public String hello(@RequestParam(&quot;id&quot;) Integer id){ return &quot;id:&quot;+id; } } 也可以使用默认参数值，和要求是否必传，如下所示： @RestController @RequestMapping(&quot;demo&quot;) public class HelloSpringBoot { @Autowired private UserProperties userProperties; @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET) public String hello(@RequestParam(value = &quot;id&quot;,required = false,defaultValue = &quot;0&quot;) Integer id){ return &quot;id:&quot;+id; } } 其中required要求是否必传，defaultValue是默认值，如果不传id则显示默认值。 ####组合注解@RequestMapping(value = “/hello”,method = RequestMethod.GET)这个注解可以使用 @GetMapping(value = “/hello”)这个组合注解来替代，当然 @PutMapping、 @DeleteMapping等形式。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-2-配置文件知识","slug":"JavaEE进阶知识学习----SpringBoot-2-配置文件知识","date":"2019-03-22T17:01:02.000Z","updated":"2019-03-22T13:37:27.696Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-2-配置文件知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-2-配置文件知识/","excerpt":"####属性配置说明在SpringBoot项目中，属性配置在resource目录下的application.properties中配置，接着我们第一次创建的那个项目说明，如下，做了一些简单的配置后，","text":"####属性配置说明在SpringBoot项目中，属性配置在resource目录下的application.properties中配置，接着我们第一次创建的那个项目说明，如下，做了一些简单的配置后，再启动项目后使用http://localhost:8080/hello就不能访问项目了，使用http://localhost:8081/gire/hello访问才能正常访问项目，在SpringBoot项目中默认使用application.properties文件来配置项目的一些信息，当然我们也可使用yml文件来配置，具体如下所示：注意：yml语法是相同的就不同重复书写，同时port: 8082之间必须存在空格。当然yml和properties只能存放一个。 ####yml文件配置的属性值如何在程序中得到，下面来看一个小例子。 #####第一步：配置文件中配置一些基本的属性和属性值，如下所示： #####第二步：在controller中获取配置文件中属性值的方法如下所示： #####写到这里都会想到如果有很多属性值，那岂不是要写很多的代码，我们可以做如下的改变， #####首先是配置文件中加上前缀： #####然后新建一个配置属性类，如下所示： #####注意的是前缀和配置文件中的前缀保持一致，只用方法如下所示： ####不同配置环境之间的切换使用问题 #####开发环境使用的配置文件和生产环境使用的配置文件，开发环境的配置文件如下所示： #####生产环境的配置文件如下所示： #####环境的切换配置文件如下所示： ####小结使用到的注解如下： @Component组件标识，表示当前类可以被注入。 @ConfigurationProperties(prefix = “user”)配置文件标识 @Value(“${age}”)获取配置文件中的属性值","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习----SpringBoot-1-项目初始化知识","slug":"JavaEE进阶知识学习----SpringBoot-1-项目初始化知识","date":"2019-03-22T17:01:01.000Z","updated":"2019-03-22T13:37:13.309Z","comments":true,"path":"2019/03/23/JavaEE进阶知识学习----SpringBoot-1-项目初始化知识/","link":"","permalink":"https://caochenhins.github.io/2019/03/23/JavaEE进阶知识学习----SpringBoot-1-项目初始化知识/","excerpt":"####前提准备 安装和配置Java1.8相关环境。 安装和配置Maven，并修改为国内镜像 官网下载IDEA旗舰版，并安装。 IDEA配置Maven，配置JDK. 修改IDEA常用的设置，例如字体，提示等等","text":"####前提准备 安装和配置Java1.8相关环境。 安装和配置Maven，并修改为国内镜像 官网下载IDEA旗舰版，并安装。 IDEA配置Maven，配置JDK. 修改IDEA常用的设置，例如字体，提示等等 ####第一个SpringBoot项目#####第一步：打开IDEA，选择创建新项目，如下所示： #####第二步：点击Next，选择对应的Java版本和项目名，包名，注意项目名只能为小写，如下所示： #####第三步：我们只选web即可，如下所示： 第一个SpringBoot项目就创建成功了，项目目录结构如下： #####第四步：创建一个HelloSpringBoot的Controller类，如下所示： 这个类的作用就时返回一个字符串， #####第五步：在程序的主入口处启动该程序，SpringbootdemoApplication启动，浏览器访问如下所示： #####至此：第一个项目就完成了，无情的战争财刚刚开始，","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"Git命令笔记","slug":"Git命令笔记","date":"2019-03-22T15:17:45.000Z","updated":"2019-03-22T16:41:53.513Z","comments":true,"path":"2019/03/22/Git命令笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/Git命令笔记/","excerpt":"","text":"创建Git版本库\"# GitHexo\" >> README.md12345git initgit add .git commit -m &quot;first commit&quot;git remote add origin https://github.com/caochenhins/HexoBack.gitgit push -u origin master git - 查看远程仓库信息12345678$ git remote show origin* remote origin URL: git://github.com/schacon/ticgit.git Remote branch merged with &apos;git pull&apos; while on branch master master Tracked remote branches master ticgit 删除git仓库12345678910111.在本地仓库的目录下调用命令行删除根目录下的.git文件夹，输入find . -name &quot;.git&quot; | xargs rm -Rf这样本地仓库就清除了，像下面这样，master不见了。2.手动删除掉残留的.git文件3.在命令行中输入rm -rf + github仓库地址，例rm -rf https://github.com/NeroSolomon/VLearning.git4.在github的对应的库中到setting删除库。 删除项目里面所有.svn和.git 文件123456789项目代码上传至svn/git后会产生.svn/.git文件，项目打包时需要将这些文件删除。打开终端，cd到项目文件夹//删除文件夹下的所有 .svn 文件 find . -name &quot;.svn&quot;| xargs rm -Rf //删除文件夹下的所有 .git 文件 find . -name &quot;.git&quot;| xargs rm -Rf git pull用法：pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并。12345678910111213141516171819202122232425262728一句话总结git pull和git fetch的区别：git pull = git fetch + git mergegit fetch不会进行合并执行后需要手动执行git merge合并分支，而git pull拉取远程分之后直接与本地分支进行合并。更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。基本用法：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;1例如执行下面语句：git pull origin master:brantest1将远程主机origin的master分支拉取过来，与本地的brantest分支合并。后面的冒号可以省略：git pull origin master1表示将远程origin主机的master分支拉取过来和本地的当前分支进行合并。上面的pull操作用fetch表示为：git fetch origin master:brantestgit merge brantest12相比起来git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。 把两个不同的项目合并123456789我在Github新建一个仓库，写了License，然后把本地一个写了很久仓库上传。先pull，因为两个仓库不同，发现refusing to merge unrelated histories，无法pull因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码，在git pull，这句代码是在git 2.9.2版本发生的，最新的版本需要添加--allow-unrelated-historiesgit pull origin master --allow-unrelated-histories Git冲突文件问题1234567891011121314Pull is not possible because you have unmerged files.本地的push和merge会形成MERGE-HEAD(FETCH-HEAD), HEAD（PUSH-HEAD）这样的引用。HEAD代表本地最近成功push后形成的引用。MERGE-HEAD表示成功pull后形成的引用。可以通过MERGE-HEAD或者HEAD来实现类型与svn revet的效果。解决：1.将本地的冲突文件冲掉，不仅需要reset到MERGE-HEAD或者HEAD,还需要--hard。没有后面的hard，不会冲掉本地工作区。只会冲掉stage区。git reset --hard FETCH_HEAD2.git pull就会成功。对于博主的git reset --hard, 大家不要轻易用, 尤其小白, 这会把你的代码最新修改全部抹掉, 出现这种Pull is not possible because you have unmerged files的最好的解决办法：git add -u 你的修改目录git add -u [path]表示 add to index only files modified or deleted and not those created.git add -u [path]: 把[path]中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。省略[path]表示.,即当前目录。 git commit 报 “Changes not staged for commitgit commit -am “提交” Git push -u orign master 提示hint: not have locally. This is usually caused by another repository push一、情景1.在GitHub上创建一个仓库A，并且初始化了readme.md这个文档.2.在本地用Git Bash初始化仓库A(一开始没有从GitHub上拉下来).git init / 初始化一个空的仓库/3.在本地仓库新建一个文件 test.txt,并且提交到本地仓库. git add test.txt / 把test.txt设为仓库跟踪文件 /git commit -m “测试第一次 test.txt” / 提交文件并且追加备注 / 4.把本地仓库提交到远程仓库master 分支 git push git@github.com：用户名/仓库名 master提交失败：not have locally. This is usually caused by another repository push 二、原因本地仓库跟远程仓库的版本不一样导致的,因为执行在步骤1的时候，远程的版本库会有个“commit readme.md”这个操作记录,本地仓库是不知道你有这个提交的，也就是说这个记录没在本地仓库是不存在的，所以俩个版本是不一致的.三 、解决方法A). 先更新本地版本在提交 利用 git pull 更新本地版本库.再 利用git push命令把本地仓库推送至远程仓库.B). 强制覆盖 加上 -f 参数 强制覆盖git push -f git如何移除某文件夹的版本控制1234567891011121314151617181920212223242526272829303132333435目录结构如下project bin lib src ...... 执行如下的操作git add .git commit -m &quot;add bin/ lib/ src/&quot;git push origin master 突然发现原来 lib 目录不需要提交到版本库,但是现在远程已经存在该目录,what should I do.（吐出去的东西还能收回来吗）万能的Git啊,help me！功夫不负有心人,找到了解决问题的方法,其实就是 git rm 的命令行参数。git rm 命令参数-n --dry-run Don’t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.-r Allow recursive removal when a leading directory name is given. --cached Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.解决方法git rm -r -n --cached &quot;bin/&quot; //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。git rm -r --cached &quot;bin/&quot; //最终执行命令. git commit -m&quot; remove bin folder all file out of control&quot; //提交git push origin master //提交到远程服务器此时 git status 看到 bin/目录状态变为 untracked可以修改 .gitignore 文件 添加 bin/ 并提交 .gitignore 文件到远程服务器,这样就可以不对bin目录进行版本管理了。以后需要的时候,只需要注释 .gitignore 里 #bin/ 内容,重新执行 git bin/ ,即可重新纳入版本管理。","categories":[{"name":"Git","slug":"Git","permalink":"https://caochenhins.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://caochenhins.github.io/tags/Git/"}]},{"title":"JavaEE基础知识学习----MyBatis（一）简介","slug":"JavaEE基础知识学习----MyBatis（一）简介","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:43:00.267Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（一）简介/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（一）简介/","excerpt":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录.","text":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. Mybatis与其他持久化方式对比 MyBatis是一个半自动化的持久化框架 JDBC是SQL夹在Java代码中，耦合度高导致硬编码，维护不易且实际开发中SQL会经常变化 Hibernate和JPA是内部自动产生的SQL语句，不容易做特殊优化，长而复杂的SQL，hibernate处理也不容易，是基于全映射的全自动化框架，大量子弹的pojo进行部分映射比较困难，导致数据库性能下降 对于开发人员，核心SQL需要自己优化，所以需要SQL和java编码分开，功能界面明显，一个专注业务，一个专注数据 文档资料下载地址：https://github.com/mybatis/mybatis-3 中文文档：http://www.mybatis.org/mybatis-3/zh/index.html MyBatis的HelloWord概述随着Maven的流行，现在几乎很少有使用jar的方式来搭建开发环境，这里也就不在单个使用Mybatis去操作数据库，不会的可以自行百度，MyBatis只是一个持久化框架，只有和其他框架整合才能更好的使用，例如SpringMVC，SpringBoot等，与Spring整合后，Mybatis的一些配置文件都会交于Spring管理。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"JavaEE基础知识学习----MyBatis（七）插件开发","slug":"JavaEE基础知识学习----MyBatis（七）插件开发","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:42:44.010Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（七）插件开发/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（七）插件开发/","excerpt":"Mybatis的插件开发PageHelper分页插件项目地址：https://github.com/pagehelper/Mybatis-PageHelper 文档地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md 使用步骤12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt;","text":"Mybatis的插件开发PageHelper分页插件项目地址：https://github.com/pagehelper/Mybatis-PageHelper 文档地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md 使用步骤12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 在 MyBatis 配置 xml 中配置拦截器插件 1234567&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=\"param1\" value=\"value1\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 代码中使用方法12345678910111213141516171819202122232425262728293031323334353637//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 常用方法介绍RowBounds方式的调用 1List&lt;Country&gt; list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页 PageHelper.startPage静态方法调用 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 PageInfo用法 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); Mybatis批量保存在MyBatis的全局设置中有设置，defaultExecutorType 配置默认的执行器 SIMPLE 就是普通的执行器； REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新 但是，如果在全局设置中设置批量执行器，那么每一个mapper中的方法都会执行批量操作，所以我们一般都是在与Spring整合后在Application.xml中配置一个可以执行批量操作的sqlSession,如下 123456789101112&lt;!--创建出SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- configLocation指定全局配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!--mapperLocations: 指定mapper文件的位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"executorType\" value=\"BATCH\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 在Service中自动注入SQLSession 123456@Autowiredprivate SqlSession sqlSession;public List&lt;Employee&gt; getEmps()&#123; EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); return mapper.getEmps();&#125;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"JavaEE基础知识学习----MyBatis（三）映射文件","slug":"JavaEE基础知识学习----MyBatis（三）映射文件","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:42:48.540Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（三）映射文件/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（三）映射文件/","excerpt":"MyBatis映射文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在 。SQL 映射文件有很少的几个顶级元素 ，如下 cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句","text":"MyBatis映射文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在 。SQL 映射文件有很少的几个顶级元素 ，如下 cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 Select查询 查询语句是 MyBatis 中最常用的元素之一 ，简单查询的 select 元素是非常简单的。比如 123&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 该查询接受一个 int（或 Integer）类型的参数，返回一个 HashMap 类型的对象，键是列名，值是结果行中的对应值。 select 元素有很多属性允许你配置，来决定每条语句的作用细节 ，如下 123456789101112&lt;select id=\"selectPerson\" parameterType=\"int\" parameterMap=\"deprecated\" resultType=\"hashmap\" resultMap=\"personResultMap\" flushCache=\"false\" useCache=\"true\" timeout=\"10000\" fetchSize=\"256\" statementType=\"PREPARED\" resultSetType=\"FORWARD_ONLY\"&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 insert update delete数据变更语句 insert，update 和 delete 的实现非常接近 ,如下 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" keyColumn=\"\" useGeneratedKeys=\"\" timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 属性说明 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 示例 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 多行插入 1234567&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username, password, email, bio) values &lt;foreach item=\"item\" collection=\"list\" separator=\",\"&gt; (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;) &lt;/foreach&gt;&lt;/insert&gt; 自动生成主键 12345&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 映射文件小结 Mybatis允许增删改直接定义的返回值：Integer，Long，Boolean,返回的是改变数据库表的记录数和true和false 支持自动生成主键的字段，设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。 数据库还支持多行插入, 你也可以传入一个数组或集合，并返回自动生成的主键 映射文件参数处理 单个参数：MyBatis不会做特殊处理，#{参数名/任意名}：取出参数值 多个参数：MyBatis会做特殊处理，多个参数被封装为一个map,key：param1…param10或者参数的索引 命名参数，多个参数使用#{param1}来取值导致错乱，故使用命名参数，明确指定封装map的key,如下 1public Person getPerson(@Param(\"id\") Integer id,@Param(\"name\") String laseName); 这个时候在xml文件中可以使用#{id}和#{name}来取值 如果传入多个参数正好是POJO：可以使用#{属性名}直接获取。 如果传入多个参数不是POJO,为了方便，我们可以传入map,如下 1public Person getPerson(Map&lt;String,Object&gt; map); 这个时候也就可以在xml文件中使用#{key}直接取出传入map的key对应的值 如果传入多个参数不是POJO,但是查询频率高，使用map不方便，可以编写一个TO(数据传输对象) 如果传入了一个Collection（list，set）类型或者数组，也会特殊处理，也是吧list或者数组封装到map中，传入的类型不一样，对应的key如下：Collection（collection）,List（list），数组（array）,示例如下 1public Person get(List&lt;Integer&gt; ids); 传入的是一个list集合，在xml文件中，我们如果需要取出list中的第一个元素为：#{list[0]} #和$取值区别 取值的方式#{}是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}:取出的值直接拼装在sql语句中；会有安全问题；大多情况下，我们去参数的值都应该去使用#{}； 原生jdbc不支持占位符的地方我们就可以使用${}进行取值比如分表、排序。；按照年份分表拆分 12select * from $&#123;year&#125;_salary where xxx;select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125; select查询返回类型 返回一个集合：resultType写集合中元素的类型 返回一条记录的map，key为列名，value为列对应的值，例如 1public Map&lt;String ,Object&gt; getPersonByMap(Integer id); 123&lt;select id = \"getPersonByMap\" resultType=\"map\"&gt; select * from person where id = #&#123;id&#125;&lt;/select&gt; 返回多条记录封装的一个map，Map&lt;Integer,Person&gt;:key是这条记录的主键，值是记录封装后的pojo,如下 12@MapKey(\"id\")public Map&lt;Integer,Person&gt; getPersonByName(String name); 123&lt;select id = \"getPersonByName\" resultType=\"com.test.Person\"&gt; select * from person where last_name like #&#123;name&#125;&lt;/select&gt; @MapKey(“id”)注解表示使用那个属性作为返回结果map的key。 resultMap自定义结果集示例 1234567&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt;&lt;/restMap&gt;&lt;select id=\"getPerson\" restMap=\"baseMap\"&gt; select * from person&lt;/select&gt; resultMap关联属性_级联属性封装结果集 例如：员工有部门属性，联合查询返回封装结果 123456&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;result column=\"dept_id\" property=\"dept.id\" &gt;&lt;/result&gt; &lt;result column=\"dept_name\" property=\"dept.name\" &gt;&lt;/result&gt;&lt;/restMap&gt; 使用association指定联合的java对象 12345678&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;/association&gt;&lt;/restMap&gt; 使用collection定义关联集合的封装规则 例如，查询部门的时候，查询出当前部门下的所有员工 12345678&lt;restMap id=\"baseMap\" type=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;collection property=\"persons\" javaType=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;/collection&gt;&lt;/restMap&gt; sql标签这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如： 1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如： 1234567&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;, &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"JavaEE基础知识学习----MyBatis（五）缓存机制","slug":"JavaEE基础知识学习----MyBatis（五）缓存机制","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:42:56.014Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（五）缓存机制/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（五）缓存机制/","excerpt":"MyBatis的缓存机制概述MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。MyBatis系统中默认定义了两级缓存，一级缓存和二级缓存。 默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存","text":"MyBatis的缓存机制概述MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。MyBatis系统中默认定义了两级缓存，一级缓存和二级缓存。 默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存（本地缓存） 与数据库同一次会话期间查询的数据会放在本地缓存中，以后如果需要获取相同数据，直接从缓存中拿，不再查询数据库 一级缓存失效的四种情况 一级缓存是sqlSession级别的缓存，也就说一个sqlSession拥有自己的一级缓存，一级缓存是一直开启的，没有使用一级缓存的情况 不同的sqlSession对应不同的一级缓存 同一个sqlSession,但是查询条件不一样 同一个sqlSession两次查询期间执行了任何一次增删改操作 同一个sqlSession两次查询期间手动清空了缓存 二级缓存（全局缓存） 二级缓存基于namespace默认不开启，需要手动配置 MyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口 二级缓存在SqlSession 关闭或提交之后才会生效 工作机制 一个会话，查询一条数据，这个数据就会放在当前会话的一级缓存中 如果会话关闭，一级缓存中的数据就会保存到二级缓存中，新的查询信息，就参照二级缓存 使用步骤 全局配置文件中开启二级缓存 1&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 需要使用二级缓存的映射文件mapper.xml处使用cache配置缓存 1&lt;cach&gt;&lt;/cach&gt; 注意：POJO需要实现Serializable接口 Mybatis提供了整合ehcache缓存，具体整合方法参考官网文档，","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"JavaEE基础知识学习----MyBatis（六）MBG逆向工程","slug":"JavaEE基础知识学习----MyBatis（六）MBG逆向工程","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:42:39.793Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（六）MBG逆向工程/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（六）MBG逆向工程/","excerpt":"MyBatis的逆向工程概述MyBatis Generator：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写 官方文档地址：http://www.mybatis.org/generator/ 官方工程地址：https://github.com/mybatis/generator/releases","text":"MyBatis的逆向工程概述MyBatis Generator：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写 官方文档地址：http://www.mybatis.org/generator/ 官方工程地址：https://github.com/mybatis/generator/releases MBG使用步骤 编写MBG的配置文件（重要几处配置） jdbcConnection配置数据库连接信息 javaModelGenerator配置javaBean的生成策略 sqlMapGenerator配置sql映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置要逆向解析的数据表 tableName：表名 domainObjectName：对应的javaBean名 运行代码生成器生成代码 注意： Context标签targetRuntime=“MyBatis3“可以生成带条件的增删改查targetRuntime=“MyBatis3Simple“可以生成基本的增删改查如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。 MBG配置文件12345678910111213141516171819202122232425&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; //数据库连接信息配置 &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/bookstore0629\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; //javaBean的生成策略 &lt;javaModelGenerator targetPackage=\"com.atguigu.bean\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; //映射文件的生成策略 &lt;sqlMapGenerator targetPackage=\"mybatis.mapper\" targetProject=\".\\conf\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; //dao接口java文件的生成策略 &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.atguigu.dao\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; //数据表与javaBean的映射 &lt;table tableName=\"books\" domainObjectName=\"Book\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 生成器代码1234567891011public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new efaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; QBC风格的带条件查询123456789101112131415@Testpublic void test01()&#123; SqlSession openSession = build.openSession(); DeptMapper mapper = openSession.getMapper(DeptMapper.class); DeptExample example = new DeptExample(); //所有的条件都在example中封装 Criteria criteria = example.createCriteria(); //select id, deptName, locAdd from tbl_dept WHERE //( deptName like ? and id &gt; ? ) criteria.andDeptnameLike(\"%部%\"); criteria.andIdGreaterThan(2); List&lt;Dept&gt; list = mapper.selectByExample(example); for(Dept dept : list) &#123; System.out.println(dept);&#125;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"JavaEE基础知识学习----MyBatis（四）动态SQL","slug":"JavaEE基础知识学习----MyBatis（四）动态SQL","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:42:52.289Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（四）动态SQL/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（四）动态SQL/","excerpt":"MyBatis的动态SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 如下","text":"MyBatis的动态SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 如下 if choose (when, otherwise) trim (where, set) foreach if的使用动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如 注意：在xml文件中特殊符号，像&lt;，&gt;要使用转义字符 12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; choose，when，otherwise有时我们不想应用到所有的条件语句，而只想从中择其一项 ，如下 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim, where, set在前面，如果所有的条件都是动态sql,那么可能会出现一下情况的SQL语句 12SELECT * FROM BLOG WHERESELECT * FROM BLOG WHERE AND title like ‘someTitle’ 出现以上错误的sql语句，MyBatis提供了一种解决方式 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除 。注意：WHERE只会去掉开头第一个AND或OR 使用where会出错的情况，And放在后面 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; AND &lt;/if&gt; &lt;if test=\"title != null\"&gt; title like #&#123;title&#125; AND &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 另外一种解决办法就是使用标签，使用where，也可能造成最后一个and，使用trim方法如下 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ... &lt;/trim&gt; prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容（移除前面多余的AND 或者OR），并且插入 prefix 属性中指定的内容。 使用suffixOverrides会移除后面多余的AND或者OR。 set标签与if结合实现动态更新 12345678910&lt;update id=\"updateAuthorIfNecessary\"&gt; update Author &lt;set&gt; &lt;if test=\"username != null\"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=\"password != null\"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"bio != null\"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号,也可以使用trim，注意这里我们删去的是后缀值，同时添加了前缀值。 123&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; ...&lt;/trim&gt; foreach动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： 123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 说明: collection：指定要遍历的集合 item：将当前遍历的每一个元素赋给指定的变量 separator：每一个元素之间的分隔符 open：遍历出所有的结果拼接一个开始的字符 close：遍历出所有的结果拼接一个结束的字符 index：遍历list的就是索引，遍历map的时候就是map的key,item是map的值 Mysql下的批量插入1public void addEmp(@Param(\"emps\") List&lt;Employee&gt; emps); 1234567&lt;insert id=\"addEmp\"&gt; INSERT into employee(name,age)values &lt;foreach item=\"emp\" index=\"index\" collection=\"emps\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;emp.name&#125;, #&#123;emp.age&#125; &lt;/foreach&gt;&lt;/insert&gt; bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如 12345&lt;select id=\"selectBlogsLike\" resultType=\"Blog\"&gt; &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 如果是模糊查询，使用下面的方式是行不通的，如下 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%#&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之一，可以使用$符号(不安全) 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%$&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之二，使用bind标签 1234567&lt;select&gt; &lt;bind name=\"_lastName\" value=\"'%'+lastName+'%'\"&gt;&lt;/bind&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like #&#123;_lastName&#125; &lt;/if&gt;&lt;/select&gt; 1&lt;bind name=\"_lastName\" value=\"'_'+lastName+'%'\"&gt;&lt;/bind&gt;&lt;!--表示以什么开始，后面是参数的模糊查询--&gt;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"JavaEE基础知识学习----MyBatis（二）全局配置文件","slug":"JavaEE基础知识学习----MyBatis（二）全局配置文件","date":"2019-03-22T11:44:53.000Z","updated":"2019-03-22T12:42:35.564Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----MyBatis（二）全局配置文件/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----MyBatis（二）全局配置文件/","excerpt":"MyBatis的全局配置文件概述MyBatis的全局配置文件可以配置的属性如下 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器","text":"MyBatis的全局配置文件概述MyBatis的全局配置文件可以配置的属性如下 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 properties属性 MyBatis使用properties来引入外部properties配置文件的内容，resource：引入类路径下的资源，url引入网络路径或者磁盘路径下的资源。可以用于将数据源连接信息放在properties文件中，与Spring整合后就写在Spring的配置文件中。 引入外部properties文件 1&lt;properties resource=\"org/mybatis/example/config.properties\"&gt;&lt;/properties&gt; 使用引入的properties文件 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; settings运行时设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。 设置参数 描述 有效值 默认值 cacheEnabled 全局开启或关闭配置文件中的所有映射器任何缓存 true \\ false true lazyLoadingEnabled 延迟加载的全局开关 true \\ false false aggressiveLazyLoading 开启，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 true \\ false false multipleResultSetsEnabled 是否允许单一语句返回多结果集 true \\ false true useColumnLabel 使用列标签代替列名。 true \\ false true useGeneratedKeys 允许 JDBC 支持自动生成主键 如果设置为 true 则这个设置强制使用自动生成主键 true \\ false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出提醒 NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 任意正整数 defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 任意正整数 safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。 true \\ false False safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。 true \\ false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true \\ false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION \\ STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始) callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 true \\ false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始） true \\ false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象用到的代理工具。 CGLIB \\ JAVASSIST 常用的Setting设置 设置参数 描述 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名规则映射A_COLUNM到aColumn false defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 Settings设置示例1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases别名类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余,但是往往我们不会使用别名，是为了方便查看代码。 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，给包和子包下的所有类起一个默认的别名（类名小写） 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。 12@Alias(\"author\")public class Author &#123;&#125; typeHandlers 类型处理器无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 类型处理器 Java类型 JDBC类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SHORT INTEGER IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 LONG INTEGER FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）。 InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR or LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE plugins插件MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments环境配置MyBatis可以配置多种环境，default代表指定使用某种环境，这样就可以快速切换环境，尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一 ，所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例 。每个数据库对应一个 SqlSessionFactory 实例 环境配置实例 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 环境配置说明 默认的环境 ID（比如:default=”development”）。 每个 environment 元素定义的环境 ID（比如:id=”development”）。 事务管理器的配置（比如:type=”JDBC”）。 数据源的配置（比如:type=”POOLED”）。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://caochenhins.github.io/tags/MyBatis/"}]},{"title":"大数据基础知识学习-----Hive学习笔记","slug":"大数据基础知识学习-----Hive学习笔记","date":"2019-03-22T11:43:55.000Z","updated":"2019-03-22T12:13:15.122Z","comments":true,"path":"2019/03/22/大数据基础知识学习-----Hive学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/大数据基础知识学习-----Hive学习笔记/","excerpt":"[TOC] Hive基本概念Hive概述 Hive：由Facebook开源用于解决海量结构化日志的数据统计 Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能 本质是：将HQL转化成MapReduce程序 Hive处理的数据存储在HDFS Hive分析数据底层的实现是MapReduce 执行程序运行在YARN上","text":"[TOC] Hive基本概念Hive概述 Hive：由Facebook开源用于解决海量结构化日志的数据统计 Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能 本质是：将HQL转化成MapReduce程序 Hive处理的数据存储在HDFS Hive分析数据底层的实现是MapReduce 执行程序运行在YARN上 Hive的优缺点 优点 操作接口采用类SQL语法，提供快速开发的能力，简单、容易上手 避免了去写MapReduce，减少开发人员的学习成本 Hive的执行延迟比较高，因此Hive常用于数据分析，对实时性要求不高的场合 Hive优势在于处理大数据，对于处理小数据没有优势，因为Hive的执行延迟比较高 Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数 缺点 Hive的HQL表达能力有限 迭代式算法无法表达 数据挖掘方面不擅长 Hive的效率比较低 Hive自动生成的MapReduce作业，通常情况下不够智能化 Hive调优比较困难，粒度较粗 Hive架构原理 Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口。 用户接口：Client：CLI（hive shell）、JDBC/ODBC(java访问hive)、WEBUI（浏览器访问hive） `元数据：Metastore： 元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等； 默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore Hadoop：使用HDFS进行存储，使用MapReduce进行计算 驱动器：Driver： 解析器（SQL Parser）：将SQL字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr；对AST进行语法分析，比如表是否存在、字段是否存在、SQL语义是否有误。 编译器（Physical Plan）：将AST编译生成逻辑执行计划 优化器（Query Optimizer）：对逻辑执行计划进行优化 执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark。 Hive和数据库比较由于 Hive 采用了类似SQL 的查询语言 HQL(Hive Query Language)，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。本文将从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。 查询语言 由于SQL被广泛的应用在数据仓库中，因此，专门针对Hive的特性设计了类SQL的查询语言HQL。熟悉SQL开发的开发者可以很方便的使用Hive进行开发。 数据存储位置 Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。 数据更新 由于Hive是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此，Hive中不支持对数据的改写和添加，所有的数据都是在加载的时候确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO … VALUES 添加数据，使用 UPDATE … SET修改数据。 索引 Hive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些Key建立索引。Hive要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了 Hive 不适合在线数据查询。 执行 Hive中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的。而数据库通常有自己的执行引擎。 执行延迟 Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce框架。由于MapReduce 本身具有较高的延迟，因此在利用MapReduce 执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。 可扩展性 由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的（世界上最大的Hadoop 集群在 Yahoo!，2009年的规模在4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 Oracle 在理论上的扩展能力也只有100台左右。 数据规模 由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。 Hive安装环境准备Hive安装地址Hive官网地址：http://hive.apache.org/ 文档查看地址：https://cwiki.apache.org/confluence/display/Hive/GettingStarted 下载地址：http://archive.apache.org/dist/hive/ github地址：https://github.com/apache/hive Hive安装部署Hive安装及配置 把apache-hive-1.2.1-bin.tar.gz上传到linux的/opt/software目录下 解压apache-hive-1.2.1-bin.tar.gz到/opt/module/目录下面 [luo@hadoop102 software]$ tar -zxvf apache-hive-1.2.1-bin.tar.gz -C /opt/module/ 修改apache-hive-1.2.1-bin.tar.gz的名称为hive [luo@hadoop102 module]$ mv apache-hive-1.2.1-bin/ hive 修改/opt/module/hive/conf目录下的hive-env.sh.template名称为hive-env.sh [luo@hadoop102 conf]$ mv hive-env.sh.template hive-env.sh 配置hive-env.sh文件 配置HADOOP_HOME路径：export HADOOP_HOME=/opt/module/hadoop-2.7.2 配置HIVE_CONF_DIR路径：export HIVE_CONF_DIR=/opt/module/hive/conf Hive集群配置 必须启动hdfs和yarn [luo@hadoop102 hadoop-2.7.2]$ sbin/start-dfs.sh [luo@hadoop103 hadoop-2.7.2]$ sbin/start-yarn.sh 在HDFS上创建/tmp和/user/hive/warehouse两个目录并修改他们的同组权限可写 [luo@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -mkdir /tmp [luo@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -mkdir -p /user/hive/warehouse [luo@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /tmp [luo@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /user/hive/warehouse Hive基本操作 启动hive：[luo@hadoop102 hive]$ bin/hive 查看数据库：hive&gt;show databases; 打开默认数据库：hive&gt;use default; 显示default数据库中的表：hive&gt;show tables; 创建一张表：hive&gt; create table student(id int, name string); 显示数据库中有几张表：hive&gt;show tables; 查看表的结构：hive&gt;desc student; 向表中插入数据：hive&gt; insert into student values(1000,&quot;ss&quot;); 查询表中数据：hive&gt; select * from student; 退出hive：hive&gt; quit; 将本地文件导入Hive实例需求：将本地/opt/module/datas/student.txt这个目录下的数据导入到hive的student(id int, name string)表中。 数据准备在/opt/module/datas/student.txt这个目录下准备数据 在/opt/module/目录下创建datas [luo@hadoop102 module]$ mkdir datas 在/opt/module/datas/目录下创建student.txt文件并添加数据 [luo@hadoop102 module]$ touch student.txt[luo@hadoop102 module]$ vi student.txt1001 zhangshan1002 lishi1003 zhaoliu 注意以tab键间隔。 Hive实际操作 启动hive：[luo@hadoop102 hive]$ bin/hive 显示数据库：hive&gt;show databases; 使用default数据库：hive&gt;use default; 显示default数据库中的表：hive&gt;show tables; 删除已创建的student表：hive&gt; drop table student; 创建student表, 并声明文件分隔符’\\t’： hive&gt; create table student(id int, name string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\\t&#39;; 加载/opt/module/datas/student.txt 文件到student数据库表中： hive&gt; load data local inpath &#39;/opt/module/datas/student.txt&#39; into table student; Hive查询结果 hive&gt; select * from student;OK1001 zhangshan1002 lishi1003 zhaoliuTime taken: 0.266 seconds, Fetched: 3 row(s) Mysql的安装安装包准备 查看mysql是否安装，如果安装了，卸载mysql 查看：rpm -qa|grep mysql 卸载：rpm -e --nodeps mysql-libs-5.1.73-7.el6.x86_64 解压mysql-libs.zip文件到当前目录 [root@hadoop102 software]# unzip mysql-libs.zip [root@hadoop102 software]# ls 进入到mysql-libs文件夹下，并设置当前用户执行权限 [root@hadoop102 mysql-libs]# ll总用量 76048-rw-r–r–. 1 root root 18509960 3月 26 2015 MySQL-client-5.6.24-1.el6.x86_64.rpm-rw-r–r–. 1 root root 3575135 12月 1 2013 mysql-connector-java-5.1.27.tar.gz-rw-r–r–. 1 root root 55782196 3月 26 2015 MySQL-server-5.6.24-1.el6.x86_64.rpm [root@hadoop102 mysql-libs]# chmod u+x ./* [root@hadoop102 mysql-libs]# ll 总用量 76048-rwxr–r–. 1 root root 18509960 3月 26 2015 MySQL-client-5.6.24-1.el6.x86_64.rpm-rwxr–r–. 1 root root 3575135 12月 1 2013 mysql-connector-java-5.1.27.tar.gz-rwxr–r–. 1 root root 55782196 3月 26 2015 MySQL-server-5.6.24-1.el6.x86_64.rpm 安装Mysql服务器 安装mysql服务端：[root@hadoop102 mysql-libs]# rpm -ivh MySQL-server-5.6.24-1.el6.x86_64.rpm 查看产生的随机密码：[root@hadoop102 mysql-libs]# cat /root/.mysql_secret 查看mysql状态：[root@hadoop102 mysql-libs]# service mysql status 启动mysql：[root@hadoop102 mysql-libs]# service mysql start 安装Mysql客户端 安装mysql客户端：[root@hadoop102 mysql-libs]# rpm -ivh MySQL-client-5.6.24-1.el6.x86_64.rpm 连接mysql：[root@hadoop102 mysql-libs]# mysql -uroot -pOEXaQuS8IWkG19Xs 修改密码：mysql&gt;SET PASSWORD=PASSWORD(‘000000’); 退出mysql：mysql&gt;exit Mysql中user表中主机配置配置只要是root用户+密码，在任何主机上都能登录MySQL数据库。 进入mysql：[root@hadoop102 mysql-libs]# mysql -uroot -p000000 显示数据库：mysql&gt;show databases; 使用mysql数据库：mysql&gt;use mysql; 展示mysql数据库中的所有表：mysql&gt;show tables; 展示user表的结构：mysql&gt;desc user; 查询user表：mysql&gt;select User, Host, Password from user; 修改user表，把Host表内容修改为%：mysql&gt;update user set host=&#39;%&#39; where host=&#39;localhost&#39;; 删除root用户的其他host： mysql&gt;delete from user where Host=&#39;hadoop102 &#39;; mysql&gt;delete from user where Host=&#39;127.0.0.1&#39;; mysql&gt;delete from user where Host=&#39;::1&#39;; 刷新：mysql&gt;flush privileges; 退出：mysql&gt; quit; Hive元数据配置到Mysql驱动拷贝 在/opt/software/mysql-libs目录下解压mysql-connector-java-5.1.27.tar.gz驱动包 [root@hadoop102 mysql-libs]# tar -zxvf mysql-connector-java-5.1.27.tar.gz 拷贝/opt/software/mysql-libs/mysql-connector-java-5.1.27目录下的mysql-connector-java-5.1.27-bin.jar到/opt/module/hive/lib/ [root@hadoop102 mysql-connector-java-5.1.27]# cp mysql-connector-java-5.1.27-bin.jar /opt/module/hive/lib/ 配置Metastore到MySql 在/opt/module/hive/conf目录下创建一个hive-site.xml [root@hadoop102 conf]# touch hive-site.xml [root@hadoop102 conf]# vi hive-site.xml 根据官方文档配置参数，拷贝数据到hive-site.xml文件中。 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\"?&gt;&lt;?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://hadoop102:3306/metastore?createDatabaseIfNotExist=true&lt;/value&gt; &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;description&gt;username to use against metastore database&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;000000&lt;/value&gt; &lt;description&gt;password to use against metastore database&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 配置完毕后，如果启动hive异常，可以重新启动虚拟机。（重启后，别忘了启动hadoop集群） 多窗口启动Hive测试 先启动MySQL [luo@hadoop102 mysql-libs]$ mysql -uroot -p000000 查看有几个数据库：mysql&gt; show databases; 再次打开多个窗口，分别启动hive [luo@hadoop102 hive]$ bin/hive 启动hive后，回到MySQL窗口查看数据库，显示增加了metastore数据库：mysql&gt; show databases; Hive常用交互命令 [luo@hadoop102 hive]$ bin/hive -help “-e”不进入hive的交互窗口执行sql语句 [luo@hadoop102 hive]$ bin/hive -e “select id from default.student;” “-f”执行脚本中sql语句 在/opt/module/datas目录下创建hivef.sql文件 [luo@hadoop102 datas]$ touch hivef.sql 文件中写入正确的sql语句 select *from student; 执行文件中的sql语句 [luo@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql 执行文件中的sql语句并将结果写入文件中 [luo@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql &gt; /opt/module/datas/hive_result.txt Hive其他命令操作 退出hive窗口： hive(default)&gt;exit; hive(default)&gt;quit; 在hive cli命令窗口中如何查看hdfs文件系统 hive(default)&gt;dfs -ls /; 在hive cli命令窗口中如何查看hdfs本地系统 hive(default)&gt;! ls /opt/module/datas; 查看在hive中输入的所有历史命令 进入到当前用户的根目录/root或/home/atguigu 查看. hivehistory文件：[luo@hadoop102 ~]$ cat .hivehistory Hive常见属性配置Hive数据仓库位置配置 Default数据仓库的最原始位置是在hdfs上的：/user/hive/warehouse路径下 在仓库目录下，没有对默认的数据库default创建文件夹。如果某张表属于default数据库，直接在数据仓库目录下创建一个文件夹。 修改default数据仓库原始位置（将hive-default.xml.template如下配置信息拷贝到hive-site.xml文件中） 12345&lt;property&gt; &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt; &lt;value&gt;/user/hive/warehouse&lt;/value&gt; &lt;description&gt;location of default database for the warehouse&lt;/description&gt;&lt;/property&gt; 配置同组用户有执行权限 bin/hdfs dfs -chmod g+w /user/hive/warehouse 显示当前数据库，以及查询表的头信息配置 在hive-site.xml文件中添加如下配置信息，就可以实现显示当前数据库，以及查询表的头信息配置。 123456789&lt;property&gt; &lt;name&gt;hive.cli.print.header&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.cli.print.current.db&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt; 重新启动hive，对比配置前后差异 Hive运行日志信息配置 Hive的log默认存放在/tmp/atguigu/hive.log目录下（当前用户名下）。 修改hive的log存放日志到/opt/module/hive/logs 修改/opt/module/hive/conf/hive-log4j.properties.template文件名称为hive-log4j.properties [luo@hadoop102 conf]$ pwd/opt/module/hive/conf [luo@hadoop102 conf]$ mv hive-log4j.properties.template hive-log4j.properties 在hive-log4j.properties文件中修改log存放位置 hive.log.dir=/opt/module/hive/logs 参数配置方式 查看当前所有的配置信息：hive&gt;set; 参数的配置三种方式及优先级 配置文件方式 默认配置文件：hive-default.xml用户自定义配置文件：hive-site.xml 注意：用户自定义配置会覆盖默认配置。另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。配置文件的设定对本机启动的所有Hive进程都有效。 命令行参数方式 启动Hive时，可以在命令行添加-hiveconf param=value来设定参数。 例如：[luo@hadoop103 hive]$ bin/hive -hiveconf mapred.reduce.tasks=10;注意：仅对本次hive启动有效 查看参数设置：hive (default)&gt; set mapred.reduce.tasks; 参数声明方式 可以在HQL中使用SET关键字设定参数 例如：hive (default)&gt; set mapred.reduce.tasks=100;注意：仅对本次hive启动有效。 查看参数设置：hive (default)&gt; set mapred.reduce.tasks; 上述三种设定方式的优先级依次递增。即配置文件&lt;命令行参数&lt;参数声明。注意某些系统级的参数，例如log4j相关的设定，必须用前两种方式设定，因为那些参数的读取在会话建立以前已经完成了。 Hive数据类型基本数据类型 Hiv基本数据类型 Java数据类型 长度 例子 TINYINT byte 1byte有符号整数 20 SMALINT short 2byte有符号整数 20 INT int 4byte有符号整数 20 BIGINT long 8byte有符号整数 20 BOOLEAN boolean 布尔类型，true或者false true,false FLOAT float 单精度浮点数 3.14159 DOUBLE double 双精度浮点数 3.14159 STRING String 字符系列。可以指定字符集。可以使用单引号或者双引号 “now is” TIMESTAMP 时间类型 BINARY 字节数组 对于Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。 集合数据类型 数据类型 描述 示例 STRUCT 和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。 struct() MAP MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素 map() ARRAY 数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。 Array() Hive有三种复杂数据类型ARRAY、MAP 和 STRUCT。ARRAY和MAP与Java中的Array和Map类似，而STRUCT与C语言中的Struct类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。 案例如下 假设某表有如下一行，我们用JSON格式来表示其数据结构。在Hive下访问的格式为 123456789101112&#123; \"name\": \"songsong\", \"friends\": [\"bingbing\" , \"lili\"] , //列表Array, \"children\": &#123; //键值Map, \"xiao song\": 18 , \"xiaoxiao song\": 19 &#125; \"address\": &#123; //结构Struct, \"street\": \"hui long guan\" , \"city\": \"beijing\" &#125;&#125; 基于上述数据结构，我们在Hive里创建对应的表，并导入数据 创建本地测试文件test.txt 12songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijingyangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing 注意，MAP，STRUCT和ARRAY里的元素间关系都可以用同一个字符表示，这里用“_”。 r Hive上创建测试表test 12345678910create table test(name string,friends array&lt;string&gt;,children map&lt;string, int&gt;,address struct&lt;street:string, city:string&gt;)row format delimited fields terminated by ','collection items terminated by '_'map keys terminated by ':'lines terminated by '\\n'; 字段解释： row format delimited fields terminated by ‘,’ – 列分隔符 collection items terminated by ‘_’ –MAP STRUCT 和 ARRAY 的分隔符(数据分割符号) map keys terminated by ‘:’ – MAP中的key与value的分隔符 lines terminated by ‘\\n’; – 行分隔符 导入文本数据到测试表 hive (default)&gt; load data local inpath ‘/opt/module/datas/test.txt’ into table test; 访问三种集合列里的数据，以下分别是ARRAY，MAP，STRUCT的访问方式 hive (default)&gt; select friends[1],children[‘xiao song’],address.city from test where name=”songsong “ 类型转换Hive的原子数据类型是可以进行隐式转换的，类似于Java的类型转换，例如某表达式使用INT类型，TINYINT会自动转换为INT类型，但是Hive不会进行反向转化，例如，某表达式使用TINYINT类型，INT不会自动转换为TINYINT类型，它会返回错误，除非使用CAST 操作。 隐式类型转换规则如下 任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。 所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。 TINYINT、SMALLINT、INT都可以转换为FLOAT BOOLEAN类型不可以转换为任何其它的类型 可以使用CAST操作显示进行数据类型转换，例如CAST(‘1’ AS INT)将把字符串’1’ 转换成整数1；如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值 NULL。 DDL数据定义创建数据库 创建一个数据库，数据库在HDFS上的默认存储路径是/user/hive/warehouse/*.db hive (default)&gt; create database db_hive; 避免要创建的数据库已经存在错误，增加if not exists判断。（标准写法） hive (default)&gt; create database if not exists db_hive; 创建一个数据库，指定数据库在HDFS上存放的位置 hive (default)&gt; create database db_hive2 location ‘/db_hive2.db’; 修改数据库用户可以使用ALTER DATABASE命令为某个数据库的DBPROPERTIES设置键-值对属性值，来描述这个数据库的属性信息。数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。 hive (default)&gt; alter database db_hive set dbproperties(&#39;createtime&#39;=&#39;20170830&#39;); 在mysql中查看修改结果：hive&gt; desc database extended db_hive; 查询数据库显示数据库 显示数据库：hive&gt; show databases; 过滤显示查询的数据库：hive&gt; show databases like ‘db_hive*’; 查看数据库详情 显示数据库信息：hive&gt; desc database db_hive; 显示数据库详细信息，extended：hive&gt; desc database extended db_hive; 使用数据库 hive (default)&gt; use db_hive; 删除数据库 删除空数据库：hive&gt;drop database db_hive2; 如果删除的数据库不存在，最好采用 if exists判断数据库是否存在： hive&gt; drop database if exists db_hive2; 如果数据库不为空，可以采用cascade命令，强制删除 hive&gt; drop database db_hive cascade; 创建表 创建表语法 123456789CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name [(col_name data_type [COMMENT col_comment], ...)] [COMMENT table_comment] [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] [ROW FORMAT row_format] [STORED AS file_format] [LOCATION hdfs_path] 字段说明 CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。 EXTERNAL关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。 COMMENT：为表和列添加注释。 PARTITIONED BY创建分区表 CLUSTERED BY创建分桶表 SORTED BY不常用 用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。 STORED AS 指定存储文件类型 常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件） 如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。 LOCATION ：指定表在HDFS上的存储位置。 LIKE允许用户复制现有的表结构，但是不复制数据。 管理表默认创建的表都是所谓的管理表，有时也被称为内部表。因为这种表，Hive会（或多或少地）控制着数据的生命周期。Hive默认情况下会将这些表的数据存储在由配置项hive.metastore.warehouse.dir(例如，/user/hive/warehouse)所定义的目录的子目录下。当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据。 普通创建表 123456create table if not exists student2(id int, name string)row format delimited fields terminated by '\\t'stored as textfilelocation '/user/hive/warehouse/student2'; 根据查询结果创建表（查询的结果会添加到新创建的表中) 12create table if not exists student3as select id, name from student; 根据已经存在的表结构创建表 1create table if not exists student4 like student; 查询表的类型 1hive (default)&gt; desc formatted student2; 外部表因为表是外部表，所有Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉。 管理表和外部表的使用场景： 每天将收集到的网站日志定期流入HDFS文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的中间表、结果表使用内部表存储，数据通过SELECT+INSERT进入内部表。 外部表实例 分别创建部门和员工外部表，并向表中导入数据。 原始数据 dep.txt 123410 ACCOUNTING 170020 RESEARCH 180030 SALES 190040 OPERATIONS 1700 emp.txt 12345678910111213147369 SMITH CLERK 7902 1980-12-17 800.00 207499 ALLEN SALESMAN 7698 1981-2-20 1600.00 300.00 307521 WARD SALESMAN 7698 1981-2-22 1250.00 500.00 307566 JONES MANAGER 7839 1981-4-2 2975.00 207654 MARTIN SALESMAN 7698 1981-9-28 1250.00 1400.00 307698 BLAKE MANAGER 7839 1981-5-1 2850.00 307782 CLARK MANAGER 7839 1981-6-9 2450.00 107788 SCOTT ANALYST 7566 1987-4-19 3000.00 207839 KING PRESIDENT 1981-11-17 5000.00 107844 TURNER SALESMAN 7698 1981-9-8 1500.00 0.00 307876 ADAMS CLERK 7788 1987-5-23 1100.00 207900 JAMES CLERK 7698 1981-12-3 950.00 307902 FORD ANALYST 7566 1981-12-3 3000.00 207934 MILLER CLERK 7782 1982-1-23 1300.00 10 建表语句 创建部门表 123456create external table if not exists default.dept(deptno int,dname string,loc int)row format delimited fields terminated by '\\t'; 创建员工表 12345678910create external table if not exists default.emp(empno int,ename string,job string,mgr int,hiredate string, sal double, comm double,deptno int)row format delimited fields terminated by '\\t'; 查看创建的表 hive (default)&gt; show tables; 向外部表中导入数据 12hive (default)&gt; load data local inpath &apos;/opt/module/datas/dept.txt&apos; into table default.dept;hive (default)&gt; load data local inpath &apos;/opt/module/datas/emp.txt&apos; into table default.emp; 查询外部表结果 12hive (default)&gt; select * from emp;hive (default)&gt; select * from dept; 查看表格式化数据 1hive (default)&gt; desc formatted dept; 分区表分区表实际上就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过WHERE子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。 分区的基本操作引入分区表（需要根据日期对日志进行管理） 123/user/hive/warehouse/log_partition/20170702/20170702.log/user/hive/warehouse/log_partition/20170703/20170703.log/user/hive/warehouse/log_partition/20170704/20170704.log 创建分区表语法 12345hive (default)&gt; create table dept_partition( deptno int, dname string, loc string ) partitioned by (month string) row format delimited fields terminated by &apos;\\t&apos;; 加载数据到分区表中 123hive (default)&gt; load data local inpath &apos;/opt/module/datas/dept.txt&apos; into table default.dept_partition partition(month=&apos;201709&apos;);hive (default)&gt; load data local inpath &apos;/opt/module/datas/dept.txt&apos; into table default.dept_partition partition(month=&apos;201708&apos;);hive (default)&gt; load data local inpath &apos;/opt/module/datas/dept.txt&apos; into table default.dept_partition partition(month=&apos;201707&apos;); 查询分区表中数据 单分区查询 1hive (default)&gt; select * from dept_partition where month=&apos;201709&apos;; 多分区联合查询 12345hive (default)&gt; select * from dept_partition where month=&apos;201709&apos; union select * from dept_partition where month=&apos;201708&apos; union select * from dept_partition where month=&apos;201707&apos;; 增加分区 创建单个分区 1hive (default)&gt; alter table dept_partition add partition(month=&apos;201706&apos;) ; 同时创建多个分区 1hive (default)&gt; alter table dept_partition add partition(month=&apos;201705&apos;) partition(month=&apos;201704&apos;); 删除分区 删除单个分区 1hive (default)&gt; alter table dept_partition drop partition (month=&apos;201704&apos;); 同时删除多个分区 1hive (default)&gt; alter table dept_partition drop partition (month=&apos;201705&apos;), partition (month=&apos;201706&apos;); 查看分区表有多少分区 1hive&gt;show partitions dept_partition; 查看分区表结构 1hive&gt;desc formatted dept_partition; 分区表注意事项创建二级分区表 12345hive (default)&gt; create table dept_partition2( deptno int, dname string, loc string ) partitioned by (month string, day string) row format delimited fields terminated by &apos;\\t&apos;; 正常的加载数据 加载数据到二级分区表中 1hive (default)&gt; load data local inpath &apos;/opt/module/datas/dept.txt&apos; into table default.dept_partition2 partition(month=&apos;201709&apos;, day=&apos;13&apos;); 查询分区数据 1hive (default)&gt; select * from dept_partition2 where month=&apos;201709&apos; and day=&apos;13&apos;; 把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式 方式一：上传数据后修复 上传数据 hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12; hive (default)&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12; 查询数据（老版本的hive，查询不到刚上传的数据） hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’12’; 执行修复命令 hive&gt;msck repair table dept_partition2; 再次查询数据 hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’12’; 方式二：上传数据后添加分区 上传数据 hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=11; hive (default)&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=11; 执行添加分区 hive (default)&gt; alter table dept_partition2 add partition(month=’201709’, day=’11’); 查询数据 hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’11’; 方式三：上传数据后load数据到分区 创建目录 hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=10; 上传数据： hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table dept_partition2 partition(month=’201709’,day=’10’); 查询数据： hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’10’; 修改表重命名表ALTER TABLE table_name RENAME TO new_table_name 1hive (default)&gt; alter table dept_partition2 rename to dept_partition3; 增加/修改/替换列信息更新列 1ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name] 增加和替换列 1ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) 注：ADD是代表新增一字段，字段位置在所有列后面(partition列前)，REPLACE则是表示替换表中所有字段。 修改表实例 查询表结构：hive&gt;desc dept_partition; 添加列：hive (default)&gt; alter table dept_partition add columns(deptdesc string); 查询表结构：hive&gt;desc dept_partition; 更新列：hive (default)&gt; alter table dept_partition change column deptdesc desc int; 查询表结构：hive&gt;desc dept_partition; 替换列：hive (default)&gt; alter table dept_partition replace columns(deptno string, dname string, loc string); 查询表结构：hive&gt;desc dept_partition; 删除表hive (default)&gt; drop table dept_partition; DML数据操作数据导入向表中装载数据（Load） 12345678hive&gt;load data [local] inpath &apos;/opt/module/datas/student.txt&apos; [overwrite] into table student [partition (partcol1=val1,…)];（1）load data:表示加载数据（2）local:表示从本地加载数据到hive表；否则从HDFS加载数据到hive表（3）inpath:表示加载数据的路径（4）into table:表示加载到哪张表（5）student:表示具体的表（6）overwrite:表示覆盖表中已有数据，否则表示追加（7）partition:表示上传到指定分区 向表中装载数据实例 创建一张表 1hive (default)&gt; create table student(id string, name string) row format delimited fields terminated by &apos;\\t&apos;; 加载本地文件到hive 1hive (default)&gt; load data local inpath &apos;/opt/module/datas/student.txt&apos; into table default.student; 加载HDFS文件到hive中 12345上传文件到HDFShive (default)&gt; dfs -put /opt/module/datas/student.txt /user/atguigu/hive;加载HDFS上数据hive (default)&gt;load data inpath &apos;/user/atguigu/hive/student.txt&apos; into table default.student; 加载数据覆盖表中已有的数据 12345上传文件到HDFShive (default)&gt; dfs -put /opt/module/datas/student.txt /user/atguigu/hive;加载数据覆盖表中已有的数据hive (default)&gt;load data inpath &apos;/user/atguigu/hive/student.txt&apos; overwrite into table default.student; 通过查询语句向表中插入数据（Insert）","categories":[{"name":"大数据","slug":"大数据","permalink":"https://caochenhins.github.io/categories/大数据/"}],"tags":[{"name":"Hive","slug":"Hive","permalink":"https://caochenhins.github.io/tags/Hive/"}]},{"title":"JavaEE进阶知识学习----Quartz-3-Scheduler函数","slug":"JavaEE进阶知识学习----Quartz-3-Scheduler函数","date":"2019-03-22T11:43:54.000Z","updated":"2019-03-22T12:32:05.969Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Quartz-3-Scheduler函数/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Quartz-3-Scheduler函数/","excerpt":"####Scheduler的主要函数 Date scheduleJob = scheduler.scheduleJob(jobDetail, trigger);","text":"####Scheduler的主要函数 Date scheduleJob = scheduler.scheduleJob(jobDetail, trigger); 绑定jobDetail和trigger，将它注册进Scheduler中，将trigger中的时间来触发jobDetail中的业务逻辑，返回的时间是最近一次的执行时间。 void start();启动Scheduler void standdby();暂停 核心代码如下 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail, trigger); //scheduler执行两秒后挂起 Thread.sleep(2000L); scheduler.standby(); //scheduler挂起三秒后重新执行 Thread.sleep(3000L); scheduler.start(); 执行结果为： 当前时间为：2018-01-24 15:25:20 Hello world 当前时间为：2018-01-24 15:25:21 Hello world 当前时间为：2018-01-24 15:25:22 Hello world 当前时间为：2018-01-24 15:25:25 Hello world 当前时间为：2018-01-24 15:25:25 Hello world 当前时间为：2018-01-24 15:25:25 Hello world 当前时间为：2018-01-24 15:25:26 Hello world void shutdown();关闭 方法中可以传入一个布尔类型的参数，true表示等待所有正在执行的job执行完毕后，再关闭scheduler，false表示直接关闭scheduler。 ####quartz.properties项目启动会加载项目根目录下的quartz.properties文件，没有就会加载jar下的quartz.properties文件，文件中的属性如下 调度器属性：org.quartz.scheduler.instanceName属性用来区分特定的调度器实例，可以按照功能用途来给调度器起名。org.quartz.scheduler.instanceId属性和前者一样，也允许任何字符串，但是这个值必须在所有调度器实例中是唯一的，尤其在一个集群中，作为集群的唯一key。 线程池属性：重要的属性是threadCount，threadPriority优先值 作业存储设置：描述了调度器实例的生命周期，Job和Trigger信息是如何被存储的。 插件配置：满足特定需求用到的Quartz插件的配置。 ####quartz.properties文件实例 # Default Properties file for use by StdSchedulerFactory # to create a Quartz Scheduler Instance, if a different # properties file is not explicitly specified. # # =========================================================================== # Configure Main Scheduler Properties 调度器属性 # =========================================================================== org.quartz.scheduler.instanceName: DefaultQuartzScheduler org.quartz.scheduler.instanceid:AUTO org.quartz.scheduler.rmi.export: false org.quartz.scheduler.rmi.proxy: false org.quartz.scheduler.wrapJobExecutionInUserTransaction: false # =========================================================================== # Configure ThreadPool 线程池属性 # =========================================================================== #线程池的实现类（一般使用SimpleThreadPool即可满足几乎所有用户的需求） org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool #指定线程数，至少为1（无默认值）(一般设置为1-100直接的整数合适) org.quartz.threadPool.threadCount: 10 #设置线程的优先级（最大为java.lang.Thread.MAX_PRIORITY 10，最小为Thread.MIN_PRIORITY 1，默认为5） org.quartz.threadPool.threadPriority: 5 #设置SimpleThreadPool的一些属性 #设置是否为守护线程 #org.quartz.threadpool.makethreadsdaemons = false #org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true #org.quartz.threadpool.threadsinheritgroupofinitializingthread=false #线程前缀默认值是：[Scheduler Name]_Worker #org.quartz.threadpool.threadnameprefix=swhJobThead; # 配置全局监听(TriggerListener,JobListener) 则应用程序可以接收和执行 预定的事件通知 # =========================================================================== # Configuring a Global TriggerListener 配置全局的Trigger监听器 # MyTriggerListenerClass 类必须有一个无参数的构造函数，和 属性的set方法，目前2.2.x只支持原始数据类型的值（包括字符串） # =========================================================================== #org.quartz.triggerListener.NAME.class = com.swh.MyTriggerListenerClass #org.quartz.triggerListener.NAME.propName = propValue #org.quartz.triggerListener.NAME.prop2Name = prop2Value # =========================================================================== # Configuring a Global JobListener 配置全局的Job监听器 # MyJobListenerClass 类必须有一个无参数的构造函数，和 属性的set方法，目前2.2.x只支持原始数据类型的值（包括字符串） # =========================================================================== #org.quartz.jobListener.NAME.class = com.swh.MyJobListenerClass #org.quartz.jobListener.NAME.propName = propValue #org.quartz.jobListener.NAME.prop2Name = prop2Value # =========================================================================== # Configure JobStore 存储调度信息（工作，触发器和日历等） # =========================================================================== # 信息保存时间 默认值60秒 org.quartz.jobStore.misfireThreshold: 60000 #保存job和Trigger的状态信息到内存中的类 org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore # =========================================================================== # Configure SchedulerPlugins 插件属性 配置 # =========================================================================== # 自定义插件 #org.quartz.plugin.NAME.class = com.swh.MyPluginClass #org.quartz.plugin.NAME.propName = propValue #org.quartz.plugin.NAME.prop2Name = prop2Value #配置trigger执行历史日志（可以看到类的文档和参数列表） org.quartz.plugin.triggHistory.class = org.quartz.plugins.history.LoggingTriggerHistoryPlugin org.quartz.plugin.triggHistory.triggerFiredMessage = Trigger {1}.{0} fired job {6}.{5} at: {4, date, HH:mm:ss MM/dd/yyyy} org.quartz.plugin.triggHistory.triggerCompleteMessage = Trigger {1}.{0} completed firing job {6}.{5} at {4, date, HH:mm:ss MM/dd/yyyy} with resulting trigger instruction code: {9} #配置job调度插件 quartz_jobs(jobs and triggers内容)的XML文档 #加载 Job 和 Trigger 信息的类 （1.8之前用：org.quartz.plugins.xml.JobInitializationPlugin） org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.XMLSchedulingDataProcessorPlugin #指定存放调度器(Job 和 Trigger)信息的xml文件，默认是classpath下quartz_jobs.xml org.quartz.plugin.jobInitializer.fileNames = my_quartz_job2.xml #org.quartz.plugin.jobInitializer.overWriteExistingJobs = false org.quartz.plugin.jobInitializer.failOnFileNotFound = true #自动扫描任务单并发现改动的时间间隔,单位为秒 org.quartz.plugin.jobInitializer.scanInterval = 10 #覆盖任务调度器中同名的jobDetail,避免只修改了CronExpression所造成的不能重新生效情况 org.quartz.plugin.jobInitializer.wrapInUserTransaction = false # =========================================================================== # Sample configuration of ShutdownHookPlugin ShutdownHookPlugin插件的配置样例 # =========================================================================== #org.quartz.plugin.shutdownhook.class = \\org.quartz.plugins.management.ShutdownHookPlugin #org.quartz.plugin.shutdownhook.cleanShutdown = true # # Configure RMI Settings 远程服务调用配置 # #如果你想quartz-scheduler出口本身通过RMI作为服务器，然后设置“出口”标志true(默认值为false)。 #org.quartz.scheduler.rmi.export = false #主机上rmi注册表(默认值localhost) #org.quartz.scheduler.rmi.registryhost = localhost #注册监听端口号（默认值1099） #org.quartz.scheduler.rmi.registryport = 1099 #创建rmi注册，false/never：如果你已经有一个在运行或不想进行创建注册 # true/as_needed:第一次尝试使用现有的注册，然后再回来进行创建 # always:先进行创建一个注册，然后再使用回来使用注册 #org.quartz.scheduler.rmi.createregistry = never #Quartz Scheduler服务端端口，默认是随机分配RMI注册表 #org.quartz.scheduler.rmi.serverport = 1098 #true:链接远程服务调度(客户端),这个也要指定registryhost和registryport，默认为false # 如果export和proxy同时指定为true，则export的设置将被忽略 #org.quartz.scheduler.rmi.proxy = false 未完，待续","categories":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/categories/Quartz/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/tags/Quartz/"}]},{"title":"JavaEE进阶知识学习----Quartz-2-触发器Trigger","slug":"JavaEE进阶知识学习----Quartz-2-触发器Trigger","date":"2019-03-22T11:43:54.000Z","updated":"2019-03-22T12:32:03.421Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Quartz-2-触发器Trigger/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Quartz-2-触发器Trigger/","excerpt":"###认识TriggerQuartz中的触发器是用来告诉调度程序作业什么时候触发，即Trigger对象是用来触发执行Job的。","text":"###认识TriggerQuartz中的触发器是用来告诉调度程序作业什么时候触发，即Trigger对象是用来触发执行Job的。 ###触发器的通用属性JobKey：表示job实例的标识，触发器被触发时，该指定的job实例会执行。StartTime：表示触发器的时间表首次触发的时间，值为util.Date。EndTime：指定触发器的不再被触发的时间，值为util.Date。实例如下HelloScheduler类中的startAt(date)和endAt(endDate) public class HelloScheduler { public static void main(String[] args) throws SchedulerException { //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;) .build(); //获取距离当前时间3秒后的时间 date.setTime(date.getTime()+3000); //获取距离当前时间6秒后的时间 Date endDate = new Date(); endDate.setTime(endDate.getTime()+6000); // 创建一个Trigger实例，定义该Job立即执行，并且每隔两秒钟重复执行一次 Trigger trigger = TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .startAt(date)//开始执行时间为当前时间的后3秒 .endAt(endDate)//停止执行的时间为当前时间的后6秒 .withSchedule( SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(2).repeatForever()) .build(); //创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail,trigger); } } HelloJob中获取了开始执行时间和结束执行时间。 public class HelloJob implements Job{ @Override public void execute(JobExecutionContext context) throws JobExecutionException { //打印当前的执行时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); Trigger currentTrigger = context.getTrigger(); System.out.println(&quot;开始时间为：&quot;+currentTrigger.getStartTime()); System.out.println(&quot;结束时间为：&quot;+currentTrigger.getEndTime()); JobKey jobKey = currentTrigger.getJobKey(); System.out.println(&quot;jobKeyName:&quot;+jobKey.getName()+&quot;jobGroup:&quot;+jobKey.getGroup()); } } ###认识SimpleTrigger在一个指定时间段内执行一次作业任务，或是在指定的时间间隔内多次执行作业任务。实例一：距离当前时间4秒后执行且执行一次 public class HelloJob implements Job{ @Override public void execute(JobExecutionContext context) throws JobExecutionException { //打印当前的执行时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); System.out.println(&quot;Hello world&quot;); } } HelloScheduler类中代码如下 public class HelloScheduler { public static void main(String[] args) throws SchedulerException { //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;) .build(); //距离当前时间4秒后执行且执行一次 date.setTime(date.getTime()+4000); SimpleTrigger trigger = (SimpleTrigger)TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .startAt(date) .build(); //创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail,trigger); } } 实例二：距距离当前时间4秒后首次执行任务之后每隔两秒重复执行一次，在第一次执行再连续执行三次 public class HelloScheduler { public static void main(String[] args) throws SchedulerException { //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot; + sf.format(date)); // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;).build(); // 距距离当前时间4秒后首次执行任务之后每隔两秒重复执行一次，在第一次执行再连续执行三次 date.setTime(date.getTime() + 4000); SimpleTrigger trigger = (SimpleTrigger) TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .startAt(date) .withSchedule( SimpleScheduleBuilder .simpleSchedule() .withIntervalInSeconds(2) .withRepeatCount(3)) .build(); // 创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail, trigger); } } 实例三：距离当前时间4秒后首次执行，距离当前时间后6秒停止执行 public class HelloScheduler { public static void main(String[] args) throws SchedulerException { //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot; + sf.format(date)); // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;).build(); // 距离当前时间4秒后首次执行，距离当前时间后6秒停止执行 date.setTime(date.getTime() + 4000); Date endDate = new Date(); endDate.setTime(endDate.getTime()+6000); SimpleTrigger trigger = (SimpleTrigger) TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .startAt(date) .endAt(endDate) .withSchedule( SimpleScheduleBuilder .simpleSchedule() .withIntervalInSeconds(2) .withRepeatCount(3)) .build(); // 创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail, trigger); } } ####注意重复次数withRepeatCount：可以是0，正整数或是SimpleTrigger.REPEAT_INDEFINITELY常量值重复执行间隔withIntervalInSeconds：必须为0或者长整数指定了endAt参数，就会覆盖重复执行的效果 ###认识CronTrigger基于日历的作业调度器，而不是像SimpleTrigger那样精确的指定时间间隔，比SimpleTrigger更常用。 ####Cron表达式用于配置CronTrigger实例，是由7个子表达式组成的字符串，描述了时间表的详细信息，格式为： [秒] [分] [小时] [日] [月] [周] [年]实例一：使用CronTrigger 每秒钟触发一次任务 public class HelloScheduler { public static void main(String[] args) throws SchedulerException { //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot; + sf.format(date)); // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;).build(); // 每秒执行一次任务 CronTrigger trigger = (CronTrigger) TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .withSchedule( CronScheduleBuilder.cronSchedule(&quot;* * * * * ? *&quot;)) .build(); // 创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail, trigger); } } 注意，表达式中的空格和英文状态 ####Cron表达式特殊字符意义对应表 ####Cron表达式举例实例： #####2017年内的每天10点15分触发一次0 15 10 ？ 2017 #####每天的14点整至14点59分55秒，以及18点整至18点59分55秒，每5秒钟触发一次0/5 14,18 * ? ####通配符说明 ####Cron表达式 L和W可以一起使用，例如LW表示每个月的最后一个工作日 周字段英文字母不区分大小写 利用工具，在线生成百度搜索Crona表达式在线生成器 ###Scheduler-工厂模式所有的Schedule实例应该有SchedulerFactory来创建，Quartz的三个核心概念是调度器，任务和触发器关系如下： ####Scheduler创建方式 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); DirectSchedulerFactory factory = DirectSchedulerFactory.getInstance(); Scheduler scheduler2 = factory.getScheduler(); ####StdSchedulerFactory 使用一组参数（Java.util.Properties）来创建和初始化Quartz调度器。 配置参数一般存储在quartz.properties中。 调用getScheduler方法就能创建和初始化调度器对象。 未完，待续","categories":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/categories/Quartz/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/tags/Quartz/"}]},{"title":"JavaEE进阶知识学习----Quartz-4-Quartz整合","slug":"JavaEE进阶知识学习----Quartz-4-Quartz整合","date":"2019-03-22T11:43:54.000Z","updated":"2019-03-22T12:32:05.206Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Quartz-4-Quartz整合/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Quartz-4-Quartz整合/","excerpt":"###Quartz和SpringMVC，Spring整合1.Quartz依赖的包如下：","text":"###Quartz和SpringMVC，Spring整合1.Quartz依赖的包如下： org.springframework spring-context-support ${spring.version} &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; ####使用Quartz配置作业的方式第一种：MethodInvokingJobDetailFactoryBean，在dispatcher-servlet.xml中配置 &lt;bean id=&quot;simpleJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt; &lt;property name=&quot;targetObject&quot; ref=&quot;myBean&quot; /&gt; &lt;property name=&quot;targetMethod&quot; value=&quot;printMessage&quot; /&gt; &lt;/bean&gt; SimpleTrigger的相关配置 &lt;!-- 距离当前时间1秒之后执行，之后每隔两秒钟执行一次 --&gt; &lt;bean id=&quot;mySimpleTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;simpleJobDetail&quot;/&gt; &lt;property name=&quot;startDelay&quot; value=&quot;1000&quot;/&gt; &lt;property name=&quot;repeatInterval&quot; value=&quot;2000&quot;/&gt; &lt;/bean&gt; 其中myBean的相关代码如下 @Component(&quot;myBean&quot;) public class MyBean { public void printMessage() { // 打印当前的执行时间，格式为2017-01-01 00:00:00 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;MyBean Executes!&quot; + sf.format(date)); } } 第二种：JobDetailFactoryBean，在dispatcher-servlet.xml中配置 &lt;bean id=&quot;firstComplexJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;property name=&quot;jobClass&quot; value=&quot;com.imooc.springquartz.quartz.FirstScheduledJob&quot; /&gt; &lt;property name=&quot;jobDataMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;anotherBean&quot; value-ref=&quot;anotherBean&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;Durability&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; anotherBean的相关代码如下： @Component(&quot;anotherBean&quot;) public class AnotherBean { public void printAnotherMessage() { System.out.println(&quot;AnotherMessage&quot;); } } FirstScheduledJob类相关代码如下 public class FirstScheduledJob extends QuartzJobBean{ private AnotherBean anotherBean; public void setAnotherBean(AnotherBean anotherBean){ this.anotherBean = anotherBean; } @Override protected void executeInternal(JobExecutionContext arg0) throws JobExecutionException { Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;FirstScheduledJob Executes!&quot; + sf.format(date)); this.anotherBean.printAnotherMessage(); } } myCronTrigger的相关配置如下 &lt;!-- 每隔5秒钟执行一次 --&gt; &lt;bean id=&quot;myCronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;firstComplexJobDetail&quot;/&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0/5 * * ? * *&quot;/&gt; &lt;/bean&gt; 两种方法的Scheduler的相关配置 &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetails&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;simpleJobDetail&quot;/&gt; &lt;ref bean=&quot;firstComplexJobDetail&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mySimpleTrigger&quot;/&gt; &lt;ref bean=&quot;myCronTrigger&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; ####完整项目如下：1.dispatcher-servlet.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; default-lazy-init=&quot;true&quot;&gt; &lt;!-- 通过mvc:resources设置静态资源，这样servlet就会处理这些静态资源，而不通过控制器 --&gt; &lt;!-- 设置不过滤内容，比如:css,jquery,img 等资源文件 --&gt; &lt;mvc:resources location=&quot;/*.html&quot; mapping=&quot;/**.html&quot; /&gt; &lt;mvc:resources location=&quot;/css/*&quot; mapping=&quot;/css/**&quot; /&gt; &lt;mvc:resources location=&quot;/js/*&quot; mapping=&quot;/js/**&quot; /&gt; &lt;mvc:resources location=&quot;/images/*&quot; mapping=&quot;/images/**&quot; /&gt; &lt;!-- 设定消息转换的编码为utf-8防止controller返回中文乱码 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 添加注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 默认扫描的包路径 --&gt; &lt;context:component-scan base-package=&quot;com.imooc.springquartz&quot; /&gt; &lt;!-- mvc:view-controller可以在不需要Controller处理request的情况，转向到设置的View --&gt; &lt;!-- 像下面这样设置，如果请求为/，则不通过controller，而直接解析为/index.jsp --&gt; &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&gt;&lt;/property&gt; &lt;!-- 配置jsp路径前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt; &lt;!-- 配置URl后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;simpleJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt; &lt;property name=&quot;targetObject&quot; ref=&quot;myBean&quot; /&gt; &lt;property name=&quot;targetMethod&quot; value=&quot;printMessage&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;firstComplexJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;property name=&quot;jobClass&quot; value=&quot;com.imooc.springquartz.quartz.FirstScheduledJob&quot; /&gt; &lt;property name=&quot;jobDataMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;anotherBean&quot; value-ref=&quot;anotherBean&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;Durability&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 距离当前时间1秒之后执行，之后每隔两秒钟执行一次 --&gt; &lt;bean id=&quot;mySimpleTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;simpleJobDetail&quot;/&gt; &lt;property name=&quot;startDelay&quot; value=&quot;1000&quot;/&gt; &lt;property name=&quot;repeatInterval&quot; value=&quot;2000&quot;/&gt; &lt;/bean&gt; &lt;!-- 每隔5秒钟执行一次 --&gt; &lt;bean id=&quot;myCronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;firstComplexJobDetail&quot;/&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0/5 * * ? * *&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetails&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;simpleJobDetail&quot;/&gt; &lt;ref bean=&quot;firstComplexJobDetail&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mySimpleTrigger&quot;/&gt; &lt;ref bean=&quot;myCronTrigger&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 2.项目结构基础知识就先告一段落吧！！！！","categories":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/categories/Quartz/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/tags/Quartz/"}]},{"title":"JavaEE进阶知识学习----Quartz-1-HelloWord","slug":"JavaEE进阶知识学习----Quartz-1-HelloWord","date":"2019-03-22T11:43:54.000Z","updated":"2019-03-22T12:32:06.983Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Quartz-1-HelloWord/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Quartz-1-HelloWord/","excerpt":"###概要Quartz是一款强大的开源任务调度框架。主要用到了Builder模式，factory模式，组件模式和链式写法。包括了三个核心概念，分别是调度器，任务和触发器。","text":"###概要Quartz是一款强大的开源任务调度框架。主要用到了Builder模式，factory模式，组件模式和链式写法。包括了三个核心概念，分别是调度器，任务和触发器。 ###重要组成部分Job：实现任务逻辑的任务接口。JobDetail：JobDetail为Job实例提供了许多设置属性，以及JobDataMap成员变量属性，它用来存储特定Job实例的状态信息，调度器需要借助JobDetail对象来添加Job实例。重要的属性如下：name、group、jobClass、jobDataMap。 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;).build(); System.out.println(&quot;jobDetail name:&quot;+jobDetail.getKey().getName());// myJob System.out.println(&quot;jobDetail group:&quot;+jobDetail.getKey().getGroup());// ground1 System.out.println(&quot;jobDetail jobClass:&quot;+jobDetail.getJobClass().getName());// com.study.quartz.HelloJob JobBuilderJobStoreTriggerTriggerBuilderThreadPoolSchedulercalendar：一个Trigger可以和多个Calendar关联，以排除或包含某些时间点。监听器：JobListener,TriggerListener,ScheduerListener ###Quartz的Hello Word ####1.创建一个maven工程，并引入Quartz的相关jar &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; ####2.创建一个job类 import java.text.SimpleDateFormat; import java.util.Date; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; public class HelloJob implements Job{ @Override public void execute(JobExecutionContext arg0) throws JobExecutionException { //打印当前的执行时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); //编写具体的业务逻辑 System.out.println(&quot;Hello World&quot;); } } ####3.创建一个Scheduler类 import java.text.SimpleDateFormat; import java.util.Date; import org.quartz.JobBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SchedulerException; import org.quartz.SchedulerFactory; import org.quartz.SimpleScheduleBuilder; import org.quartz.Trigger; import org.quartz.TriggerBuilder; import org.quartz.impl.StdSchedulerFactory; public class HelloScheduler { public static void main(String[] args) throws SchedulerException { // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;).build(); // 创建一个Trigger实例，定义该Job立即执行，并且每隔两秒钟重复执行一次 Trigger trigger = TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .startNow() .withSchedule( SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(2).repeatForever()) .build(); //创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); scheduler.scheduleJob(jobDetail,trigger); } } ###Job中的JobExecutionContext 当Scheduler调用一个job，就会将JobExecutionContext传递给Job的execute方法。 Job可以通过JobExecutionContext对象访问到Quartz运行时候的环境以及Job本身的明细数据。 ###JobDataMap 在进行任务调度时JobDataMap存储在JobExecutionContext中，方便获取。 JobDataMap可以用来装载任何可序列化的数据对象，当job实例对象被执行时这些参数对象就会传递给他。 JobDataMap实现了JDK的Map接口，并且添加了一些方便的方法用来存取基本的数据类型。 ####JobDataMap的获取方式我们修改了HelloScheduler类，并传入了一些我们自定义的参数和值，如何在job中获取这些值，就使用到了JobDataMap对象。 public class HelloScheduler { public static void main(String[] args) throws SchedulerException { // 创建一个JobDetail实例，将实例与HelloJob绑定 JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(&quot;myJob&quot;, &quot;ground1&quot;) .usingJobData(&quot;message&quot;, &quot;Hello job&quot;) .usingJobData(&quot;doubleJobValue&quot;, 66.6).build(); // 创建一个Trigger实例，定义该Job立即执行，并且每隔两秒钟重复执行一次 Trigger trigger = TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .usingJobData(&quot;message&quot;, &quot;Hello trigger&quot;) .usingJobData(&quot;doubleTrigglerValue&quot;, 88.8) .startNow() .withSchedule( SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(2).repeatForever()) .build(); //创建Schedule实例 SchedulerFactory sFactory = new StdSchedulerFactory(); Scheduler scheduler = sFactory.getScheduler(); scheduler.start(); //打印当前时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); scheduler.scheduleJob(jobDetail,trigger); } } Job类中JobDataMap的获取方式如下，包含了如何获取trigger中的自定义的参数值。 public class HelloJob implements Job{ @Override public void execute(JobExecutionContext context) throws JobExecutionException { //打印当前的执行时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); //编写具体的业务逻辑 JobKey key = context.getJobDetail().getKey(); System.out.println(&quot;Job的name属性值和group属性值分别为：&quot;+key.getName()+&quot;:&quot;+key.getGroup()); TriggerKey trKey = context.getTrigger().getKey(); System.out.println(&quot;Trigger的name属性值和group属性值分别为：&quot;+trKey.getName()+&quot;:&quot;+trKey.getGroup()); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); JobDataMap tDataMap = context.getTrigger().getJobDataMap(); String jobMsg = dataMap.getString(&quot;message&quot;); double doubleJobValue = dataMap.getDouble(&quot;doubleJobValue&quot;); String tiggerMsg = tDataMap.getString(&quot;message&quot;); double doubleTrigglerValue = tDataMap.getDouble(&quot;doubleTrigglerValue&quot;); System.out.println(&quot;jobMsg：&quot;+jobMsg); System.out.println(&quot;doubleJobValue：&quot;+doubleJobValue); System.out.println(&quot;tiggerMsg：&quot;+tiggerMsg); System.out.println(&quot;doubleTrigglerValue：&quot;+doubleTrigglerValue); } } 输出结果为： 当前时间为：2018-01-22 17:03:29 Job的name属性值和group属性值分别为：myJob:ground1 Trigger的name属性值和group属性值分别为：myTrigger:group1 jobMsg：Hello job doubleJobValue：66.6 tiggerMsg：Hello trigger doubleTrigglerValue：88.8 ####也可以使用成员变量的getter和setter获取修改job类的代码如下 public class HelloJob implements Job{ private String message; private double doubleJobValue; private double doubleTrigglerValue; public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public double getDoubleJobValue() { return doubleJobValue; } public void setDoubleJobValue(double doubleJobValue) { this.doubleJobValue = doubleJobValue; } public double getDoubleTrigglerValue() { return doubleTrigglerValue; } public void setDoubleTrigglerValue(double doubleTrigglerValue) { this.doubleTrigglerValue = doubleTrigglerValue; } @Override public void execute(JobExecutionContext context) throws JobExecutionException { //打印当前的执行时间 Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;当前时间为：&quot;+sf.format(date)); //编写具体的业务逻辑 JobKey key = context.getJobDetail().getKey(); System.out.println(&quot;Job的name属性值和group属性值分别为：&quot;+key.getName()+&quot;:&quot;+key.getGroup()); TriggerKey trKey = context.getTrigger().getKey(); System.out.println(&quot;Trigger的name属性值和group属性值分别为：&quot;+trKey.getName()+&quot;:&quot;+trKey.getGroup()); System.out.println(&quot;Msg：&quot;+message); System.out.println(&quot;doubleJobValue：&quot;+doubleJobValue); System.out.println(&quot;doubleTrigglerValue：&quot;+doubleTrigglerValue); } } 结果为 Job的name属性值和group属性值分别为：myJob:ground1 Trigger的name属性值和group属性值分别为：myTrigger:group1 Msg：Hello trigger doubleJobValue：66.6 doubleTrigglerValue：88.8 未完，待续","categories":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/categories/Quartz/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"https://caochenhins.github.io/tags/Quartz/"}]},{"title":"JavaEE日常工作经验总结系列（一）-----Java8优雅去重","slug":"JavaEE日常工作经验总结系列（一）-----Java8优雅去重","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:08:08.838Z","comments":true,"path":"2019/03/22/JavaEE日常工作经验总结系列（一）-----Java8优雅去重/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE日常工作经验总结系列（一）-----Java8优雅去重/","excerpt":"字符串集合去重 1List&lt;String&gt; distinctElements = list.stream().distinct().collect(Collectors.toList());","text":"字符串集合去重 1List&lt;String&gt; distinctElements = list.stream().distinct().collect(Collectors.toList()); 根据对象属性去重 1234567public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, Object&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; map = new ConcurrentHashMap&lt;&gt;(); return t -&gt; map.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null; &#125;//使用举例persons.stream().filter(distinctByKey(Person::getName))","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"前端基础知识学习---MybatisPus核心知识学习总结","slug":"前端基础知识学习---MybatisPus核心知识学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:02:48.111Z","comments":true,"path":"2019/03/22/前端基础知识学习---MybatisPus核心知识学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/前端基础知识学习---MybatisPus核心知识学习总结/","excerpt":"一、MybatisPlus简介1.1.简介Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2.文档地址官网文档地址 1.3.MybatisPlus的特性 无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性 依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 预防Sql注入：内置 Sql 注入剥离器，有效预防Sql注入攻击 通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题 支持热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动 支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作 支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（P.S. 比 Mybatis 官方的 Generator 更加强大！） 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 支持关键词自动转义：支持数据库关键词（order、key……）自动转义，还可自定义关键词 内置分页插件：基于 Mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作","text":"一、MybatisPlus简介1.1.简介Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2.文档地址官网文档地址 1.3.MybatisPlus的特性 无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性 依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 预防Sql注入：内置 Sql 注入剥离器，有效预防Sql注入攻击 通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题 支持热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动 支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作 支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（P.S. 比 Mybatis 官方的 Generator 更加强大！） 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 支持关键词自动转义：支持数据库关键词（order、key……）自动转义，还可自定义关键词 内置分页插件：基于 Mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作 二、集成MybatisPlus 集成使用Mybatis，哎西吧，那就这样吧，明天要加班，今天加班完了，明天早起学习吧，这一周开始学习吧 mac上写吧 三、入门的Hello World四、条件查询五、活动记录六、代码生成器七、插件扩展八、自定义全局操作九、公共字段填充","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"前端基础知识学习---CSS3学习总结","slug":"前端基础知识学习---CSS3学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:02:16.427Z","comments":true,"path":"2019/03/22/前端基础知识学习---CSS3学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/前端基础知识学习---CSS3学习总结/","excerpt":"CSS3学习笔记前言 css的全称是什么？——casccading style sheets 样式表的组成？——选择器+声明块 浏览器杜宇编译css的顺序？——div ul li #test从右往左","text":"CSS3学习笔记前言 css的全称是什么？——casccading style sheets 样式表的组成？——选择器+声明块 浏览器杜宇编译css的顺序？——div ul li #test从右往左 选择器 基本选择器 通配符选择器——* {margin:0;} 元素选择器——body {background: #eee} 类选择器——.list {list-style: square} ID选择器——#list {width: 500ox} 后代选择器——.list li {margin-top: 10px} 子元素选择器也可以叫后代直接选择器，此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素 1#wrap &gt; .inner &#123;color: pink;&#125; Html实例 123456789&lt;div id=\"wrap\"&gt; &lt;div&gt;1 &lt;div&gt;1-1&lt;/div&gt; &lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/div&gt; CSS实例 1234#wrap &gt; div&#123; color: brown; border: 5px solid;&#125; 注意：选择的是#wrap下的所有直接后代div,但是color是可继承的，所以1-1颜色也会改变，border却不会。 相邻兄弟选择器它只会匹配紧跟着的兄弟元素 1#wrap &gt; #first + .inner&#123;color: #A52A2A;&#125; Html实例 1234567&lt;div id=&quot;wrap&quot;&gt;&lt;div class=&quot;inner&quot;&gt;1&lt;/div&gt;&lt;div id=&quot;first&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;5&lt;/div&gt;&lt;/div&gt; 注意：改变的只是3号div，如果3号之前存在一个&lt;div&gt;&lt;/div&gt;,那么将不会改变 通用兄弟选择器它会匹配所有的兄弟元素（不需要紧跟） 1#wrap #first ~div&#123;border: 1px solid cornflowerblue;&#125; 注意：HTML结构和相邻兄弟选择器一样，改变的是3,4,5号div 属性选择器存在和值属性选择器html结构 12345&lt;div id=\"wrap\"&gt; &lt;div name=\"zhangsan\"&gt;1&lt;/div&gt; &lt;div name=\"li luo\"&gt;2&lt;/div&gt; &lt;div name=\"li\"&gt;3&lt;/div&gt;&lt;/div&gt; [attr]：该选择器选择包含attr属性的所有元素，无论attr的值是什么 1div[name]&#123;border: 1px solid blueviolet;&#125; /*选中的是所有div*/ [attr = val]：该选择器仅选择attr属性被赋值val的所有元素 1div[name = \"li\"]&#123;border: 1px solid coral;&#125; /*选中的是2,3号div*/ [attr ~= val]：表示带有以attr命名的属性的元素，并且该属性是以一个空格作为分割的值列表，其中至少一个为val 1div[name ~= \"luo\"]&#123;border: 1px solid coral;&#125; /*选中的是2号div*/ 子串值属性选择器html结构 123456&lt;div id=\"wrap\"&gt; &lt;div name=\"luo-zhangsan\"&gt;1&lt;/div&gt; &lt;div name=\"li luo\"&gt;2&lt;/div&gt; &lt;div name=\"luo-li\"&gt;3&lt;/div&gt; &lt;div name=\"luoliluo\"&gt;4&lt;/div&gt;&lt;/div&gt; [attr |= val]：选择的是attr属性的值是val（包括val）或者以val-开头的元素 1div[name |= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,3号元素*/ [attr ^= val]：选择的是attr属性的值以val开头（包括val）的元素 1div[name ^= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,4号元素*/ [attr $= val]：选择的是attr属性的值以val结尾（包括val）的元素 1div[name $= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有2,4号元素*/ [attr *= val]：选择的是attr属性的值中包含字符串val的元素 1div[name *= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,2,3,4号元素*/ 伪类与伪元素选择器链接伪类:link：表示作为超链接，并指向一个为访问的地址的所有锚 :visited：表示作为超链接，并指向一个已访问的地址的所有锚 123a&#123;text-decoration: none;&#125;a:link&#123;color: deeppink;&#125;#test :link&#123;background: pink;&#125; :target：代表一个特殊元素，它的id是URL的片段标识符 :target实例-选项卡,html结构如下 1234567891011121314&lt;body&gt; &lt;a href=\"#div1\"&gt;div1&lt;/a&gt; &lt;a href=\"#div2\"&gt;div2&lt;/a&gt; &lt;a href=\"#div3\"&gt;div3&lt;/a&gt; &lt;div id=\"div1\"&gt; div1 &lt;/div&gt; &lt;div id=\"div2\"&gt; div2 &lt;/div&gt; &lt;div id=\"div3\"&gt; div3 &lt;/div&gt;&lt;/body&gt; css结构如下 12345678910111213141516171819*&#123; margin: 0; padding: 0;&#125;a&#123; text-decoration: none; color: deeppink;&#125;div&#123; width: 200px; height: 200px; background: pink; display: none; text-align: center; font: 50px/200px \"微软雅黑\";&#125;:target&#123; display: block;&#125; 注意：:link，:visited，:target是作用与链接元素的 动态伪类:hover：表示悬浮到元素上 :active：表示匹配被用户激活的元素（点击按住） 由于a标签的：link和：visited可以覆盖了所有的a标签的状态，所以当：link,:visited,:hover,:active同时出现在a标签身上时，：link和：visited不能放在最后 注意：:hover和:active基本可以作用于所有的元素 表单相关伪类:enabled：匹配可编辑的表单:disable：匹配被禁用的表单:checked：匹配被选中的表单:focus ：匹配获焦的表单 实例如下 12345678910111213input:enabled&#123; background: deeppink;&#125;input:disabled&#123; background: blue;&#125;input:checked&#123; width: 200px; height: 200px;&#125;input:focus&#123; background: darkcyan;&#125; html结构如下 123&lt;input type=\"text\" /&gt;&lt;input type=\"text\" disabled=\"disabled\" /&gt;&lt;input type=\"checkbox\" /&gt; 小例子-自定义单选按钮 123456789101112&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt; css代码如下 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;label&#123; position: relative; float: left; width: 100px; height: 100px; border: 2px solid; overflow: hidden; border-radius: 50%;&#125;label &gt; span&#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0;&#125;input&#123; position: absolute; left: -50px; top: -50px;&#125;input:checked + span&#123; background: pink;&#125; 结构性伪类选择器:nth-child(index)系列 :first-child :last-child nth-last-child(index):表示从后面开始计数 only-child(相当于:first-child:last-child或者:noth-child(1):nth-last-child(1)) :nth-child(index)实例 1234/*找到#warp底下的所有li子元素,并且选中第一个子元素，并且这个子元素必须是li*/#wrap li:nth-child(1)&#123; color: deeppink;&#125; 注意：1.index的值从1开始计数；2.index可以为变量n(只能是n)；3.index可以为even或者odd :nth-of-type系列 :first-of-type last-of-type nth-last-type(index):表示从后面开始计数 only-of-type 123#wrap li:nth-of-type(1)&#123; color: deeppink;&#125; 注意：nth-child(index)和nth-of-type(index)的区别：前者找某某下的第一个适配元素，后者找某某下的出现第一次的适配元素。 nth-child和nth-of-type的区别（坑） html结构如下 1234567&lt;div id=\"warp\"&gt; &lt;div class=\"inner\"&gt;div&lt;/div&gt; &lt;span class=\"inner\"&gt;span&lt;/span&gt; &lt;p class=\"inner\"&gt;p&lt;/p&gt; &lt;h1 class=\"inner\"&gt;h1&lt;/h1&gt; &lt;h2 class=\"inner\"&gt;h2&lt;/h2&gt;&lt;/div&gt; 使用nth-child如下，这个没什么问题，选中的是#warp下的class为.inner的第一个元素div 123#warp .inner:nth-child(1)&#123; color: deeppink;&#125; 使用nth-of-type如下，选中的却是所有元素，这是因为nth-of-type是以元素为中心 123#warp .inner:nth-of-type(1)&#123; color: deeppink;&#125; not 123div &gt; a:not(:last-of-type)&#123; border-right: 1px solid red;&#125; enpty(内容必须是空的，有空格都不行) 伪元素选择器伪元素包含这几种，::after，::before，::firstLetter，::firstLine，::selection ::after实例如下 1234567#warp::after&#123; content: \"\"; display: block; width: 200px; height: 200px; background: deeppink;&#125; ::firstLetter实例如下:将第一个字改变 1&lt;div&gt;我是谁？&lt;/div&gt; 12345div::first-letter&#123; color: deeppink; font-size: 24px; font-weight: bold;&#125; ::firstLine实例如下：将第一行改变 1234&lt;div&gt; 我是谁？&lt;br&gt; 我来自哪里？&lt;br&gt;&lt;/div&gt; 12345div::first-line&#123; color: deeppink; font-size: 24px; font-weight: bold;&#125; ::selection实例如下：改变鼠标选中时的状态 1&lt;div&gt;我是谁？我来自哪里？&lt;/div&gt; 1234div::selection&#123; color: deeppink; background: white;&#125; 自定义字体实例如下 1234@font-face &#123; font-family:; src: url();&#125; 新增UI方案文本新增样式opacity：改变透明度123456789101112#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: pink; opacity: 0.1;&#125;#inner&#123; width: 100px; height: 100px; background: deeppink;&#125; 12345&lt;div id=\"warp\"&gt; &lt;div id=\"inner\"&gt; inner &lt;/div&gt;&lt;/div&gt; 新增颜色模式rgba123456#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: rgba(0,0,0,.8);&#125; 说明：rgba其实就是rgb颜色加一个透明度 实例，背景透明，文字不透明12345678910#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: rgba(0,0,0,0.8); color: #FFFFFF; font-size: 30px; line-height: 300px; text-align: center;&#125; 如果是文字透明，背景不透明，将color换成rgba,background使用#形式的颜色模式 文字阴影text-shadow用来为文字添加阴影，而且可以添加多层，阴影之间用逗号隔开（多个阴影时，第一个在最上面） 12345h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; text-shadow: gray 10px 10px 10px;&#125; 实例-浮雕文字123456h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; color: white; text-shadow: black 1px 1px 10px;&#125; 实例-文字模糊效果12345678910h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; color: black; transition: 1s;&#125;h1:hover&#123; color: rgba(0,0,0,0); text-shadow: black 0 0 100px;&#125; 实例-模糊背景12345678910111213141516171819#warp&#123; height: 100px; background: rgba(0,0,0,.5); position: relative;&#125;#warp #bg&#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0; background: url(img/2_1.jpg) no-repeat; background-size: 100% 100%; z-index: -1; filter: blur(10px);/*元素模糊*/&#125;img&#123; margin: 24px 0 0 24px;&#125; 1234&lt;div id=\"warp\"&gt; &lt;img src=\"img/2_1.jpg\" width=\"64\" height=\"64\" /&gt; &lt;div id=\"bg\"&gt;&lt;/div&gt;&lt;/div&gt; 文字描边123456h1&#123; font: 100px/200px \"微软雅黑\"; text-align: center; color: white; -webkit-text-stroke: pink 4px;&#125; 文字排版实例，省略过长内容显示为… 123456789div&#123; width: 200px; height: 100px; border: 1px solid; margin: 0 auto; white-space: nowrap;/*不换行*/ overflow: hidden;/*省略溢出内容*/ text-overflow: ellipsis;&#125; 注意：这个的使用的前提是：不能让元素的大小靠内容撑大，也就是不能使用display: inline;属性 盒模型新增样式盒模型阴影1box-shadow: inset 10px 10px 10px 0px black ; 说明：box-shadow较text-shadow多了两个参数，第一个是阴影方向，第五个是阴影大小 1234567891011121314151617#warp&#123; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; width: 100px; height: 100px; background: pink;/*以上所有样式就是让盒子水平和垂直居中*/ text-align: center; line-height: 100px; transition: 1s;&#125;#warp:hover&#123; box-shadow: 10px 10px 10px 0px black ;&#125; 倒影-webkit-box-reflect1234img&#123; vertical-align: middle; -webkit-box-reflect: right;&#125; resize:允许你控制一个元素的可调整性，需要overflow：auto配合使用 12345678#warp&#123; display: inline-block; width: 200px; height: 200px; background: pink; resize: both; overflow: auto;&#125; box-sizingbox-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素， 123456789#warp &gt; div&#123; margin: 10px; width:130px ; height: 130px; background: deeppink; float: left; border: 1px solid; box-sizing: border-box;&#125; 在上面的css代码中使用 float: left;如果要使用 border: 1px solid;就必须添加box-sizing: border-box;才不会改变布局 新增UI样式圆角12345678910111213#warp&#123; position: absolute; height: 70px; width: 200px; border: 1px solid; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ border-radius: 30px;&#125; border-radius: 30px;这种是简写方式，border-radius: 30px 20px 10px 40px; 是分别对应四角的写法 注意：圆角最好使用px值，不要使用百分比 圆角实例-旋转的风车1234567891011121314151617181920212223242526272829303132333435363738*&#123; margin: 0; padding: 0;&#125;html,body&#123; height: 100%; overflow: hidden;/*这两个是禁止滚动条*/&#125;#warp&#123; position: absolute; height: 300px; width: 300px; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ transition: 2s;&#125;#warp &gt; div&#123; margin: 10px; width:130px ; height: 130px; background: deeppink; float: left; border: 1px solid; box-sizing: border-box;&#125;#warp &gt; div:nth-child(1),#warp &gt; div:nth-child(4)&#123; border-radius: 0 60%;&#125;#warp &gt; div:nth-child(2),#warp &gt; div:nth-child(3)&#123; border-radius: 60% 0;&#125;#warp:hover&#123; transform: rotate(120deg);/*旋转函数*/&#125; 123456&lt;div id=\"warp\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 边框图片1234567891011121314151617#warp&#123; position: absolute; height: 200px; width: 200px; border: 1px solid; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ border: 50px solid; border-image-source: url(img/border-image.png); border-image-slice: 33.3333%; border-image-repeat: round; border-image-width: 20px;&#125; 1&lt;div id=\"warp\"&gt;&lt;/div&gt; 线性渐变双颜色值的线性渐变 1background-image:linear-gradient(red,blue); 多颜色值的线性渐变 1background-image:linear-gradient(red,blue,pink,black); 改变渐变方向 1background-image:linear-gradient(to top left,red,blue); 使用角度 1background-image:linear-gradient(0deg,red,blue); 控制颜色节点的分布 1background-image:linear-gradient(90deg,red 10%,orange 15%,yellow 20%,green 30%,blue 50%,indigo 70%,violet 80%); 透明度的渐变 1background-image:linear-gradient(90deg,rgba(255,0,0,0) 50%,rgba(255,0,0,0.5),rgba(255,0,0,1) 60%); 重复渐变 1background: repeating-linear-gradient(90deg,red 10%,blue 30%); 渐变实例-发廊灯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; overflow: hidden; &#125; #warp&#123; height: 300px; width: 40px; border: 1px solid; margin: 100px auto; overflow: hidden; &#125; #warp &gt; .inner&#123; height: 600px;/*这是是颜色所在的高度。远比能看见的要高*/ background: repeating-linear-gradient(135deg,black 0px,black 10px,white 10px,white 20px); &#125; #warp:hover .inner&#123; margin-top: -300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"warp\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var inner = document.querySelector(\"#warp &gt; .inner\");/*获取元素*/ var flag = 0;/*循环结束后归零*/ setInterval(function()&#123; flag++; if(flag == 300)&#123; flag = 0; &#125; inner.style.marginTop = -flag+\"px\"; &#125;,1000/60)/*设置定时器循环*/ &lt;/script&gt;&lt;/html&gt; 渐变实例-光斑动画1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; overflow: hidden; background: black; text-align: center;/*配合h1的display: inline-block;属性让h1这个元素居中*/ &#125; h1&#123; display: inline-block; color: rgba(255,255,255,.3); font: bold 80px \"微软雅黑\"; background: linear-gradient(120deg,rgba(255,255,255,0) 100px,rgba(255,255,255,1) 180px,rgba(255,255,255,0) 260px); background-repeat: no-repeat; -webkit-background-clip: text; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;码酱博客-专注与总结分享&lt;/h1&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var h1 = document.querySelector(\"h1\");/*获取元素*/ var flag = -160;/*循环结束后归零*/ setInterval(function()&#123; flag+=10; if(flag == 900)&#123; flag = -160; &#125; h1.style.backgroundPosition = flag+\"px\"; &#125;,30)/*设置定时器循环*/ &lt;/script&gt;&lt;/html&gt; 径向渐变双颜色值的径向渐变 1background-image:radial-gradient(red,blue); 多颜色值的径向渐变 1background-image: radial-gradient(red,blue,pink,black); 不均匀分布 1background-image:radial-gradient(red 50%,blue 70%); 改变渐变形状 1background-image:radial-gradient(ellipse,red,blue); 渐变形状的尺寸大小 1background-image:radial-gradient(farthest-corner ellipse,red,blue); 改变圆心 1background-image:radial-gradient(closest-corner circle at 10px 10px,red,blue); 重复渐变 1background-image:repeating-radial-gradient(closest-corner circle,red 30%,blue 50%); 过渡transition CSS transition 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义 transition是一个简写属性，用于 transition-property,transition-duration,transition-timing-function, 和transition-delay。 注意：在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay transition分为一下属性：transition-property，transition-duration，transition-timing-function，transition-delay transition-property指定应用过渡属性的名称，默认值为 all，表示所有可被动画的属性都表现出过渡动,可以指定多个 property 注意：不是所有的属性都可以添加动画过渡的，过渡时间必须带单位s秒 那些属性可以添加动画过渡，参看这个连接 默认值： none： 没有过渡动画。 all ：所有可被动画的属性都表现出过渡动画。 transition-duration属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s (一定要带单位)，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 默认值： 属性值： 以毫秒或秒为单位的数值&lt;time&gt; 类型。表示过渡属性从旧的值转变到新的值所需要的时间。 如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。一定要加单位(不能写0 一定要写0s 1s,0s,1s)！ transition-timing-functionCSS属性受到 transition的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变 属性值： ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier： 贝塞尔曲线 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(&lt;integer&gt;,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） transition-delay规定了在过渡效果开始作用之前需要等待的时间。默认值：0s; 你可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始 当属性值的列表长度不一致时1234transition-property: background,width,height;transition-duration: 3s,2s;transition-delay:3s,2s;transition-timing-function:linear; 实际效果如下 1234transition-property: background,width,height;transition-duration: 3s,2s,3s;transition-delay:3s,2s,3s;transition-timing-function:linear,ease,ease; 说明： 1.超出的情况下是会被全部截掉的2.不够的时候，关于时间的会重复列表，transition-timing-function的时候使用的是默认值ease 2D变换（变形）transformtransform 属性允许你修改CSS视觉格式模型的坐标空间，transform 属性 , 只对 block 级元素生效！ 旋转（rotate） 平移（translate） 倾斜（skew） 缩放（scale） 基点的变换 矩阵（matrix） 旋转 平移 倾斜 缩放 旋转（rotate）1transform:rotate(angle); 正值:顺时针旋转 rotate(360deg), 负值:逆时针旋转 rotate(-360deg) 只能设单值。正数表示顺时针旋转，负数表示逆时针旋转 平移（translate）X方向平移:transform: translateX(tx)，Y方向平移:transform: translateY(ty)二维平移：transform: translate(tx, ty)； 如果ty没有指定，它的值默认为0。 说明：可设单值，可设双值，正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变， 12transform: translate(100px,200px);// 斜着移动transform: translate(100px,0); 倾斜（skew）X方向倾斜:transform: skewX(angle) 1transform: skewX(45deg) // 参数值以deg为单位 代表与y轴之间的角度 Y方向倾斜:transform: skewY(angle) 1transform: skewY(45deg) // 参数值以deg为单位 代表与x轴之间的角度 二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜 1transform:skew(45deg,15deg);// 第一个参数代表与y轴之间的角度, 第二个参数代表与x轴之间的角度 缩放（scale）X方向缩放:transform: scaleX(sx); 1transform: scaleX(2); Y方向缩放:transform: scaleY(sy); 1transform: scaleY(.5); 二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 1transform: scale(2,.5); 要缩小请设0.01～0.99之间的值，要放大请设超过1的值。单值时表示只X轴,Y轴上缩放粒度一样，如transform: scale(2);等价于transform: scale(2,2); 注意：以上的变换都是基于中心原点变换，改变基点，使用transform-origin: 100% 100%;属性 基点变换transform-origintransform-origin CSS属性让你更改一个元素变形的基点。 矩阵（matrix）在 2D变换 中，矩阵变换函数 matrix() 接受 6个值，语法形式如下：transform: matrix(a, b, c, d, e, f); 对某一元素应用旋转变换 rotate(θ)，使用矩阵实现 matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0) 对某一元素应用旋转变换 translate(X, Y)，使用矩阵实现： matrix(1, 0, 0, 1, X, Y) 对某一元素应用倾斜变换 skew(α, β)，使用矩阵变换函数 matrix(1, tanβ, tanα,1, 0, 0)。 对某一元素应用缩放变换 scale(scaleX, scaleY)，使用矩阵变换函数 matrix(scaleX, 0, 0, scaleY, 0, 0) 3D变形在浏览器中，X轴是从左到右，Y轴是从上到下，Z轴是从里到外 3D缩放transform: scale3d(scaleX,scaleY,scaleZ);或者transform: scaleZ(number) 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 3D旋转CSS3中的3D旋转主要包括四个功能函数：rotateX(angle)、 rotateY(angle)、rotateZ(angle)、rotate3d(x,y,z,angle) x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值 3D平移transform: translateZ(length)是3D Transformaton特有的，其他两个2D中就有 translateZ 它不能是百分比值; 那样的移动是没有意义的。 transform: translate3d(translateX,translateY,translateZ); translateZ 它不能是百分比值; 那样的移动是没有意义的。 景深（perspective）动画（Animation）css3动画就是使元素从一种样式逐渐变化为另一种样式的效果，animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 关键帧（@keyframes）语法如下： 12345 @keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125; animiationName:必写项，定义动画的名称, keyframes-selector：必写项，动画持续时间的百分比， from：0%to：100%， css-style：css声明 示例如下： 1234567891011#wran&#123; animation-name :move&#125;@keyframes move&#123; from&#123; transform:rotate(0deg); &#125; to&#123; transform:rotate(360deg); &#125;&#125; animation-nameanimation-name属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 animation-durationanimation-duration属性指定一个动画周期的时长。默认值为0s，表示无动画。一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 注意：负值无效，浏览器会忽略该声明，但是一些早起的带前缀的声明会将负值当作0s animation-timing-functionanimation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始，到关键帧结束。动画的默认效果：由慢变快再变慢 linear:线性过渡，等同于贝塞尔曲线（0,0,1,1） ease:平滑过渡，等同于贝塞尔曲线（0.25,0.1,0.25,1.0） ease-in:由慢到快，等同于贝塞尔曲线（0.42,0,1,1） ease-out:由快到慢，等同于贝塞尔曲线（0,0,0.58,1） ease-in-out:由慢到快再到慢，等同于贝塞尔曲线（0.42,0,0.58,1） cubic-bezier(1,1,2,3) steps(n,[start|end]) 传入一到两个参数，第一个参数意思是把动画分成 n 等分，然后动画就会平均地运行。 第二个参数 start 表示从动画的开头开始运行，相反，end 就表示从动画的结尾开始运行， 默认值为 end。 animation-delay定义动画开始前等待的时间,以秒或毫秒计(属于动画外的范畴),值为time, 从动画样式应用到元素上到元素开始执行动画的时间差。该值可用单位为秒(s)和毫秒(ms)。如果未设置单位，定义无效 animation-iteration-count定义了动画执行的次数（属于动画内的范畴）,值为infinite表示 无限循环播放动画.&lt;number&gt;表示动画播放的次数 不可为负值. animation-direction定义了动画执行的方向 normal： 每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，默认属性。 alternate：动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向， 比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭 代 reverse：反向运行动画，每周期结束动画由尾到头运行。 alternate-reverse：反向交替， 反向开始交替 animation-fill-mode属于动画外的范畴，定义动画在动画外的状态 animation-play-state定义了动画执行的运行和暂停， running表示当前动画正在运行。paused表示当前动画以被停止。 布局扩展老版本布局CSS3 弹性盒子(Flexible Box 或 Flexbox)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行/列。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。 老版本的我们通常称之为box， 新版本的我们通常称之为flex 注意：项目永远在主轴的正方向排列 老版容器的布局方向 -webkit-box-orient: horizontal; x轴 -webkit-box-orient: vertical; y轴 123display: -webkit-box;/*-webkit-box-orient属性控制的主轴是那个*/-webkit-box-orient: vertical; 注意：项目永远在主轴的正方向排列 老版容器的排列方向 -webkit-box-direction: normal; -webkit-box-direction: reverse; -webkit-box-direction属性本质上改变了主轴的方向 1234display: -webkit-box;-webkit-box-orient: vertical;/*-webkit-box-direction控制主轴的方向*/-webkit-box-direction: reverse; 老版本富裕空间管理（主轴上）1-webkit-box-pack:start; 不会给项目区分配空间，只是确定富裕空间的位置 start：表示富裕空间在右边 end：表示富裕空间在左边 center：表示富裕空间在两边 justify：表示富裕空间在项目之间 老版本富裕空间管理（侧轴上）1-webkit-box-align:center; /*不会给项目区分配空间，只是确定富裕空间的位置*/ start：侧轴为x轴，富裕空间位于右边，侧轴为y轴，富裕空间位于下边 end：侧轴为x轴，富裕空间位于左边，侧轴为y轴，富裕空间位于上边 center ：富裕空间位于两边 新版本flex布局新版本的布局方向 flex-direction: row; flex-direction: column; 123display: flex;/*flex-direction决定主轴方向*/flex-direction: row; 新版本的排列方向 flex-direction:row-reverse; flex-direction:column-reverse; 123display: flex;/*flex-direction既控制主轴是那个，也控制主轴方向*/flex-direction: row-reverse 新版本富裕空间管理（主轴上）1justify-content: flex-start; /*更强大的富裕空间的管理（主轴）*/ flex-start：富裕空间在主轴的正方向 flex-end：富裕空间在主轴的反方向 center：富裕空间在主轴的两边 space-between：富裕空间在项目之间 space-around(box 没有的)：富裕空间在项目两边 新版本富裕空间管理（侧轴上）1align-items: stretch; flex-start：富裕空间在侧轴的正方向 flex-end：富裕空间在侧轴的反方向 center：富裕空间在侧轴的两边 baseline(box 没有的)：按照基线对齐 stretch(box 没有的)：等高布局 有关布局的HTML结构如下 1234567&lt;div id=\"warp\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;div class=\"item\"&gt;5&lt;/div&gt;&lt;/div&gt; 说明：id=”warp”为容器，&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;为项目 flex布局总结 明确什么是容器，什么是项目，什么是主轴，什么是侧轴 项目永远排列在主轴上 flex布局分为两个版本：-webkit-box-和flex 老版本容器 容器的布局方向：-webkit-box-orient:horizontal/vertical,控制主轴是哪一根， horizontal：x轴，vertical ：y轴 容器的排列方向：-webkit-box-direction：normal/reverse控制主轴的方向， normal：从左往右（正方向）reverse：从右往左（反方向） 富裕空间的管理：只决定富裕空间的位置，不会给项目区分配空间 主轴：-webkit-box-pack 主轴是x轴 start：在右边 end: 在左边 center：在两边 justify：在项目之间 主轴是y轴 start：在下边 end：在上边 center：在两边 justify：在项目之间 侧轴：-webkit-box-algin 侧轴是x轴 start：在右边 end： 在左边 center：在两边 侧轴是y轴 start：在下边 end： 在上边 center：在两边 项目 弹性空间管理：-webkit-box-flex：弹性因子（默认值为0） 新版本容器容器的布局方向和容器的排列方向使用一个属性flex-direction,控制主轴是哪一根，控制主轴的方向 row; 从左往右的x轴 row-reverse;从右往左的x轴 column; 从上往下的y轴 column-reverse;从下往上的y轴 富裕空间的管理：只决定富裕空间的位置，不会给项目区分配空间 主轴justify-content flex-start： 在主轴的正方向 flex-end: 在主轴的反方向 center： 在两边 space-between： 在项目之间 space-around： 在项目两边 侧轴align-items flex-start：在侧轴的正方向 flex-end： 在侧轴的反方向 center： 在两边 baseline 基线对齐 stretch 等高布局（项目没有高度） 新版flex布局详解容器 flex-wrap：控制的是侧轴的方向 123align-items: flex-start;/*对单行单列的富裕空间管理*/flex-wrap: wrap-reverse;/*当容器的宽度小于项目的宽度时控制是否换行显示，也就是控制侧轴的方向*/align-content: flex-start;/*对多行多列富裕空间的管理*/ align-content 属性定义弹性容器的侧轴方向上有额外空间时，如何排布每一行/列。当弹性容器只有一行/列时无作用 align-content值如下： flex-start：所有行/列从侧轴起点开始填充。第一行/列的侧轴起点边和容器的侧轴起点边对齐。 接下来的每一行/列紧跟前一行/列。 flex-end：所有弹性元素从侧轴末尾开始填充。最后一个弹性元素的侧轴终点和容器的侧轴终点对齐。同时所有后续元素与前一个对齐。 center：所有行/列朝向容器的中心填充。每行/列互相紧挨，相对于容器居中对齐。 容器的侧轴起点边和第一行/列的距离相等于容器的侧轴终点边和最后一行/列的距离。 space-between：所有行/列在容器中平均分布。相邻两行/列间距相等。 容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的边对齐。 space-around：所有行/列在容器中平均分布，相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的距离是相邻两行/列间距的一半。 stretch：拉伸所有行/列来填满剩余空间。剩余空间平均的分配给每一行/列 flex-flow 属性 flex-flow 属性是设置“flex-direction”和“flex-wrap”的简写,默认值：row nowrap 不可继承 控制主轴和侧轴的位置以及方向 项目order 属性 order 属性规定了弹性容器中的可伸缩项目在布局时的顺序。元素按照 order 属性的值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局,order越大越后 123456#warp &gt; .item:nth-child(1)&#123; order: 5;&#125;#warp &gt; .item:nth-child(2)&#123; order: 3;&#125; align-self 属性 align-self 会对齐当前 flex 行中的 flex 元素，并覆盖 align-items 的值. 如果任何 flex 元素的侧轴方向 margin 值设置为 auto，则会忽略 align-self。 auto：设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch。 flex-start：flex 元素会对齐到 cross-axis 的首端。 flex-end：flex 元素会对齐到 cross-axis 的尾端。 center： flex 元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出。 baseline：所有的 flex 元素会沿着基线对齐， stretch：flex 元素将会基于容器的宽和高，按照自身 margin box 的 cross-size 拉伸 12345678#warp &gt; .item:nth-child(2)&#123; order: 3; align-self: flex-end;&#125;#warp &gt; .item:nth-child(3)&#123; order: 2; align-self: center;&#125; flex-shrink属性 flex-grow 属性定义弹性盒子项（flex item）的拉伸因子。 可用空间 = (容器大小 - 所有相邻项目flex-basis的总和) 可扩展空间 = (可用空间/所有相邻项目flex-grow的总和) 每项伸缩大小 = (伸缩基准值 + (可扩展空间 x flex-grow值)) flex-shrink 属性指定了 flex 元素的收缩因子 默认值为1 计算收缩因子与基准值乘的总和 计算收缩因数： 收缩因数=（项目的收缩因子*项目基准值）/第一步计算总和 移除空间的计算：移除空间= 项目收缩因数 x 负溢出的空间 flex-basis属性 flex-basis 指定了 flex 元素在主轴方向上的初始大小，默认值 ：auto 不可继承 注意： 在flex简写属性中 flex-basis的默认值为0 flex实例等分布局 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; #warp&#123; width:500px; height: 300px; border: 1px solid; margin: 100px auto; display: flex; &#125; #warp &gt; .item&#123; height: 50px; background: pink; text-align: center; line-height: 50px; flex-shrink: 1; flex-grow: 1;/*将富裕空间等分，并没有将项目等分*/ flex-basis: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"warp\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;22&lt;/div&gt; &lt;div class=\"item\"&gt;333&lt;/div&gt; &lt;div class=\"item\"&gt;4444&lt;/div&gt; &lt;div class=\"item\"&gt;55555&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex简写属性语法糖 12345flex-shrink: 1;flex-grow: 1;/*将富裕空间等分，并没有将项目等分*/flex-basis: 0;/*上述三个属性和下列属性语法一样*/flex: 1; 等分布局实例，天猫导航栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; a&#123; text-decoration: none; color: gray; display: block;/*设置a标签不仅仅是可以点击文字，还可以点击div块*/ &#125; #nav .row&#123; display: flex; &#125; #nav &gt;.row &gt; .item&#123; flex: 1; text-align: center; &#125; #nav &gt; .row &gt; .item &gt; a:before&#123; content: \"\"; display: block; width: 86px; height: 86px; margin: 0 auto; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(1) &gt; a:before&#123; background: url(../img/01.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(2) &gt; a:before&#123; background: url(../img/02.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(3) &gt; a:before&#123; background: url(../img/03.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(4) &gt; a:before&#123; background: url(../img/04.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(5) &gt; a:before&#123; background: url(../img/05.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(1) &gt; a:before&#123; background: url(../img/06.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(2) &gt; a:before&#123; background: url(../img/07.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(3) &gt; a:before&#123; background: url(../img/08.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(4) &gt; a:before&#123; background: url(../img/09.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(5) &gt; a:before&#123; background: url(../img/10.png) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"nav\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;聚划算&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫国际&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;外卖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫超时&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;充值中心&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫旅行&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;领金币&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;拍卖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;分类&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习-----SpringCloud学习总结","slug":"JavaEE进阶知识学习-----SpringCloud学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:02:09.153Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习-----SpringCloud学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习-----SpringCloud学习总结/","excerpt":"SpringCloud概述SpringCloud是什么SpringCloud，基于SpringBoot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，等组件。换句话说是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。","text":"SpringCloud概述SpringCloud是什么SpringCloud，基于SpringBoot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，等组件。换句话说是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。 SpringBoot和SpringCloud SpringBoot专注于快速方便的开发单个个体微服务 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的单体微服务整合并管理，为各个微服务之间提供配置管理，服务发现，路由，分布式会话等集成服务 SpringBoot可以离开SpringCloud独立的开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系 SpringBoot专注于快速，方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架 Double和SpringCloud首先可以在GitHub上看到二者的活跃度，其次是比较各功能组件的支持情况，最大的区别在于SpringCloud抛弃了Dubbo的RPC通信，采用的是HTTP的REST方式，如下： Dobbo SpringCloud 服务注册中心 Zookeeper SpringCloud Netflix Eureka 服务调用方式 RPC Rest API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netflix Hystrix 服务网关 无 Spring Cloud Netflix Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task SpringCloud资料SpringCloud各个组件的文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud中文API：https://springcloud.cc/spring-cloud-dalston.html SpringCloud实践准备项目技术版本SpringCloud版本：Dalston.SR1，SpringBoot版本：1.5.9 项目说明项目是使用SpringCloud将四个工程进行整合，microservicecloud整体父工程Project，microservicecloud-api公共子模块Module，microservicecloud-provider-dept-8001部门微服务提供者Module，microservicecloud-consumer-dept-80部门微服务消费者Module。 1.父类项目创建在逻辑视图中选择new-Maven Project-勾上创建简单项目-选择pom方式 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 2.公共组件项目创建在父项目上创建microservicecloud-api项目，注意是在microservicecloud上new一个maven module，packaging选择jar POM.xml文件12345678910111213141516171819&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Dept实体类123456789101112131415161718192021222324252627282930313233343536public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称、 private String db_source; // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 public Dept() &#123; super(); &#125; public Dept(Long deptno, String dname, String db_source) &#123; super(); this.deptno = deptno; this.dname = dname; this.db_source = db_source; &#125; public Long getDeptno() &#123; return deptno; &#125; public void setDeptno(Long deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getDb_source() &#123; return db_source; &#125; public void setDb_source(String db_source) &#123; this.db_source = db_source; &#125; @Override public String toString() &#123; return \"Dept [deptno=\" + deptno + \", dname=\" + dname + \", db_source=\" + db_source + \"]\"; &#125; 当我们每次都需要创建一个实体类的getter，setter，toString和构造器等方法时，如果增加一个字段就要重新生成方法，为了简化这种重复的操作，我们在前面的pom中引入了lombok，同样的实体类，使用方法如下 1234567891011@SuppressWarnings(\"serial\")@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain=true)public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称 // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 private String db_source; &#125; lombok安装方法拷贝lombok-1.16.18.jar到Eclipse目录下，执行java -jar D:\\javasoft\\eclipse-jee-neon-3-win32-x86_64\\eclipse\\ombok-1.16.18.jar，然后，弹框中选择Eclipse安装目录，选择install即可。 lombok注解使用1234567@Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual@Setter：注解在属性上；为属性提供 setting 方法@Getter：注解在属性上；为属性提供 getting 方法@Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象@NoArgsConstructor：注解在类上；为类提供一个无参的构造方法@AllArgsConstructor：注解在类上；为类提供一个全参的构造方法@Accessors(chain=true)：可以使用链式写法 lombok测试123456789101112131415@SuppressWarnings(\"serial\")@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain=true)public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称、 private String db_source; // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 public static void main(String[] args) &#123; Dept dept = new Dept(); dept.setDeptno(12L).setDname(\"开发部\").setDb_source(\"DB01\"); &#125;&#125; 注意内容实体类必须实现Serializable接口 打包使用公共组件模块写好后可以点击run as 选择maven clean ，然后在选择maven install。其他模块引用的方法如下 123&lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;&lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 3.部门微服务提供者首先现在父类项目上new一个maven module,microservicecloud-provider-dept-8001修改pom.xml文件 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-provider-dept-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678910111213141516171819202122232425262728server: port: 8001 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间 eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka mybatis下mybatis.cfg.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt;&lt;!-- 二级缓存开启 --&gt; &lt;/settings&gt;&lt;/configuration&gt; SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB01 ;CREATE DATABASE cloudDB01 CHARACTER SET UTF8 ;USE cloudDB01 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); dao接口12345678@Mapperpublic interface DeptDao &#123; public boolean addDept(Dept dept); public Dept findById(Long id); public List&lt;Dept&gt; findAll();&#125; DeptMapper.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.luo.springcloud.dao.DeptDao\"&gt; &lt;select id=\"findById\" resultType=\"Dept\" parameterType=\"Long\"&gt; select deptno,dname,db_source from dept where deptno=#&#123;deptno&#125;; &lt;/select&gt; &lt;select id=\"findAll\" resultType=\"Dept\"&gt; select deptno,dname,db_source from dept; &lt;/select&gt; &lt;insert id=\"addDept\" parameterType=\"Dept\"&gt; INSERT INTO dept(dname,db_source) VALUES(#&#123;dname&#125;,DATABASE()); &lt;/insert&gt;&lt;/mapper&gt; DeptService12345public interface DeptService &#123; public boolean add(Dept dept); public Dept get(Long id); public List&lt;Dept&gt; list();&#125; DeptServiceImpl1234567891011121314151617181920@Servicepublic class DeptServiceImpl implements DeptService&#123; @Autowired private DeptDao dao; @Override public boolean add(Dept dept) &#123; return dao.addDept(dept); &#125; @Override public Dept get(Long id) &#123; return dao.findById(id); &#125; @Override public List&lt;Dept&gt; list() &#123; return dao.findAll(); &#125;&#125; DeptController1234567891011121314151617181920@RestControllerpublic class DeptController &#123; @Autowired private DeptService service; @RequestMapping(value=\"/dept/add\",method=RequestMethod.POST) public boolean add(@RequestBody Dept dept)&#123; return service.add(dept); &#125; @RequestMapping(value=\"dept/get/&#123;id&#125;\",method=RequestMethod.GET) public Dept get(@PathVariable(\"id\") Long id)&#123; return service.get(id); &#125; @RequestMapping(value=\"dept/list\",method=RequestMethod.GET) public List&lt;Dept&gt; list()&#123; return service.list(); &#125;&#125; 创建主启动类DeptProvider8001_App123456@SpringBootApplicationpublic class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 测试结果输入http://localhost:8001/dept/list以JSON的方式返回数据 4.部门微服务消费者首先现在父类项目上new一个maven module,microservicecloud-consumer-dept-80修改pom.xml文件 POM.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-80&lt;/artifactId&gt; &lt;description&gt;部门微服务消费者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12server: port: 80 ConfigBean注解类1234567@Configurationpublic class ConfigBean &#123; @Bean public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125;&#125; RestTemplateRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单高效便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具类集，使用方法如下 （url,requestMap,ResponseBean.class）三个参数分别代表Rest请求地址，请求参数，HTTP响应转换被转换的对象类型 DeptController_Consumer123456789101112131415161718192021@RestControllerpublic class DeptController_Consumer &#123; private static final String REST_URL_PREFIX = \"http://localhost:8001\"; @Autowired private RestTemplate restTemplate; @RequestMapping(value=\"/consumer/dept/add\") public boolean add(Dept dept)&#123; return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\", dept, Boolean.class); &#125; @RequestMapping(value=\"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id)&#123; return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/get/\"+id, Dept.class); &#125; @RequestMapping(value=\"/consumer/dept/list\") public Dept list()&#123; return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/list/\", Dept.class); &#125;&#125; DeptConsumer80_App主类123456@SpringBootApplicationpublic class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 测试结果http://localhost/consumer/dept/list http://localhost/consumer/dept/get/2 http://localhost/consumer/dept/add?dname=AI Eureka服务注册与发现Eureka三大角色 Eureka Server提供服务注册和发现 Service Provider服务提供方将自身服务注册到Eureka， 从而使服务消费者能够找到 Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费 1.Eureka Server注册在上述项目的父工程中新建microservicecloud-eureka-7001，这个module是Eureka的服务中心 POM.xml文件123456789101112131415161718192021222324252627&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-eureka-7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-server服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件1234567891011server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ EurekaServer主启动类1234567@SpringBootApplication@EnableEurekaServer// EurekaServer服务器端启动类，接收其它微服务注册进来public class EurekaServer7001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7001_App.class, args); &#125;&#125; 测试EurekaServer浏览器输入http://localhost:7001/，看到Spring Eureka界面表示成功，这个访问链接和程序中的application.yml配置吻合。 2.微服务注册将microservicecloud-provider-dept-8001微服务注册到microservicecloud-eureka-7001中 修改microservicecloud-provider-dept-8001的POM.xml文件123456789&lt;!-- 将微服务provider侧注册进eureka --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 修改microservicecloud-provider-dept-8001的application.yml文件1234eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka 说明：defaultZone的地址对应Eureka Server服务注册中心的application.yml中的defaultZone路径 microservicecloud-provider-dept-8001主程序类使用注解1234567@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心public class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 测试是否注册成功先启动Eureka服务注册中心microservicecloud-eureka-7001，启动微服务microservicecloud-provider-dept-8001，打开浏览器输入http://localhost:7001/，Application下出现**MICROSERVICECLOUD-DEPT**微服务名称，这个名称来源于microservicecloud-provider-dept-8001中application.ym文件中的配置属性，如下 123spring: application: name: microservicecloud-dept 3.微服务常用设置主机名称和服务名称修改在Eureka中注册的微服务的Status的名称显示localhost或者显示电脑主机名，所以要修改服务的主机名称，修改方法如下，修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 12instance: instance-id: microservicecloud-dept8001 访问信息有IP信息提示修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 123instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #访问路径可以显示IP地址 微服务info内容详细信息增加microservicecloud-provider-dept-8001中POM.xml文件 12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 总的父工程microservicecloud修改pom.xml添加构建build信息 12345678910111213141516171819202122&lt;build&gt; &lt;finalName&gt;microservicecloud&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 说明在src/main/resources目录下的配置文件 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;!-- 表示以$开始和以$结束的表示方法 --&gt; &lt;delimit&gt;$&lt;/delimit&gt; &lt;/delimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 12345info: app.name: luokangyuan-microservicecloud company.name: www.luokangyuan.com build.artifactId: $project.artifactId$ build.version: $project.version$ 4.Eureka的自我保护机制导致的原因默认情况下，如果EurekaServer在一定的时间内没有接收到某一个微服务实例的心跳，EurekaServer将会注销该实例，页面就会看见一串红色提示，但是当网络分区发生故障时，微服务与EurekaServer无法进行正常的通信，此时本不应该注销这个微服务实例，这个时候，Eureka的自我保护机制就可以解决这个问题，当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式，一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务），当网络故障恢复后，该EurekaServer节点就会自动退出自我保护模式。 总结在自我保护模式下，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例，当它收到的心跳数重新到阈值以上，该EurekaServer就会自动退出自我保护模式，也就是宁可保留错误的服务注册信息，也不盲目的删除任何可能健康的服务实例。 5.服务发现对于注册近Eureka里面的微服务，可以通过服务发现来获取该服务的信息 修改microservicecloud-provider-dept-8001的DeptController12345678910111213141516@Autowiredprivate DiscoveryClient client;@RequestMapping(value = \"/dept/discovery\", method = RequestMethod.GET)public Object discovery()&#123; List&lt;String&gt; list = client.getServices();//得到Eureka中所有的微服务 System.out.println(\"**********\" + list); List&lt;ServiceInstance&gt; srvList = client.getInstances(\"MICROSERVICECLOUD-DEPT\"); for (ServiceInstance element : srvList) &#123; System.out.println(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); &#125; return this.client;&#125; microservicecloud-provider-dept-8001主启动类添加注解12345678@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心@EnableDiscoveryClient // 服务发现public class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 自测试启动服务注册中心microservicecloud-eureka-7001，再启动microservicecloud-provider-dept-8001，访问http://localhost:8001/dept/discovery可以得到这个服务的info信息，/dept/discovery接口就是microservicecloud-provider-dept-8001这个服务暴露给外部访问的接口。使用http://localhost:8001/dept/discovery测试，就是自己测试能不能使用 外部访服务暴露的接口microservicecloud-consumer-dept-80调用microservicecloud-provider-dept-8001服务暴露在外的接口，修改microservicecloud-consumer-dept-80中的DeptController_Consumer，如下 12345// 测试@EnableDiscoveryClient,消费端可以调用服务发现@RequestMapping(value = \"/consumer/dept/discovery\")public Object discovery()&#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/discovery\", Object.class);&#125; 消费者访问接口测试启动microservicecloud-consumer-dept-80访问http://localhost/consumer/dept/discovery得到8001微服务信息 总结 microservicecloud-provider-dept-8001注册到EurekaServer服务中心 microservicecloud-provider-dept-8001将Controller中的某一个方法暴露出去（提供服务发现） microservicecloud-consumer-dept-80中的Controller就可以调用微服务暴露出来的接口 Eureka集群配置microservicecloud-eureka-7001使EurekaServer服务注册中心，一旦这个出现问题，那么微服务就不能正常的工作，为防止这种情况，所以出现了集群，就是建立多个microservicecloud-eureka-7002，microservicecloud-eureka-7003等服务注册中心。 新建microservicecloud-eureka-7002，microservicecloud-eureka-7003服务注册中心 根据microservicecloud-eureka-7001的pom.xml修改7002和7003的pom.xml文件 复制7001的主程序启动类，并修改为7002,7003即可 修改映射配置在7001注册中的application.yml文件中hostname，不能与7002,7003相同，所以要做映射配置 123eureka: instance: hostname: localhost #eureka服务端的实例名称 修改C:\\Windows\\System32\\drivers\\etc\\host文件,让127.0.0.1有三个别名 123127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com127.0.0.1 eureka7003.com microservicecloud-eureka-7001中的yml修改123456789101112server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ microservicecloud-eureka-7002中的yml修改123456789101112server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ microservicecloud-eureka-7003中的yml修改123456789101112server: port: 7003eureka: instance: hostname: eureka7003.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 修改dept微服务的yml文件dept微服务会同时注册到7001,7002,7003服务注册中心 12345eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 测试 访问eureka7001.com:7001 访问eureka7002.com:7002 访问eureka7003.com:7003 Eureka和Zookeeper区别遵循原则不同Eureka遵循AP原则，Zookeeper遵循CP原则，C：强一致性，A：可用性，P：分区容错性 著名的CAP理论中提出，一个分布式系统不可能同时满足C(一致性)A(可用性)P(分区容错性)，由于分区容错性p是分布式系统中必须保证，因此只能在A和C之间权衡 Zookeeper保证CP在Zookeeper中存在一种情况下，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是，选举leader的时间太长，且选举过程中这个Zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪，在云部署的环境中，因为网络问题使得Zookeeper集群失去master节点的可能性较大，虽然服务最终能够恢复，但是在漫长的选举时间导致的注册时间不可用是不能容忍的，当我们向注册中心查询注册列表时，可以忍受注册中心返回的是几分钟以前的注册信息，但是不能接收服务直接down不可用，也就是说，服务注册对可用性的要求高于一致性。 Eureka保证APEureka知道Zookeeper的不足，所以设计最初就保证可用性，Eureka各个节点都是平等的，几个节点的挂点不会影响其他正常节点的工作，剩余的节点仍然可以提供注册和查询服务，只不过不能保证查询的信息是最新的，除此之外，Eureka还有一种自我保护机制，当过多的节点没有正常的心跳时，那么Eureka就会认为客户端出现了网络故障，此时Eureka会 Eureka不会从注册表中移除因为长时间没有收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点上（保证当前节点可用） 当网络稳定时，当前实例新的注册信息会被同步到其他节点上 Ribbon负载均衡Ribbon概述Spring Cloude Ribbon是基于Netfilx Ribbon实现的一套客户端 负载均衡的工具，简单说，Ribbon是Netfilix发布的开源项目，主要功能就是提供 客户端的软件负载均衡算法，将Netfilix的中间层服务连接在一起，Ribbon客户端组件提供了一系列完善的配置项如连接超时，重试等，简单说，就是在配置文件中列出Load Balance后面的所有机器，Ribbon会自动的帮助你基于某种算法规则（简单轮询，随机连接等）去连接这些机器，也可以使用Ribbon自定义负载均衡算法。LB，即负载均衡，在微服务或者分布式集群中常用的一种应用。负载均衡就是将用户的请求平摊的分配到多个服务上，从而达到HA，常见的负载均衡软件有Nginx，LVS，硬件F5等 Ribbon配置初步由于Ribbon是客户端的负载均衡工具，所以我们需要修改的是客户端项目microservicecloud-consumer-dept-80 POM.xml文件1234567891011121314151617&lt;!-- Ribbon相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml文件，添加Eureka的服务注册地址1234567server: port: 80eureka: client: register-with-eureka: false #自己不能注册 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 修改客户端配置类由于客户端使用restTemplate访问服务端中的数据接口，restTemplate配置在服务端的配置类中，所以修改如下 12345678@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改客户端主程序启动类1234567@SpringBootApplication@EnableEurekaClientpublic class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 修改客户端访问类DeptController_Consumer.java1private static final String REST_URL_PREFIX = \"http://MICROSERVICECLOUD-DEPT\"; 测试启动7001,7002,7003三个服务注册中心，启动8001服务提供者，启动80客户端，使用http://localhost/consumer/dept/list可以渠道对应的数据，在DeptController_Consumer使用的是http://MICROSERVICECLOUD-DEPT服务名称来调用服务的接口，相比之前的http://localhost:8001，Ribbon和Eureka整合后，Consumer可以直接通过服务名称来调用服务，而不再关心地址和端口号。 Ribbon负载均衡 目前只有一个microservicecloud-provider-dept-8001服务提供者，为了实现Ribbon的负载均衡，所以我们需要多个服务提供者实例，新建microservicecloud-provider-dept-8002，microservicecloud-provider-dept-8003两个Module。参考8001的pom.xml文件修改8002,8003的pom.xml文件。拷贝8001中的所以类和配置文件mybatis和application.yml文件，将主启动类修改为对应的名字 microservicecloud-provider-dept-8002服务提供者使用的数据库SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB02 ;CREATE DATABASE cloudDB02 CHARACTER SET UTF8 ;USE cloudDB02 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); Application.yml文件1234567891011121314151617181920212223server: port: 8002 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB02 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 microservicecloud-provider-dept-8003服务提供者使用的数据库SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB03 ;CREATE DATABASE cloudDB03 CHARACTER SET UTF8 ;USE cloudDB03 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); Application.yml文件1234567891011121314151617181920212223server: port: 8003 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB03 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 微服务提供者说明三个微服务提供者连接不同的数据库，因此在application.yml文件中，我们需要修改端口号和连接的数据库，注意的是三个微服务提供者的微服务名字保持一样，也就是如下的配置信息 123spring: application: name: microservicecloud-dept 负载均衡自测访问连接http://localhost:8001/dept/list，http://localhost:8002/dept/list，http://localhost:8003/dept/list得到不同数据库数据，当我们启动服务注册中心7001,7002,7003,再启动80客户端，这个时候访问localhost/consumer/dept/list，每次刷新就会得到不同数据库的数据。这就是Ribbon默认的轮询算法的负载均衡。 Ribbon核心组件IRuleRibbon负载均衡算法Ribbon默认提供的是轮询的负载均衡算法，完整了还有如下 RoundRobinRule 轮询 RandomRule 随机 AvaliabilityFilteringRule 会先过滤由于多次访问故障而处于断路器跳闸的状态的服务和并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略 WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大 RetryRule 先按照RoundRobinRule策略获取服务，如果获取服务失败会在指定时间内重试 BestAvailableRule 会先过滤掉由于多次访问故障二处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 ZoneAvoidanceRule 默认规则，复合判断server所在的区域的性能和server的可用性选择服务器 Ribbon负载均衡算法使用方法在客户端的配置类ConfigBean.java中添加IRule的实现 123456789101112@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public IRule myRule()&#123; return new RandomRule(); &#125;&#125; Ribbon自定义如果不使用Ribbon默认的七种负载均衡算法，这个时候就需要使用自定义负载均衡算法 客户端主启动类使用注解@RibbonClient12345678@SpringBootApplication@EnableEurekaClient@RibbonClient(name=\"MICROSERVICECLOUD-DEPT\",configuration=MySelfRule.class)public class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 特此说明 RibbonClient注解中的MySelfRule类使我们自定义负载均衡算法的类，但是，这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们这个自定义的配置类会被所有的Ribbon客户端所共享，也就说，达不到我们特殊化定制的目的。举例说明，自定义配置类不能放在项目主启动类所有的包以及子包下，因为主启动类使用注解@SpringBootApplication，这个注解点进去使用@ComponentScan注解 自定义负载均衡算法轮询算法中每一个服务轮询一次，现在需求是每一个服务调用五次后在轮询下一个服务 自定义配置类12345678910111213package com.luo.myrule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.netflix.loadbalancer.IRule;@Configurationpublic class MySelfRule &#123; @Bean public IRule myRule()&#123; return new RandomRule_lky(); &#125;&#125; 自定义算法类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.luo.myrule;import java.util.List;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;public class RandomRule_lky extends AbstractLoadBalancerRule&#123; // total = 0 // 当total==5以后，我们指针才能往下走， // index = 0 // 当前对外提供服务的服务器地址， // total需要重新置为零，但是已经达到过一个5次，我们的index = 1 // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？ private int total = 0; // 总共被调用的次数，目前要求每台被调用5次 private int currentIndex = 0; // 当前提供服务的机器号 public Server choose(ILoadBalancer lb, Object key)&#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; return null; &#125;// private int total = 0; // 总共被调用的次数，目前要求每台被调用5次// private int currentIndex = 0; // 当前提供服务的机器号 if(total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125;else &#123; total = 0; currentIndex++; if(currentIndex &gt;= upList.size()) &#123; currentIndex = 0; &#125; &#125; if (server == null) &#123; Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key)&#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig)&#123;&#125;&#125; Feign负载均衡Feign是一个声明式WebService客户端，使用Feign能够让编写Web Service客户端变得更简单，它的使用方法就是定义一个接口，然后在上面添加注解。SpringCloud对Feign进行了封装，支持SpringMVC注解和HTTPMessageConverters，Feign可以与Eureka和Ribbon组合使用以支持负载均衡。简单讲，只需要创建一个接口，然后在上面使用注解即可。 Feign使用步骤参考项目microservicecloud-consumer-dept-80新建microservicecloud-consumer-dept-feign,拷贝相应的包和配置文件，去掉IRule等信息，修改pom.xml文件，添加对Feign的支持 pom.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-feign&lt;/artifactId&gt;&lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 由于Feign是面向接口编程，为方便接口的互相调用，将接口和公共的方向在项目microservicecloud-api中，因此修改为： 修改microservicecloud-api工程的pom.xml文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 新建DeptClientService接口1234567891011@FeignClient(value = \"MICROSERVICECLOUD-DEPT\")public interface DeptClientService &#123; @RequestMapping(value = \"/dept/get/&#123;id&#125;\",method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\",method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 修改microservicecloud-consumer-dept-feign中Controller添加新建的DeptClientService1234567891011121314151617181920@RestControllerpublic class DeptController_Consumer &#123; @Autowired private DeptClientService service; @RequestMapping(value = \"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id)&#123; return this.service.get(id); &#125; @RequestMapping(value = \"/consumer/dept/list\") public List&lt;Dept&gt; list()&#123; return this.service.list(); &#125; @RequestMapping(value = \"/consumer/dept/add\") public Object add(Dept dept)&#123; return this.add(dept); &#125;&#125; 修改microservicecloud-consumer-dept-feign主启动类,添加注解123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients(basePackages = &#123;\"com.luo.springcloud\"&#125;)@ComponentScan(\"com.luo.springcloud\")public class DeptConsumer80_Feign_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_Feign_App.class, args); &#125;&#125; 测试启动3个Eureka集群，启动三个部门微服务提供者，启动Feign，访问http://localhost/consumer/dept/list即可 总结说明Feign集成了Ribbon，利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并通过轮询的方式实现了客户端的复杂均衡，与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式法人方法，优雅而简单的实现服务调用。 Hystrix断路器概述Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多的依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下， 不会导致整体服务的失败，避免级联故障，以提高分布式系统的弹性。断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方法返回一个预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法异常无法处理的异常，这样就保证服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延。 服务熔断熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某一个微服务不可用或者响应时间太长，会进行服务的降级， 进而熔断该节点微服务的调用，快速返回“错误”的响应信息，当检测到该节点微服务调用响应正常后恢复调用链路，在SpringCloud框架中熔断机制使用Hystrix实现，Hystrix会监控微服务调用情况，当失败达到一定阈值。就会启动熔断机制，熔断机制的注解是 @HystrixCommand Hystrix实操参照microservicecloud-provider-dept-8001建立microservicecloud-provider-dept-hystrix-8001项目pom.xml文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-provider-dept-hystrix-8001&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址 1234567891011121314151617181920212223242526272829303132333435363738server: port: 8001 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间 eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址 info: app.name: luokangyuan-microservicecloud company.name: www.luokangyuan.com build.artifactId: $project.artifactId$ build.version: $project.version$ 修改DeptControllerHystrix的作用就是当调用服务出现异常时如何解决，模拟根据id查部门信息，查到null，人为抛出运行时异常，让Hystrix处理这种情况。 123456789101112131415@RequestMapping(value=\"dept/get/&#123;id&#125;\",method=RequestMethod.GET)@HystrixCommand(fallbackMethod = \"processHystrix_GET\")public Dept get(@PathVariable(\"id\") Long id)&#123; Dept dept = service.get(id); if(null == dept)&#123; throw new RuntimeException(\"该ID:\"+id+\"没有对应的部门信息\"); &#125; return dept;&#125;public Dept processHystrix_GET(@PathVariable(\"id\") Long id)&#123; return new Dept().setDeptno(id) .setDname(\"该ID：\"+id+\"没有对应的信息，null--@HystrixCommand\") .setDb_source(\"no this database in Mysql\");&#125; 修改主启动类添加Hystrix支持123456789@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心@EnableDiscoveryClient // 服务发现@EnableCircuitBreaker //对Hystrix熔断机制的支持public class DeptProvider8001_Hystrix_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_Hystrix_App.class, args); &#125;&#125; 测试熔断机制启动三个Eureka集群，启动服务主启动类DeptProvider8001_Hystrix_App，客户端启动microservicecloud-consumer-dept-80，页面访问http://localhost/consumer/dept/get/112 服务降级服务降级处理是在客户端完成的，与服务端没有关系，在前面的服务熔断中，我们发现每一个业务方法都要写一个processHystrix_方法，这样就造成了很大耦合，根据Spring的学习，我们可将processHystrix_改写一个异常通知。 修改microservicecloud-api工程根据已有的DeptClientService接口，新建一个实现了FallbackFactory接口的类DeptClientServiceFallbackFactory 123456789101112131415161718192021222324252627282930313233343536package com.luo.springcloud.service;import java.util.List;import org.springframework.stereotype.Component;import com.luo.springcloud.entities.Dept;import feign.hystrix.FallbackFactory;@Componentpublic class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt;&#123; @Override public DeptClientService create(Throwable arg0) &#123; return new DeptClientService() &#123; @Override public List&lt;Dept&gt; list() &#123; return null; &#125; @Override public Dept get(long id) &#123; return new Dept().setDeptno(id) .setDname(\"该ID：\"+id+\"没有对应的信息，Consumer客户端提供的降级信息，此服务暂停使用\") .setDb_source(\"no this database in Mysql\"); &#125; @Override public boolean add(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; 注意：不要忘记新类上添加@Component注解 修改microservicecloud-api在DeptClientService接口在注解@FeignClient(value = “MICROSERVICECLOUD-DEPT”)添加fallbackFactory属性值 1@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class) 1234567891011@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class)public interface DeptClientService &#123; @RequestMapping(value = \"/dept/get/&#123;id&#125;\",method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\",method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 修改microservicecloud-consumer-dept-feign的Application.yml文件1234567891011server: port: 80 feign: hystrix: enabled: trueeureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 测试服务降级启动三个Eureka集群，microservicecloud-provider-dept-8001启动，microservicecloud-consumer-dept-feign启动，正常访问http://localhost/consumer/dept/get/1测试，故意关停microservicecloud-provider-dept-8001，客户端自己调用提示 服务监控Hystrix DashboardHystrix还提供了准实时的调用监控Hystrix Dashboard，Hystx会持续的记录所有通过Hystrix发起的请求的执行信息，并以统计报表的图形的形式展示给用户，包括每秒执行多少次请求多少成功多少失败等，对监控内容转换为可视化界面。 新建microservicecloud-consumer-hystrix-dashboard监控的一个微服务工程 POM.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-hystrix-dashboard&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- 自己定义的api --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix和 hystrix-dashboard相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12server: port: 9001 主启动类DeptConsumer_DashBoard_App1234567@SpringBootApplication@EnableHystrixDashboardpublic class DeptConsumer_DashBoard_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer_DashBoard_App.class, args); &#125;&#125; 微服务提供者添加监控依赖配置所有的Provider微服务提供类（8001,8002,8003）都需要监控依赖配置，也就是pom文件添加如下依赖 12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 监控页面测试启动microservicecloud-consumer-hystrix-dashboard，访问http://localhost:9001/hystrix,出现豪猪页面 全部测试启动3个Eureka集群，启动microservicecloud-provider-dept-hystrix-8001，启动了microservicecloud-consumer-hystrix-dashboard用来监控8001服务提供者，访问http://localhost:8001/hystrix.stream 观察监控窗口访问http://localhost:9001/hystrix，填写监控地址http://localhost:8001/hystrix.stream,时间2000，title:demo01,点击按钮 实心圆：两种含义，它通过颜色的变化代表了实例的健康程度，健康色是从绿色&lt;黄色&lt;橙色&lt;红色递减，该实心圆除了颜色的变化之外，他的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大，所以通过实心圆的展示就可以在大量实例中快速的发现 故障实例和高压力测试。 Zuul路由网关概述Zuul包含了对请求的路由和过滤两个主要的功能，其中路由的功能是负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤功能是负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础，Zuul和Eureka进行整合，将Zuul自身注册近Eureka服务治理的应用，同时从Eureka中获取其他微服务的消息，也及时以后的访问服务都是通过Zuul跳转后获得， 注意的是Zuul服务最终还是会注册近Eureka中 路由基本配置新建项目microservicecloud-zuul-gateway-9527，添加依赖如下 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-zuul-gateway-9527&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- zuul路由网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix容错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日常标配 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678910111213141516171819202122232425server: port: 9527 spring: application: name: microservicecloud-zuul-gateway eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka,http://eureka7003.com:7003/eureka instance: instance-id: gateway-9527.com prefer-ip-address: true zuul: #ignored-services: microservicecloud-dept prefix: /luo ignored-services: \"*\"info: app.name: luo-microcloud company.name: www.luo.com build.artifactId: $project.artifactId$ build.version: $project.version$ 修改host文件1127.0.0.1 myzuul.com 主启动类Zuul_9527_StartSpringCloudApp1234567@SpringBootApplication@EnableZuulProxypublic class Zuul_9527_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(Zuul_9527_StartSpringCloudApp.class, args); &#125;&#125; 启动三个集群，一个服务提供类microservicecloud-provider-dept-8001，一个路由 测试不使用路由：http://localhosat:8001/dept/get/2 使用路由：http://myzuul.com:9527/microservicecloud-dept/dept/get/2 Zuul路由访问映射在前面的测试中我们可以使用http://myzuul.com:9527/microservicecloud-dept/dept/get/2访问我们的接口，这样就暴露我们的微服务名称，需要做安全加固，就用到了路由访问映射，修改路由项目的yml文件,添加 mydept.path: /mydept/** 1234567zuul: #ignored-services: microservicecloud-dept #忽略真实地址，只让虚拟地址访问 prefix: /luo #访问地址前缀 ignored-services: \"*\"#忽略真实地址，只让虚拟地址访问 routes: mydept.serviceId: microservicecloud-dept ##真实地址 mydept.path: /mydept/** # 虚拟地址 访问连接：http://lyzuul.com:9527/luo/mydept/dept/get/1 SpringCloudConfig配置中心概述就前面项目而言，分布面临的问题是配置问题，每一个项目都有一个yml文件，不好运维管理，所有需要一套集中式，动态的配置管理设施，SpringCloud提供了ConfigServer来解决这个问题。 SpringCloud Config是为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为 各个不同的微服务应用的环境提供了一个 中心化的外部配置。SpringCloud Config分为客户端和服务端，服务端也称 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密和解密信息等访问接口，客户端是通过指定的配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具管理和访问配置内容。 作用 集中管理配置文件 不同环境下不同配置，动态化的配置更新，分环境部署等 运行期间动态调整配置，不需要在每一个服务部署的机器编码上编写文件，服务会向配置中心拉取自己的配置信息 当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置 将配置信息以REST接口的形式暴露 config服务端与GitHub通信GitHUb上新建一个microservicecloud-config的Repository 本地硬盘目录新建git仓库并clone 在D:\\workspace2018\\micorservicecloude-config\\microservicecloud-config新建application.yml文件 1234567891011121314Spring: profiles: active: - dev---Spring: profiles: dev application: name: micorservicecloud-config-luo-dev---Spring: profiles: test application: name: micorservicecloud-config-luo-test 注意保存为utf-8的文件格式 将yml文件推送到GitHub上 123git add .git commit -m&quot;&quot;git push origin master 新建项目microservicecloud-config-3344 POM.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-config-3344&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- springCloud Config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 避免Config的Git插件报错：org/eclipse/jgit/api/TransportConfigCallback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt; &lt;version&gt;4.10.0.201712302008-r&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 图形化监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 熔断 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件 1234567891011server: port: 3344 spring: application: name: microservicecloud-config cloud: config: server: git: uri: git@github.com:luokangyuan/microservicecloud-config.git #GitHub上面的git仓库名字 主启动类 1234567@SpringBootApplication@EnableConfigServerpublic class Config_3344_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(Config_3344_StartSpringCloudApp.class, args); &#125;&#125; 修改host文件 1127.0.0.1 config-3344.com 测试通过config微服务从GitHub上获取配置内容 启动服务3344，访问http://config-3344.com:3344/application-dev.yml，http://config-3344.com:3344/application-test.yml config客户端获取github配置本地新建microservicecloud-config-client.yml文件,并推送到github 123456789101112131415161718192021server: port: 8201spring: profiles: dev application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-dev.com:7001/eureka/---server: port: 8202spring: profiles: test application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-test.com:7001/eureka/ 新建项目microservicecloud-config-client-3355，pom.xml文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringCloud Config客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建bootstrap.yml文件 1234567spring: cloud: config: name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名 profile: test #本次访问的配置项 label: master uri: http://config-3344.com:3344 #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址 application.yml是用户级的资源配置文件，bootstrap.yml是系统级，优先级更高，保证不会被本地配置文件所覆盖 修改host文件，增加映射 1127.0.0.1 client-config.com 新建测试controller，从github读取配置信息 123456789101112131415161718192021222324252627package com.luo.springcloud.rest;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ConfigClientRest&#123; @Value(\"$&#123;spring.application.name&#125;\") private String applicationName; @Value(\"$&#123;eureka.client.service-url.defaultZone&#125;\") private String eurekaServers; @Value(\"$&#123;server.port&#125;\") private String port; @RequestMapping(\"/config\") public String getConfig() &#123; String str = \"applicationName: \" + applicationName + \"\\t eurekaServers:\" + eurekaServers + \"\\t port: \" + port; System.out.println(\"******str: \" + str); return \"applicationName: \" + applicationName + \"\\t eurekaServers:\" + eurekaServers + \"\\t port: \" + port; &#125;&#125; 新建主启动类 123456@SpringBootApplicationpublic class ConfigClient_3355_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClient_3355_StartSpringCloudApp.class, args); &#125;&#125; 测试 启动3344服务，启动3355服务，bootstrap.yml中的profile值是什么，决定从github上读取什么,ruguo 访问http://client-config.com:8201/config得到是github上的microservicecloud-config-client.yml文件中dev相关的配置信息 访问http://client-config.com:8202/config得到是github上的microservicecloud-config-client.yml文件中test相关的配置信息","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"前端基础知识学习---JavaScript学习总结","slug":"前端基础知识学习---JavaScript学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:02:31.162Z","comments":true,"path":"2019/03/22/前端基础知识学习---JavaScript学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/前端基础知识学习---JavaScript学习总结/","excerpt":"JavaScript基础部分JavaScript简介JavaScript实现JavaScript是一种专门为网页交互设计的脚本语言，有以下三部分组成： ECMAScript，提供和核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口； HTML中使用JavaScript","text":"JavaScript基础部分JavaScript简介JavaScript实现JavaScript是一种专门为网页交互设计的脚本语言，有以下三部分组成： ECMAScript，提供和核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口； HTML中使用JavaScript 标签的位置传统位置将JavaScript放在title后面 12345&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../js/index.js\"&gt;&lt;/script&gt;&lt;/head&gt; 由于解析网页的时候按照从上到写的加载原则，只有等所有的JavaScript文件加载成功后页面才能显示，如果JavaScript文件有一处错误，那么整个页面都就是一片空白，因此，位置应该放置与body内容后面，如下： 1234&lt;body&gt; &lt;!--这里放页面内容--&gt; &lt;script type=\"text/javascript\" src=\"../js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt; JavaScript基本概念JavaScript语法严格区分大小写 在ECMAScript中的一切变量，函数名和操作符都严格区分大小写，例如变量名test和Test是两个不同的变量名。 标识符 标识符就是指变量，函数，属性的名字，或者函数的参数名，标识符是由满足下列规则组合的一个或者多个字符 第一个字符必须是一个字母、下划线（_）或者一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或者数字； 标识符一般采用驼峰命名法，首字母小写，每一个单词的开头字母大写（规范，不是强制要求） 注意：不能将关键字，保留字，true，false和null用作标识符 注释 ECMAScript中有单行注释和块级注释，单行注释以两个斜杠开头，块级注释以一个斜杠加一个星号开头（/*），一个星号加一个斜杠结尾。 语句 ECMAScript语句以一个分号结尾，虽然不加分号也是能运行的，但是不加分号，是浏览器很会帮我们添加分号，这样依赖降低性能，二来，浏览器有时会加错分号的位置，所以，养成良好的代码编写风格，自己加。 关键字和保留字在ECMAScript中具有特定用途的标识符称之为关键字，这些关键字可表示控制语句的开始或者结束，或者用于描述一个变量等，如下： breake；do；instanceof；typeof；case；else；new；var,catch；finally；return； void；continue；for；switch；while；default；if,throw；delete；in；try； function；this；with；debugger；false；true；null 还存在一些没有特殊用途的标识符，但是以后可能有特殊用途的标识符称之为保留字，如下： class ；enum；extends；super；const；export； import；implements；le:；private；public；yield；interface；package；protected；static 说明：在ES6中已经将let作为关键字定义变量 JavaScript数据类型变量在ES中，变量是松散类型的，所谓松散类型就是说变量可以保存任何类型的数据，换句话说，这个变量仅仅是一个用于保存值的占位符，使用关键字var，在ES6中推荐使用let关键字； 数据类型在ES中定义了六种数据类型，其中包含了五种基本数据类型，分别是：String，Number，Boolean，Null，Underfined和一种复杂数据类型Object； typeof操作符因为在ES中的数据类型是松散类型的，因此需要一种手段来检测变量的数据类型，这个时候就使用typeof，使用该操作符可能返回以下值，分别为： underfined：表示这个值未定义； boolean：表示这个值是布尔值； string：表示这个值是一个字符串； number：表示这个值是一个数值； object：表示这个值是一个对象或者null； function：表示这个值是一个函数； 123var a = \"hello\"console.log(typeof a);console.log(Number.MAX_VALUE * Number.MAX_VALUE)/*返回的是Infinity无穷大*/ Undefined类型Undefined类型就只有一个undefined值，在使用var定义变量后，未初始化该变量，那么使用typeof检测，返回的就是undefined，例如： 123var message;console.log(message)/*undefined*/console.log(message == undefined);/*true*/ Null类型NULL类型也只有一个NULL值，从逻辑角度看，这个NULL值代表的是一个空对象指针，所以当我们使用typeof null返回的是Object，如下： 12var user = null;console.log(typeof user);/*object*/ 注意：如果定义变量是在将来用于保存对象，那么最好在定义的时候就初始化为NULL Boolean类型Boolean类型有两个值，分别为:true，false；这两个值和数字值没有关系，true并不代表1，如下： 12var message = false;var test = true; 注意：Boolean类型的值是区分大小写的，True和False，或者大小写混写都只是代表标识符，不是Boolean值； 虽然Boolean类型的值只有两个，但是在ES中任何类型的值都可以与这两个Boolean值有着等价的值，要将一个值转换为对应的Boolean值，可以调用转型函数Boolean()，如下所示： 1234var test = \"Helo\";var testBoolean = Boolean(test);console.log(typeof testBoolean)/*boolean*/console.log(testBoolean);/*true*/ 有关各种数据类型的转换规则如下： String类型，非空字符转换为true，空字符串转换为false； number类型，任何非零数字值（包括无穷大），转换为true，0和NaN转换为false； Object类型，任何对象转换为true，NUL转换为false； 使用这些转换规则可以更方便的使用if流程语句，例如： 1234var message = \"Hello Word\";if(message)&#123; console.log(\"我执行了。。。\")/*该行代码会被执行*/&#125; Number类型ES中Number数据类型包含整数和浮点数值，在JavaScript中可以使用number类型保存正零和负零，正零和负零被认为是相等的。 浮点数值 在JavaScript中浮点数值就是数值中必须包含一个小数点，并且小数点后至少有一位数字，虽然小数点前面可以没有整数，但是不建议这种写法，如下： 123var floatN1 = \"1.1\";var floatN2 = \"0.1\";var floatN3 = \".1\";/*虽有效，但不推荐*/ 由于保存浮点数值需要的内存空间是整数的两倍，所以，只要可以将浮点数转换为整数，就会转换为整数，如下： 1var floatN1 = \"1.0\"; 当然也可以使用科学计数法，如下： 1var floatN1 = 3.12e7; 注意：使用浮点数值进行计算会产生误差的问题，所以和钱相关的就不要使用JavaScript计算了。 整数数值 由于内存的限制，JavaScript不可能保存最大的数值，所以就有了JavaScript中的最大值和最小值，如果超出这个值就会返回一个Infinity无穷大和-Infinity负无穷，如下 12console.log(Number.MIN_VALUE);/*5e-324*/console.log(Number.MAX_VALUE);/*1.7976931348623157e+308*/ 非数值NANNAN,是一个特殊的数值，表示一个本来应该返回数值的操作却没有返回数值的情况，例如任何数值除以非数值就会返回NAN，但是在其他编程语言中就会保存，就是程序的运行。有关非数值NAN需要注意以下几点： 任何涉及到NAN的操作都会返回NAN,例如NAN/10; 任何数值和NAN都不相等，包括NAN本身； 在JavaScript中针对NAN的特殊性，定义了isNaN()函数，这个函数接受一个参数，该参数可以是任何类型，这个函数可以帮我们确定这个参数是否是不是数值，这个函数接收一个参数后，会尝试将这个参数转换为数值类型，不能被转换的就会返回false，否则返回true，如下： 12345console.log(isNaN(NaN));/*true*/console.log(isNaN(10));/*false*/console.log(isNaN(\"10\"));/*false*/console.log(isNaN(\"hello\"));/*true*/ console.log(isNaN(true));/*false*/ 数值转换在JavaScript中有三个函数可以将非数值转换为数值类型，分别是：Number()、parseInt()和parseFloat(),其中Number()函数可以用于任何数据类型，而其他两个用于将字符串转换为数值，三个函数对于同样的输入却有不同的输出，具体的转换规则如下： Number()函数的转换规则 如果是Boolean值，则true和false分别转换为1和0； 如果是数字值，就只是简单的传入和返回； 如果是NULL，返回的是0； 如果是undefined，返回的是NAN； 如果是字符串，具体转换如下： 如果字符串只包含数字（包括前面的正负号），则将其转换为十进制数值； 如果字符串包含有效的浮点格式，就会转换为对应的浮点数值； 如果字符串包含有效的十六进制格式，就会转换为相同大小的十进制数值； 如果字符串是空字符串，则转换为数值0； 如果字符串不是以上类型的格式，就会转换为NaN； 如果是对象，则调用对象的valueOf()方法，然后按照上述的规则转换，如果转换结果为NaN，则调用对象的toString()方法，然后再按照上述规则转换； 1234console.log(Number(\"hello word\"))/*NaN*/console.log(Number(\"\"))/*0*/console.log(Number(\"0000011\"))/*11*/console.log(Number(true))/*1*/ parsenInt()函数转换规则 parsenInt()函数在转换数值的时候，注重的是看是否复合数值模式，它会忽略字符串前面的空格，直至找到第一个非空字符串，如果第一个字符串不是数字或者正负号，就返回NaN； 对空字符串，返回的是NaN,Number函数对于空字符串返回的是0 1234567console.log(parseInt(\"1234hello\"));/*1234*/console.log(parseInt(\"\"));/*NaN*/console.log(parseInt(\"0xA\"));/*十六进制：10*/console.log(parseInt(\"22.5\"));/*22*/console.log(parseInt(\"070\"));/*八进制：70*/console.log(parseInt(\"70\"));/*十进制：70*/console.log(parseInt(\"0xf\"));/*十六进制：15*/ parseFloat函数转换规则 从第一个字符开始解析，直到解析到字符串末尾结束，或者遇见一个无效的浮点数字字符位置； 字符串中的第一个小数点是有效的，第二个小数点是无效的； 如果字符串包含的是一个可解析为整数的数，则会返回整数； 123456console.log(parseFloat(\"1234hello\"));/*1234*/console.log(parseFloat(\"0xA\"));/*0*/console.log(parseFloat(\"22.5\"));/*22.5*/console.log(parseFloat(\"22.34.45\"));/*22.34*/console.log(parseFloat(\"0986.6\"));/*986.6*/console.log(parseFloat(\"3.144e7\"));/*31440000*/ String类型string类型用于表示由零个或者多个16位Unicode字符组成的字符串序列，就是字符串，在JavaScript中字符串可以使用单引号和双引号，但是不可混用。 转义字符 \\n：表示换行，\\t：表示制表符，\\b：表示退格，\\r：表示回车 \\\\:表示斜杠，\\&#39;：表示单引号，\\&quot;：表示双引号 说明：任何字符串可以通过length属性获取字符串的长度，例如：text.length 字符串的特点 在JavaScript中字符串是不可变的，换句话说，就是字符一旦创建，他的值就不能改变，要改变某一个变量的字符串，就要先销毁原来的字符串，在创建一个新的字符串值填充该变量。 转换为字符串 调用toString()方法；例如数值，布尔值，对象和字符串值都有toString方法；null和undefined没toString方法； 使用String()转型函数， 123456var num = 10;console.log(num.toString());/*\"10\"*/console.log(num.toString(2));/*按照二进制转换：\"1010\"*/console.log(num.toString(8));/*按照八进制转换：\"12\"*/console.log(num.toString(10));/*按照十进制转换：\"10\"*/console.log(num.toString(16));/*按照十六进制转换：\"a\"*/ 注意：调用toString方法可以指定基数，转换成不同的字符串 12345var value;console.log(String(10));/*\"10\"*/console.log(String(true));/*\"true\"*/console.log(String(null));/*\"null\"*/console.log(String(value));/*\"undefined\"*/ Object类型在JavaScript中对象是一组数据和功能的集合，对象通过new的方式创建，例如var u = new Object()，Object类型是所有它的实例的基础，也就是说，Object具有的任何属性和方法也都存在与具体的对象中，和java中的Object对象一样，Object具有的属性和方法如下： constructor：保存着用于创建当前对象的函数，构造函数constructor就是Object()； hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中是否存在； isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型； propertyIsEnumerable(propertyName)：用于检查给定的属性能否使用for-in语句来枚举； toLocaleString()：返回对象的字符串表示； toString()：返回对象的字符串表示； valueOf()：返回对象的字符串、数值或者布尔值。 JavaScript操作符一元操作符","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习-----PostgreSQL学习总结","slug":"JavaEE进阶知识学习-----PostgreSQL学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:00:19.576Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习-----PostgreSQL学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习-----PostgreSQL学习总结/","excerpt":"PostgreSQL基础部分PostgreSQL简介PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。","text":"PostgreSQL基础部分PostgreSQL简介PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。 PostgreSQL特点 PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。 PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。 PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。 在PostgreSQL中，表可以设置为从“父”表继承其特征。 可以安装多个扩展以向PostgreSQL添加附加功能。 PostgreSQL语法可以使用help语句查看所有postgreSQL语句的语法。 按照以下步骤查看PostgreSQL中所有语句的语法。 安装postgreSQL后，打开psql为：程序文件 -&gt; PostgreSQL 9.2 -&gt; SQL Shell(psql) 使用以下语句查看特定语句的语法。 postgres-＃\\ help＆ PostgreSQL数据类型数据类型指定要在表字段中存储哪种类型的数据。 在创建表时，对于每列必须使用数据类型。 以下是PostgreSQL中主要有三种类型的数据类型： 数值数据类型 字符串数据类型 日期/时间数据类型 数值数据类型 名称 描述 存储大小 范围 smallint 存储整数，小范围 2字节 -32768 至 +32767 integer 存储整数。使用这个类型可存储典型的整数 4字节 -2147483648 至 +2147483647 bigint 存储整数，大范围。 8字节 -9223372036854775808 至 9223372036854775807 decimal 用户指定的精度，精确 变量 小数点前最多为131072个数字; 小数点后最多为16383个数字。 numeric 用户指定的精度，精确 变量 小数点前最多为131072个数字; 小数点后最多为16383个数字。 real 可变精度，不精确 4字节 6位数字精度 double 可变精度，不精确 8字节 15位数字精度 serial 自动递增整数 4字节 1 至 2147483647 bigserial 大的自动递增整数 8字节 1 至 9223372036854775807 字符串数据类型 数据类型 描述 char(size) 这里size是要存储的字符数。固定长度字符串，右边的空格填充到相等大小的字符。 character(size) 这里size是要存储的字符数。 固定长度字符串。 右边的空格填充到相等大小的字符。 varchar(size) 这里size是要存储的字符数。 可变长度字符串。 character varying(size) 这里size是要存储的字符数。 可变长度字符串。 text 可变长度字符串。 日期/时间数据类型 名称 描述 存储大小 最小值 最大值 解析度 timestamp [ (p) ] [不带时区 ] 日期和时间(无时区) 8字节 4713 bc 294276 ad 1微秒/14位数 timestamp [ (p) ]带时区 包括日期和时间，带时区 8字节 4713 bc 294276 ad date 日期(没有时间) 4字节 4713 bc 5874897 ad 1微秒/14位数 time [ (p) ] [ 不带时区 ] 时间(无日期) 8字节 00:00:00 24:00:00 1微秒/14位数 time [ (p) ] 带时区 仅限时间，带时区 12字节 00:00:00+1459 24:00:00-1459 1微秒/14位数 interval [ fields ] [ (p) ] 时间间隔 12字节 -178000000年 178000000年 1微秒/14位数 PostgreSQL基本使用创建数据库可以使用数据库客户端pgAdmin来创建数据库,下面说的是使用SQL shell查询工具来创建数据库 1create database testdb; 查看数据库1postgres=# \\l 删除数据库123postgres=# drop database testdb;DROP DATABASEpostgres=# 创建表12345678CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); 删除表12postgres=# drop table student2;DROP TABLE PostgreSQL模式模式(也叫架构)是指定的表集合。 它还可以包含视图，索引，序列，数据类型，运算符和函数。 尤为重要 创建模式语法1CREATE SCHEMA schema_name; 创建模式实例1CREATE SCHEMA myschema; 在模式下新建表12345678CREATE TABLE myschema.tb_test( id integer, name character(254))WITH ( OIDS=FALSE); 使用模式的优点 模式有助于多用户使用一个数据库，而不会互相干扰。 它将数据库对象组织成逻辑组，使其更易于管理。 可以将第三方模式放入单独的模式中，以避免与其他对象的名称相冲突。 PostgreSQL查询工具INSERT语句1234567INSERT INTO EMPLOYEES( ID, NAME, AGE, ADDRESS, SALARY) VALUES (1, 'Maxsu', 25, '海口市人民大道2880号', 109990.00 ), (2, 'minsu', 25, '广州中山大道 ', 125000.00 ), (3, '李洋', 21, '北京市朝阳区', 185000.00), (4, 'Manisha', 24, 'Mumbai', 65000.00), (5, 'Larry', 21, 'Paris', 85000.00); SELECT语句1SELECT ID, NAME, AGE, SALARY FROM EMPLOYEES; UPDATE语句123UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; DELETE语句12DELETE FROM table_name WHERE [condition]; 注意：如果不使用“WHERE”条件，整个表中的记录都将被删除 ORDER BY语句ORDER BY子句用于按升序或降序对数据进行排序。数据在一列或多列的基础上进行排序。 1234SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; GROUP BY语句GROUP BY子句用于将具有相同数据的表中的这些行分组在一起。 它与SELECT语句一起使用。GROUP BY子句通过多个记录收集数据，并将结果分组到一个或多个列。 它也用于减少输出中的冗余 12345SELECT column-list FROM table_name WHERE [conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN 实例,按name分组，统计薪水 123SELECT NAME, SUM(SALARY) FROM EMPLOYEES GROUP BY NAME; HAVING IN语句HAVING子句与GROUP BY子句组合使用，用于选择函数结果满足某些条件的特定行。 123456SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 实例，查询表中名字相同数大于2 123SELECT NAME,COUNT (NAME) FROM EMPLOYEES GROUP BY NAME HAVING COUNT (NAME) &gt; 2; PostgreSQL条件查询PostgreSQL条件用于从数据库获取更具体的结果。 通常与WHERE子句一起使用。 具有子句的条件就像双层过滤器。 AND 条件 OR 条件 AND &amp; OR 条件 NOT 条件 LIKE 条件 IN 条件 NOT IN 条件 BETWEEN 条件 AND条件AND条件与WHERE子句一起使用，以从表中的多个列中选择唯一的数据。 1234SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] AND [search_condition]; OR条件OR条件与WHERE子句一起使用，以从表中的一列或多列列中选择唯一数据 1234SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] OR [search_condition]; OR和AND一起使用实例 1234SELECT * FROM EMPLOYEES WHERE (NAME = 'Minsu' AND ADDRESS = 'Delhi') OR (ID&gt;= 8); NOT条件NOT条件与WHERE子句一起使用以否定查询中的条件。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] NOT [condition]; 实例 1234567SELECT * FROM EMPLOYEES WHERE address IS NOT NULL ;--查询年龄不是21和24的所有记录SELECT * FROM EMPLOYEES WHERE age NOT IN(21,24) ; LIKE条件LIKE条件与WHERE子句一起用于从指定条件满足LIKE条件的表中获取数据 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] LIKE [condition]; 实例，查询名字以Ma开头记录 123SELECT * FROM EMPLOYEES WHERE NAME LIKE 'Ma%'; IN条件IN条件与WHERE子句一起使用，从指定条件满足IN条件的表中获取数据。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] IN [condition]; 实例,查询年龄是19,21的记录 123SELECT * FROM EMPLOYEES WHERE AGE IN (19, 21); NOT IN条件NOT IN条件与WHERE子句一起使用，以从指定条件否定IN条件的表中获取数据。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] NOT IN [condition]; BETWEEN条件BETWEEN条件与WHERE子句一起使用，以从两个指定条件之间的表中获取数据 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] BETWEEN [condition]; 实例，查询年龄在24到27之间的记录，包括24和27 123SELECT * FROM EMPLOYEES WHERE AGE BETWEEN 24 AND 27; PostgreSQL连接 内连接(INNER JOIN) 左外连接(LEFT OUTER JOIN) 右外连接(RIGHT OUTER JOIN) 全连接(FULL OUTER JOIN) 跨连接(CROSS JOIN) INNER JOIN内连接内部连接也被称为连接或简单连接。 这是最常见的连接类型。 此连接返回满足连接条件的多个表中的所有行。 简单讲，就是返回两张表中共同拥有的部分 1234SELECT table1.columns, table2.columns FROM table1 INNER JOIN table2 ON table1.common_filed = table2.common_field; LEFT JOIN左外连接左外连接返回从“ON”条件中指定的左侧表中的所有行，只返回满足条件的另一个表中的行。 简单讲on条件中左侧表的全部加上两张表共同的部分 1234SELECT table1.columns, table2.columns FROM table1 LEFT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 返回的是table1的全部和table1和table2共同的记录 RIGHT JOIN右外连接右外连接返回从“ON”条件中指定的右侧表中的所有行，只返回满足条件的另一个表中的行。 1234SELECT table1.columns, table2.columns FROM table1 RIGHT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 返回的是table2的全部记录和table1和table2共同的部分 FULL 全外连接FULL外连接从LEFT手表和RIGHT表中返回所有行。 它将NULL置于不满足连接条件的位置。 1234SELECT table1.columns, table2.columns FROM table1 FULL OUTER JOIN table2 ON table1.common_filed = table2.common_field; CROSS跨连接跨连接(CROSS JOIN)将第一个表的每一行与第二个表的每一行相匹配。 它也被称为笛卡儿积分。 如果table1具有“x”列，而table2具有“y”列，则所得到的表将具有(x + y)列。 123SELECT coloums FROM table1 CROSS JOIN table2 PostgreSQL高级部分PostgreSQL视图在PostgreSQL中，视图(VIEW)是一个伪表。 它不是物理表，而是作为普通表选择查询。 视图也可以表示连接的表。 它可以包含表的所有行或来自一个或多个表的所选行。 使用视图的优点 它以自然和直观的方式构建数据，并使其易于查找。 它限制对数据的访问，使得用户只能看到有限的数据而不是完整的数据。 它归总来自各种表中的数据以生成报告。 创建视图可以使用CREATE VIEW语句来在PostgreSQL中创建视图。 您可以从单个表，多个表以及另一个视图创建它。 1234CREATE [TEMP | TEMPORARY] VIEW view_name AS SELECT column1, column2..... FROM table_name WHERE [condition]; 创建视图实例,在Employees表创建一个视图，此视图仅包含Employee表中的几个列 123CREATE VIEW current_employees AS SELECT NAME, ID, SALARY FROM EMPLOYEES; 这个时候，你可以在视图下看到current_employees视图 使用视图 1SELECT * FROM current_employees; 删除视图 1DROP VIEW current_employees; PostgreSQL函数PostgreSQL函数也称为PostgreSQL存储过程。 PostgreSQL函数或存储过程是存储在数据库服务器上并可以使用SQL界面调用的一组SQL和过程语句(声明，分配，循环，控制流程等)。 它有助于您执行通常在数据库中的单个函数中进行多次查询和往返操作的操作。可以在许多语言(如SQL，PL/pgSQL，C，Python等)中创建PostgreSQL函数。 12345678910CREATE [OR REPLACE] FUNCTION function_name (arguments) RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN &lt; function_body &gt; [...] RETURN &#123; variable_name | value &#125; END; LANGUAGE plpgsql; 说明： function_name：指定函数的名称。 [OR REPLACE]：是可选的，它允许您修改/替换现有函数。 RETURN：它指定要从函数返回的数据类型。它可以是基础，复合或域类型，或者也可以引用表列的类型。 function_body：function_body包含可执行部分。 plpgsql：它指定实现该函数的语言的名称。 实例，在Employee表上创建一个total records() 函数 123456789CREATE OR REPLACE FUNCTION totalRecords () RETURNS integer AS $total$ declare total integer; BEGIN SELECT count(*) into total FROM EMPLOYEES; RETURN total; END; $total$ LANGUAGE plpgsql; 调用函数 1select totalRecords(); PostgreSQL触发器PostgreSQL触发器是一组动作或数据库回调函数，它们在指定的表上执行指定的数据库事件(即，INSERT，UPDATE，DELETE或TRUNCATE语句)时自动运行。 触发器用于验证输入数据，执行业务规则，保持审计跟踪等。 说明 PostgreSQL在以下情况下执行/调用触发器：在尝试操作之前(在检查约束并尝试INSERT，UPDATE或DELETE之前)。或者在操作完成后(在检查约束并且INSERT，UPDATE或DELETE完成后)。或者不是操作(在视图中INSERT，UPDATE或DELETE的情况下) 对于操作修改的每一行，都会调用一个标记为FOR EACH ROWS的触发器。 另一方面，标记为FOR EACH STATEMENT的触发器只对任何给定的操作执行一次，而不管它修改多少行。 您可以为同一事件定义同一类型的多个触发器，但条件是按名称按字母顺序触发。 当与它们相关联的表被删除时，触发器被自动删除。 创建触发器12345CREATE TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name ON table_name [ -- Trigger logic goes here.... ]; 在这里，event_name可以是INSERT，UPDATE，DELETE和TRUNCATE数据库操作上提到的表table_name。 您可以选择在表名后指定FOR EACH ROW。下面来看看看如何在INSERT操作中创建触发器的语法。 12345CREATE TRIGGER trigger_name AFTER INSERT ON column_name ON table_name [ -- Trigger logic goes here.... ]; 实例当插入一条数据到审核表COMPANY时，就会在AUDIL表中插入一条记录 先在审核表中创建一个函数auditlogfunc 123456CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$ BEGIN INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp); RETURN NEW; END; $example_table$ LANGUAGE plpgsql; COMPANY表上创建触发器 12CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY FOR EACH ROW EXECUTE PROCEDURE auditlogfunc(); 向审核表中插入数据测试 12INSERT INTO COMPANY VALUES(1, '小米科技', 8, '北京市朝阳区', 9999);INSERT INTO COMPANY VALUES(2, '京东中科', 6, '广州市天河区', 8999); 触发器使用场景 验证输入数据。 执行业务规则。 为不同文件中新插入的行生成唯一值。 写入其他文件以进行审计跟踪。 从其他文件查询交叉引用目的。 访问系统函数。 将数据复制到不同的文件以实现数据一致性。 触发器的优点 它提高了应用程序的开发速度。 因为数据库存储触发器，所以您不必将触发器操作编码到每个数据库应用程序中。 全局执法业务规则。定义触发器一次，然后将其重用于使用数据库的任何应用程序。 更容易维护 如果业务策略发生变化，则只需更改相应的触发程序，而不是每个应用程序。 提高客户/服务器环境的性能。 所有规则在结果返回之前在服务器中运行。 PostgreSQL索引索引是用于加速从数据库检索数据的特殊查找表。数据库索引类似于书的索引(目录)。 索引为出现在索引列中的每个值创建一个条目。 特点 索引使用SELECT查询和WHERE子句加速数据输出，但是会减慢使用INSERT和UPDATE语句输入的数据。 您可以在不影响数据的情况下创建或删除索引。 可以通过使用CREATE INDEX语句创建索引，指定创建索引的索引名称和表或列名称。 还可以创建一个唯一索引，类似于唯一约束，该索引防止列或列的组合上有一个索引重复的项 创建索引1CREATE INDEX index_name ON table_name; 索引类型PostgreSQL中有几种索引类型，如B-tree，Hash，GiST，SP-GiST和GIN等。每种索引类型根据不同的查询使用不同的算法。 默认情况下，CREATE INDEX命令使用B树索引。 单列索引如果仅在一个表列中创建索引，则将其称为单列索引。 12CREATE INDEX index_name ON table_name (column_name); 多列索引如果通过使用表的多个列创建索引，则称为多列索引。 12CREATE INDEX index_name ON table_name (column1_name, column2_name); 唯一索引创建唯一索引以获取数据的完整性并提高性能。它不允许向表中插入重复的值，或者在原来表中有相同记录的列上也不能创建索引。 12CREATE UNIQUE INDEX index_name on table_name (column_name); 删除索引1DROP INDEX index_name; 避免使用索引场景 应该避免在小表上使用索引。 不要为具有频繁，大批量更新或插入操作的表创建索引。 索引不应用于包含大量NULL值的列。 不要在经常操作(修改)的列上创建索引。 PostgreSQL日期函数 函数 描述 AGE() 减去参数 CURRENT DATE/TIME() 它指定当前日期和时间。 DATE_PART() 获取子字段(相当于提取) EXTRACT() 获得子字段 ISFINITE() 测试有限的日期，时间和间隔(非+/-无穷大) JUSTIFY 调整间隔 AGE(timestamp，timestamp)＆AGE(timestamp) 函数 描述 age(timestamp, timestamp) 当使用第二个参数的时间戳形式调用时，age()减去参数，产生使用年数和月份的类型为“interval”的“符号”结果。 age(timestamp) 当仅使用时间戳作为参数调用时，age()从current_date(午夜)减去。 AGE函数实例 1SELECT AGE(timestamp '2017-01-26', timestamp '1951-08-15'); --结果是65 year 5 mons 11 day 当前时间函数 函数 描述 CURRENT_DATE 提供当前日期 CURRENT_TIME 提供带时区的值 CURRENT_TIMESTAMP 提供带时区的值 CURRENT_TIME(precision) 选择使用precision参数，使结果在四分之一秒的范围内四舍五入到数位数。 CURRENT_TIMESTAMP(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 LOCALTIME 提供没有时区的值。 LOCALTIMESTAMP 提供没有时区的值。 LOCALTIME(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 LOCALTIMESTAMP(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 实例 12345SELECT CURRENT_TIME; --获取当前时间SELECT CURRENT_DATE; --获取当前日期SELECT CURRENT_TIMESTAMP; --获取当前时间戳SELECT CURRENT_TIMESTAMP(2); --虎丘当前时间戳更精确SELECT LOCALTIMESTAMP; --获取本地时间戳 PostgreSQL UNIONS语句PostgreSQL UNION子句/运算符用于组合两个或多个SELECT语句的结果，而不返回任何重复的行。要使用UNION，每个SELECT必须具有相同的列数，相同数量的列表达式，相同的数据类型，并且具有相同的顺序，但不一定要相同。 语法123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNIONSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] 实例 12345SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID UNION SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; UNION ALL语句UNION ALL运算符用于组合两个SELECT语句(包括重复行)的结果。 适用UNION的相同规则也适用于UNION ALL运算符。 123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNION ALLSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] PostgreSQL NULLPostgreSQL NULL是用于表示缺少值的术语。 表中的NULL值是一个字段中的值，显示为空白。具有NULL值的字段是没有值的字段。要知道一个NULL值与零值或包含空格的字段不同是非常重要的。 IS NOT NULL123SELECT ID, NAME, AGE, ADDRESS, SALARY FROM COMPANY WHERE SALARY IS NOT NULL; IS NULL123SELECT ID, NAME, AGE, ADDRESS, SALARY FROM COMPANY WHERE SALARY IS NULL; PostgreSQL修改表PostgreSQL ALTER TABLE命令用于添加，删除或修改现有表中的列。您还可以使用ALTER TABLE命令在现有表上添加和删除各种约束。 语法使用ALTER TABLE语句在现有表中添加新列的基本语法如下： 1ALTER TABLE table_name ADD column_name datatype; 现有表中ALTER TABLE到DROP COLUMN(删除某个字段)的基本语法如下： 1ALTER TABLE table_name DROP COLUMN column_name; ALTER TABLE更改表中列的DATA TYPE(修改字段类型)的基本语法如下： 1ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype; ALTER TABLE向表中的列添加NOT NULL约束的基本语法如下： 1ALTER TABLE table_name MODIFY column_name datatype NOT NULL; ALTER TABLE添加唯一约束ADD UNIQUE CONSTRAINT到表中的基本语法如下： 12ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...); ALTER TABLE将“检查约束”添加到表中的基本语法如下所示： 12ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION); ALTER TABLE添加主键ADD PRIMARY KEY约束的基本语法如下： 12ALTER TABLE table_nameADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...); 使用ALTER TABLE从表中删除约束(DROP CONSTRAINT)的基本语法如下： 12ALTER TABLE table_nameDROP CONSTRAINT MyUniqueConstraint; 使用ALTER TABLE从表中删除主键约束(DROP PRIMARY KEY)约束的基本语法如下： 12ALTER TABLE table_nameDROP CONSTRAINT MyPrimaryKey; PostgreSQL子查询子查询或内部查询或嵌套查询是一个PostgreSQL查询中的查询，它可以嵌入到WHERE子句中。子查询用于返回将在主查询中使用的数据作为进一步限制要检索的数据的条件。 子查询可以与SELECT，INSERT，UPDATE和DELETE语句以及运算符(如=，&lt;，&gt;，&gt;=，&lt;=，IN等)一起使用。 子查询必须括在括号中。 子查询在SELECT子句中只能有一列，除非主查询中有多个列用于比较其所选列的子查询。 ORDER BY不能用于子查询，主查询可以使用ORDER BY，GROUP BY可用执行与子查询中的ORDER BY相同的功能。 返回多行的子查询只能与多个值运算符一起使用，例如：IN，EXISTS，NOT IN，ANY / SOME，ALL运算符。 BETWEEN运算符不能与子查询一起使用; 但是，BETWEEN可以在子查询中使用。 带SELECT语句的子查询123456SELECT column_name [, column_name ]FROM table1 [, table2 ]WHERE column_name OPERATOR (SELECT column_name [, column_name ] FROM table1 [, table2 ] [WHERE]) 实例 12345SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &gt; 45000) ; 带INSERT语句的子查询子查询也可以用于INSERT语句。INSERT语句使用从子查询返回的数据插入另一个表。 可以使用任何字符，日期或数字函数修改子查询中选定的数据。 1234INSERT INTO table_name [ (column1 [, column2 ]) ] SELECT [ *|column1 [, column2 ] FROM table1 [, table2 ] [ WHERE VALUE OPERATOR ] 1234INSERT INTO COMPANY_BKP SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY) ; 带UPDATE语句的子查询子查询可以与UPDATE语句一起使用。 当使用具有UPDATE语句的子查询时，可以更新表中的单列或多列 123456UPDATE tableSET column_name = new_value[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 实例 假设我们有一个名为COMPANY_BKP表，它是COMPANY表的备份。以下示例将所有客户(其AGE大于或等于27)在COMPANY表中的SALARY更新为0.50倍： 1234UPDATE COMPANY SET SALARY = SALARY * 0.50 WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt;= 27 ); 带有DELETE语句的子查询12345DELETE FROM TABLE_NAME[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 实例 假设我们有一个COMPANY_BKP表，它是COMPANY表的备份。以下示例从COMPANY 表中删除所有客户的记录，其AGE大于或等于27数据记录 123DELETE FROM COMPANY WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt; 27 );","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习-----Java8新特性学习总结","slug":"JavaEE进阶知识学习-----Java8新特性学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T11:58:54.532Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习-----Java8新特性学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习-----Java8新特性学习总结/","excerpt":"lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 语法格式","text":"lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 语法格式 1.无参数，无返回值（）-&gt; System.out.print(“Hello Word”);12345678910111213@Testpublic void test1()&#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.print(\"Hello Word\"); &#125; &#125;; r.run(); System.out.print(\"===============================\"); Runnable r1 = () -&gt; System.out.print(\"Hello Word\"); r1.run();&#125; 2.一个参数，无返回值（x）-&gt; System.out.print(x);12345@Testpublic void test2()&#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept(\"Hello Word\");&#125; 如果只有一个参数，无返回值可以省略小括号不写。 3.两个参数，有返回值，并且有多条执行语句123456789@Testpublic void test3()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt;&#123; System.out.println(\"函数式接口\"); return Integer.compare(x,y); &#125;; int max = com.compare(4,5); System.out.println(max);&#125; 4.如果只有一条返回语句1234@Testpublic void test4()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);&#125; 注意说明lambda表达式中的参数类型可以省略不写，JVM可以根据上下文推断出类型 Lambda表达式需要函数式接口的支持。 函数式接口接口中只有一个抽象方法的接口，就叫函数式接口。可以使用注解@FunctionalInterface检查是否为函数式接口。 1234@FunctionalInterfacepublic interface MyPredicat &lt;T&gt;&#123; public boolean test(T t);&#125; 函数式接口示例1.定义一个函数式接口1234@FunctionalInterfacepublic interface MyFun &#123; public Integer getValue(Integer num);&#125; 2.定义一个方法，方法的参数为函数式接口123public Integer operation(Integer num,MyFun mf)&#123; return mf.getValue(num); &#125; 3.使用Lambda表达式12345@Testpublic void test5()&#123; Integer num = operation(100,(x)-&gt; x*x); System.out.println(num);&#125; Lambda表达式左侧是函数式接口的参数，右侧是函数式接口的实现。 Lambda练习练习一将集合中的员工排序，按照年龄从小到大排序，如果年龄相同就按照名称排序 123456789101112131415161718192021public class TestLambda &#123; List&lt;Employee&gt; emps = Arrays.asList( new Employee(\"张三\",13,9999.99), new Employee(\"李四\",67,444.44), new Employee(\"王五\",45,55.55), new Employee(\"赵六\",45,6666.66) ); @Test public void test1()&#123; Collections.sort(emps,(e1,e2) -&gt; &#123; if(e1.getAge() == e2.getAge())&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return Integer.compare(e1.getAge(),e2.getAge()); &#125; &#125;); for(Employee emp:emps)&#123; System.out.println(emp); &#125; &#125;&#125; 练习二对字符串进行处理 1.申明一个函数式接口，用于处理字符串1234@FunctionalInterfacepublic interface MyFunction &#123; public String getValue(String str);&#125; 2.申明一个处理字符串的方法，返回处理后的结果123public String strHandle(String str,MyFunction mf)&#123; return mf.getValue(str);&#125; 3.调用处理方法，使用Lambda表达式实现字符串的不同处理123456789101112@Testpublic void test2()&#123; //将传入的字符串做去除空格处理 String trimStr = strHandle(\" \\t\\t\\t\\tHello Word\",(str) -&gt; str.trim()); System.out.println(trimStr); //将传入的字符串做大写转换处理 String uper = strHandle(\"abce\",(str) -&gt; str.toUpperCase()); System.out.println(uper); //将传入的字符串做截取处理 String subStr = strHandle(\"我要好好学习，成为一个大神\",(str) -&gt; str.substring(1,5)); System.out.println(subStr);&#125; 练习三计算两个long型参数做处理 1.声明一个函数式接口1234@FunctionalInterfacepublic interface MyFunction2 &lt;T,R&gt;&#123; public R getValue(T t1,T t2);&#125; 2.定义处理方法123public void operator(Long l1,Long l2,MyFunction2&lt;Long,Long&gt; mf)&#123; System.out.println(mf.getValue(l1,l2));&#125; 3.使用Lambda表达式12345@Testpublic void test4()&#123; operator(100L,200L,(x,y) -&gt; x+y); operator(100L,200L,(x,y) -&gt; x*y);&#125; lambda表达式总结从上述代码中，我们可以看出Lambda表达式的好处，但是我们会发现，每次使用都会新建一个函数式接口，增加了很多麻烦，所以，Java8给我们增加了很多函数式接口， 四大核心函数接口 Consumer消费型接口： 参数类型 T 返回类型 void 对类型T的对象应用操作 Supplier供给型接口： 参数类型 无 返回类型 T 返回类型为T的对象 Function&lt;T,R&gt;函数型接口： 参数类型 T 返回类型 R 对了类型为T的对象应用操作，并返回结果 Predicate断言型接口： 参数类型 T 返回类型 boolean 确定类型为T的对象是否满足某约束，并返回布尔值。 Consumer示例1234567@Testpublic void test1()&#123; happy(10000,(m) -&gt; System.out.println(\"购买笔记本电脑，每次消费\"+m+\"元\"));&#125;public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; Supplier示例123456789101112131415@Testpublic void test2()&#123; List&lt;Integer&gt; list = getNumList(10, () -&gt; (int)(Math.random()*100)); for(Integer num: list)&#123; System.out.println(num); &#125;&#125;public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;num ; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; 上述使用Lambda表达式就是产生10个100以内的随机数。 Function示例12345678@Testpublic void test3()&#123; String upperStr = strHandle(\"abce\",(str) -&gt; str.toUpperCase()); System.out.println(upperStr);&#125;public String strHandle(String str, Function&lt;String,String&gt; fun)&#123; return fun.apply(str);//对str进行处理，具体处理方式调用的时候使用Lambda表达式指定&#125; Predicate示例将满足条件的字符串添加到集合中 123456789101112131415161718@Testpublic void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"Hello\",\"www.baidu.com\",\"zhangsan\",\"lisi\"); List&lt;String&gt; strList = filterStr(list,(s) -&gt; s.length() &gt; 4); for(String str: strList)&#123; System.out.println(str); &#125;&#125;public List&lt;String&gt; filterStr(List&lt;String&gt; list , Predicate&lt;String&gt; per)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str: list) &#123; if(per.test(str))&#123;//对str进行过滤操作，具体操作调用的时候才执行 strList.add(str); &#125; &#125; return strList;&#125; 函数接口总结 Consumer消费型是传入一个参数，进行处理 Supplier供给型是得到一些结果 Function函数型是传入一个参数，处理后返回一个结果 Predicate断言型就是做一些判断操作 有无参数和返回值是指Predicate per等调用的方法需不需要参数和有无返回值，例如：per.test(str)、fun.apply(str)、sup.get()等。 方法引用当要传递给Lambda体的操作，已经有了实现的方法，可以使用方法引用.(实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致)。方法引用：使用操作符“::”将方法名和对象或类的名字分割开，例如： 对象::实例方法 类::静态方法 类::实例方法 对象::实例方法示例1234567@Testpublic void test1()&#123; //注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 Consumer&lt;String&gt; com = (x) -&gt; System.out.println(x); PrintStream ps = System.out; Consumer&lt;String&gt; con = ps::println;&#125; 例如打印一个字符串： 12345@Testpublic void test1()&#123; Consumer&lt;String&gt; con = System.out::println; con.accept(\"Hello Word\");&#125; 注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 类::静态方法方法引用的实质就是使用更简单的方式代替Lambda表达式。下述代码就是类::静态方法的一个实例。 123456@Testpublic void test2()&#123; Comparator&lt;Integer&gt; con = (x,y) -&gt; Integer.compare(x,y); //上述代码中Lambda表达体中的compare方法已经被实现，可以简写为 Comparator&lt;Integer&gt; con1 = Integer::compare;&#125; 类::实例方法如下123456@Testpublic void test3()&#123; BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); //上述代码简写为 BiPredicate&lt;String,String&gt; bp2 = String::equals;&#125; 构造器引用12345678@Testpublic void test4()&#123; Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); //构造器引用 Supplier&lt;Employee&gt; sup2 = Employee::new; Employee employee = sup.get(); System.out.println(employee.getName());&#125; 其中构造器方法调用哪一个构造器取决与接口Supplier中的方法参数，Supplier就是调用的无参构造器，例如Function函数接口就是传入一个参数，并返回一个结果。如下 12345678@Testpublic void test5()&#123; Function&lt;String,Employee&gt; fun = (x) -&gt; new Employee(x); //构造器引用 Function&lt;String,Employee&gt; fun2 = Employee::new; Employee emp = fun2.apply(\"王五\"); System.out.println(emp);&#125; Function&lt;String,Employee&gt;中的String是传入参数类型，Employee是返回结果类型。如果我们想传入两个参数，并返回一个结果，就必须要在Employee中创建两个含两个参数的构造器，如下 123456@Testpublic void test6()&#123; BiFunction&lt;String,Integer,Employee&gt; fun = Employee::new; Employee emp = fun.apply(\"赵六\",123); System.out.println(emp);&#125; 注意：Employee中构造器参数列表和接口中的方法fun.apply(“赵六”,123);参数列表保持一致。 数组引用数组引用格式type[]::new 123456@Testpublic void test7()&#123; Function&lt;Integer,String[]&gt; fun = (x) -&gt; new String[x]; String[] str= fun.apply(10); System.out.println(str.length);&#125; 上述代码就是使用Lambda表达式传入一个数组大小，从而创建一个指定大小和类型的数组。使用数组引用为： 123Function&lt;Integer,String[]&gt; fun2 = String[]::new;String[] str2 = fun2.apply(10);System.out.println(str2.length); StreamAPIStream简介Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行测操作，可以执行非常复杂的查找，过滤和映射数据的操作，使用Stream API对集合数据进行操作就类似于使用SQL执行的数据库查询查询，Stream API提供了一种高效且易于使用的处理数据的方式。流（Stream）是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列，“集合讲的是数据，流讲的是计算”，需要注意的是以下三点 Stream自己不会存储元素 Stream不会改变源对象，相会，他们会返回一个持有结果的新的Stream Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。 Stream使用方法 创建Stream：一个数据源（集合、数组）获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作：一个终止操作，执行中间操作链，并产生结果。 创建Stream的方法 通过Collection系列提供的stream()或parallelStream()，如下： 通过Arrays中的静态方法stream()方法获取流 通过Stream类中的静态方法of() 创建无限流 创建Stream的方法示例12345678910111213141516171819202122232425@Testpublic void test1()&#123; // 1.通过Collection系列提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); // 2.通过Arrays中的静态方法stream()方法获取流 Employee[] emps = new Employee[10]; Stream&lt;Employee&gt; stream1 = Arrays.stream(emps); // 3.通过Stream类中的静态方法of() Stream&lt;String&gt; stream2 = Stream.of(\"AA\",\"BB\",\"CC\"); // 4.创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0,(x) -&gt; x+2); //只要前10个（中间操作） stream3.limit(10).forEach(System.out::println); //打印了所有的中间流操作 //stream3.forEach(System.out::println); //4.2生成 Stream.generate(() -&gt; Math.random()) .limit(10) .forEach(System.out::println);&#125; 中间操作 filter—-接受lambda,从流中排除某一些元素 limit—-截断流，使其元素不超过给定的数量 skip(n)—-跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流 distinct—-筛流，通过流生成元素的hashcode()和equals()去除重复元素 filter示例1234567891011@Testpublic void test1()&#123; //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; &#123; System.out.println(\"中间操作\"); return e.getAge() &gt; 16; &#125;); //终止操作 stream.forEach(System.out::println);&#125; 惰性求值和内部迭代 如果没有终止操作，是不会打印中间操作的，这就是流只有需要结果的时候才会被调用，这就是惰性求值。 上述打印是Stream自己给我们迭代输出的，这个就是内部迭代。 筛选和切片示例如下1234567891011@Testpublic void test1()&#123; //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; e.getAge() &gt; 15) .limit(4) .skip(1) .distinct(); //终止操作 stream.forEach(System.out::println);&#125; 说明：由于distinct是根据hashcode()和equals()去重，所以Employee中要重写equals和hashCode方法。 映射 map(Function f) 接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 map示例1234567891011@Testpublic void test2()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println);System.out.println(\"================\"); employees.stream() .map(Employee::getName) .forEach(System.out::println);&#125; flatMap示例123456789101112131415@Testpublic void test3()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); Stream&lt;Character&gt; sm = list.stream() .flatMap(TestMiddle::filterCharacter); sm.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(Character ch: str.toCharArray())&#123; list.add(ch); &#125; return list.stream();&#125; 排序sorted()-自然排序（comparable）12345678@Test public void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"ccc\",\"aaa\",\"bbb\",\"eee\"); list.stream() .sorted() .forEach(System.out::println); &#125;&#125; sorted(Comparator com)-定制排序（Comparator）1234567891011@Testpublic void test5()&#123; employees.stream() .sorted((e1,e2) -&gt; &#123; if(e1.getAge().equals(e2.getAge()))&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e2.getAge().compareTo(e2.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作终止操作会从流的流水线生成结果，该结果可以是任何不是流的值，例如：List、Integer、void。 查找和匹配 allMatch(Predicate p) 检查是否匹配所有的元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有的元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素个数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestStreamAPI &#123; List&lt;Employee&gt; employees = Arrays.asList( new Employee(\"张三\",16,9999.99, Employee.Status.FREE), new Employee(\"李四\",18,8888.99, Employee.Status.VOCATION), new Employee(\"王五\",20,7777.99, Employee.Status.BUSY), new Employee(\"赵六\",22,6666.99, Employee.Status.FREE), new Employee(\"田七\",24,5555.99, Employee.Status.BUSY), new Employee(\"小八\",26,4444.99, Employee.Status.VOCATION), new Employee(\"陈九\",28,3333.99, Employee.Status.VOCATION), new Employee(\"王五\",32,9999.99, Employee.Status.BUSY), new Employee(\"王五\",34,9999.99, Employee.Status.FREE), new Employee(\"王五\",36,9999.99, Employee.Status.BUSY) ); @Test public void test1()&#123; //检查是否所有的状态为BUSY状态 Boolean b1 = employees.stream() .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否至少匹配一个元素 Boolean b2 = employees.stream() .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否没有匹配元素 Boolean b3 = employees.stream() .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //先按照工资排序，再去除第一个元素放在Option容器中 Optional&lt;Employee&gt; op = employees.stream() .sorted((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())) .findFirst(); System.out.println(op.get()); //findAny返回当前流中的任意元素，先过滤再返回一个， //mployees.stream()实现的是串行流，每次返回的值一定的。 //employees.parallelStream()实现的是并行流 ，返回的就是满足条件的随机结果。 Optional&lt;Employee&gt; op2 = employees.parallelStream() .filter((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)) .findAny(); System.out.println(op2.get()); //返回流中元素个数 Long count = employees.stream() .count(); //返回流中最大值 Optional&lt;Employee&gt; op1 = employees.stream() .max((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())); System.out.println(op1.get()); //返回流中最低工资 Optional&lt;Double&gt; op3 = employees.stream() .map(Employee::getSalay) .min(Double::compare); System.out.println(op3.get()); &#125;&#125; 归约reduce(T iden,BinaryOperator b)可以将流中元素反复结合起来，得到一个值，返回T,示例如下： 123456789101112@Testpublic void test2()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0,(x,y) -&gt; x+y); System.out.println(sum); //计算工资的总和 Optional&lt;Double&gt; op = employees.stream() .map(Employee::getSalay) .reduce(Double::sum); System.out.println(op.get());&#125; 上述代码中使用map得到所有的工资，再有reduce将所有的工资累加，map和reduce配合使用情况比较多。 收集collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。Colletor接口中的方法实现决定了如何对流执行收集操作（如收集到List，Set,Map）,但是Collectors实用类提供了很多静态的方法，可以方便的创建常用收集器实例，具体方法与实例如下： toList 返回List 将流中元素搜集到List toSet 返回Set 将流中元素手机到Set toCollection 返回Collection 把流中元素收集到创建的集合中 counting 返回Long 计算流中元素的个数 summinglnt 返回Integer 对流中元素的整数属性求和 averaginglnt 返回Double 计算流中元素Integer属性的平均值 summarizinglnt 返回IntSummaryStatistics 计算流中Integer属性的统计值，如平均值。 joining 返回String 连接流中每一个字符串 maxBy 返回Optional 根据比较器选择最大值 minBy 返回Optional 根据比较器选择最小值 reducing 归约产生的类型 collectionAndThen 转换函数返回的类型 实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Testpublic void test3()&#123; //将名字添加到list中 List&lt;String&gt; list = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); //将名字添加到Set中 Set&lt;String&gt; set = employees.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); //将名字添加到特定的数据结构中 HashSet&lt;String&gt; hashSet = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); //总数 Long count = employees.stream() .collect(Collectors.counting()); //平均数 Double avg = employees.stream() .collect(Collectors.averagingDouble(Employee::getSalay)); //总和 Double sum = employees.stream() .collect(Collectors.summingDouble(Employee::getSalay)); //最大值，返回工资最大的员工信息 Optional&lt;Employee&gt; max = employees.stream() .collect(Collectors.maxBy((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay()))); //最小值，返回最小工资 Optional&lt;Double&gt; min = employees.stream() .map(Employee::getSalay) .collect(Collectors.minBy(Double::compare)); //按照状态分组 Map&lt;Employee.Status,List&lt;Employee&gt;&gt; map = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus)); map.get(Employee.Status.BUSY); //多级分组 Map&lt;Employee.Status,Map&lt;String,List&lt;Employee&gt;&gt;&gt; map1 = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus,Collectors.groupingBy((e) -&gt;&#123; if(((Employee)e).getAge() &lt;= 18)&#123; return \"少年\"; &#125;else if(((Employee)e).getAge() &lt;= 26)&#123; return \"中年\"; &#125;else&#123; return \"老年\"; &#125; &#125;))); System.out.println(map1); //分区。满足条件一个区，不满足条件的一个区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map2 = employees.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalay() &gt;5000)); System.out.println(map2); //其他的一种获取方式 DoubleSummaryStatistics dss = employees.stream() .collect(Collectors.summarizingDouble(Employee::getSalay)); System.out.println(dss.getSum()); System.out.println(dss.getAverage()); System.out.println(dss.getMax()); //连接字符串 String str = employees.stream() .map(Employee::getName) .collect(Collectors.joining(\",\",\"====\",\"===\"));&#125; StreamAPI练习1.给定一个数字列表，返回一个由每一个数的平方构成的列表。12345678@Testpublic void test()&#123; Integer[] nums = new Integer[]&#123;1,2,3,4,5&#125;; Arrays.stream(nums) .map((x) -&gt; x*x) .forEach(System.out::println);&#125; 2.使用map和reduce方法数一数流中有多少个Employee1234567@Testpublic void test1()&#123; Optional&lt;Integer&gt; count = employees.stream() .map((e) -&gt; 1) .reduce(Integer::sum); System.out.println(count.get());&#125; 交易员类1234567891011121314151617181920212223242526272829303132333435public class Trader &#123; private String name; private String city; public Trader() &#123; &#125; public Trader(String name, String city) &#123; this.name = name; this.city = city; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; @Override public String toString() &#123; return \"Trader [name=\" + name + \", city=\" + city + \"]\"; &#125;&#125; 交易类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Transaction &#123; private Trader trader; private int year; private int value; public Transaction() &#123; &#125; public Transaction(Trader trader, int year, int value) &#123; this.trader = trader; this.year = year; this.value = value; &#125; public Trader getTrader() &#123; return trader; &#125; public void setTrader(Trader trader) &#123; this.trader = trader; &#125; public int getYear() &#123; return year; &#125; public void setYear(int year) &#123; this.year = year; &#125; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Transaction [trader=\" + trader + \", year=\" + year + \", value=\" + value + \"]\"; &#125;&#125; 练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class TestTransaction &#123; List&lt;Transaction&gt; transactions = null; @Before public void before()&#123; Trader raoul = new Trader(\"Raoul\", \"Cambridge\"); Trader mario = new Trader(\"Mario\", \"Milan\"); Trader alan = new Trader(\"Alan\", \"Cambridge\"); Trader brian = new Trader(\"Brian\", \"Cambridge\"); transactions = Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); &#125; //1. 找出2011年发生的所有交易， 并按交易额排序（从低到高） @Test public void test1()&#123; transactions.stream() .filter((t) -&gt; t.getYear() == 2011)//过滤2011年的交易 .sorted((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())) .forEach(System.out::println); &#125; //2. 交易员都在哪些不同的城市工作过？ @Test public void test2()&#123; transactions.stream() .map((t) -&gt; t.getTrader().getCity()) .distinct() .forEach(System.out::println); &#125; //3. 查找所有来自剑桥的交易员，并按姓名排序 @Test public void test3()&#123; new ArrayList&lt;Integer&gt;(); transactions.stream() .filter((t) -&gt; t.getTrader().getCity().equals(\"Cambridge\")) .map(Transaction::getTrader) .sorted((t1,t2) -&gt; t1.getName().compareTo(t2.getName())) .distinct() .forEach(System.out::println); &#125; //4. 返回所有交易员的姓名字符串，按字母顺序排序 @Test public void test4()&#123; transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .forEach(System.out::println); System.out.println(\"====================================\"); String str = transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .reduce(\"\",String::concat); System.out.println(str); &#125; //5. 有没有交易员是在米兰工作的？ @Test public void test5()&#123; Boolean b1 = transactions.stream() .anyMatch((t) -&gt; t.getTrader().getCity().equals(\"Milan\")); System.out.println(b1); &#125; //6. 打印生活在剑桥的交易员的所有交易额 @Test public void test6()&#123; Optional&lt;Integer&gt; sum = transactions.stream() .filter((e) -&gt; e.getTrader().getCity().equals(\"Cambridge\")) .map(Transaction::getValue) .reduce(Integer::sum); System.out.println(sum.get()); &#125; //7. 所有交易中，最高的交易额是多少 @Test public void test7()&#123; Optional&lt;Integer&gt; max = transactions.stream() .map((t) -&gt; t.getValue()) .max(Integer::compare); System.out.println(max); &#125; //8. 找到交易额最小的交易 @Test public void test8()&#123; Optional&lt;Transaction&gt; op = transactions.stream() .min((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())); System.out.println(op.get()); &#125;&#125; LocalDateTimeLocalDateTime是一个不可变的日期时间对象，代表日期时间，通常被视为年 - 月 - 日 - 时 - 分 - 秒。 方法摘要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687Temporal adjustInto(Temporal temporal) 调整指定的时间对象与此对象具有相同的日期和时间。 OffsetDateTime atOffset(ZoneOffset offset) 将此日期时间与偏移量相结合以创建 OffsetDateTime 。 ZonedDateTime atZone(ZoneId zone) 将此日期时间与时区相结合以创建 ZonedDateTime 。 int compareTo(ChronoLocalDateTime&lt;?&gt; other) 将此日期时间与其他日期时间进行比较。 boolean equals(Object obj) 检查这个日期时间是否等于另一个日期时间。 String format(DateTimeFormatter formatter) 使用指定的格式化程序格式化此日期时间。 static LocalDateTime from(TemporalAccessor temporal) 从时间对象获取一个 LocalDateTime的实例。 int get(TemporalField field) 从此日期时间获取指定字段的值为 int 。 int getDayOfMonth() 获取月份字段。 DayOfWeek getDayOfWeek() 获取星期几字段，这是一个枚举 DayOfWeek 。 int getDayOfYear() 获得日期字段。 int getHour() 获取时间字段。 long getLong(TemporalField field) 从此日期时间获取指定字段的值为 long 。 int getMinute() 获取小时字段。 Month getMonth() 使用 Month枚举获取月份字段。 int getMonthValue() 将月份字段从1到12。 int getNano() 获得纳秒第二场。 int getSecond() 获得第二分钟的字段。 int getYear() 获取年份字段。 int hashCode() 这个日期时间的哈希码。 boolean isAfter(ChronoLocalDateTime&lt;?&gt; other) 检查这个日期时间是否在指定的日期之后。 boolean isBefore(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否在指定的日期时间之前。 boolean isEqual(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否等于指定的日期时间。 boolean isSupported(TemporalField field) 检查指定的字段是否受支持。 boolean isSupported(TemporalUnit unit) 检查指定的单位是否受支持。 LocalDateTime minus(long amountToSubtract, TemporalUnit unit) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minus(TemporalAmount amountToSubtract) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minusDays(long days) 返回此 LocalDateTime的副本，其中指定的时间间隔以天为单位。 LocalDateTime minusHours(long hours) 以指定的时间段返回此 LocalDateTime的副本，以减少的小时数。 LocalDateTime minusMinutes(long minutes) 返回此 LocalDateTime的副本，以指定的时间间隔减去。 LocalDateTime minusMonths(long months) 返回此 LocalDateTime的副本，指定的时间以月为单位减去。 LocalDateTime minusNanos(long nanos) 返回这个 LocalDateTime的副本，以指定的时间减去纳秒。 LocalDateTime minusSeconds(long seconds) 返回此 LocalDateTime的副本，其中指定的时间间隔以秒为单位。 LocalDateTime minusWeeks(long weeks) 返回此 LocalDateTime的副本，其中指定的周期以周为单位减去。 LocalDateTime minusYears(long years) 返回此 LocalDateTime的副本，并以减去的年份为单位。 static LocalDateTime now() 从默认时区的系统时钟获取当前的日期时间。 static LocalDateTime now(Clock clock) 从指定的时钟获取当前的日期时间。 static LocalDateTime now(ZoneId zone) 从指定时区的系统时钟获取当前的日期时间。static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得LocalDateTime的实例，将第二和纳秒设置为零。static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) 获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得 LocalDateTime的实例，将第二和纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(LocalDate date, LocalTime time) 从日期和时间获取 LocalDateTime一个实例。 static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) 使用从1970-01-01T00：00：00Z的时代开始的秒数获得一个 LocalDateTime的实例。 static LocalDateTime ofInstant(Instant instant, ZoneId zone) 从 Instant和区域ID获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text) 从一个文本字符串（如 2007-12-03T10:15:30获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) 使用特定的格式化 LocalDateTime从文本字符串获取 LocalDateTime的实例。 LocalDateTime plus(long amountToAdd, TemporalUnit unit) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plus(TemporalAmount amountToAdd) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plusDays(long days) 返回此 LocalDateTime的副本，并以指定的时间段添加天数。 LocalDateTime plusHours(long hours) 以指定的时间（以小时为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMinutes(long minutes) 以指定的时间（以分钟为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMonths(long months) 返回这个 LocalDateTime的副本，其中指定的时间段以月为单位。 LocalDateTime plusNanos(long nanos) 返回这个 LocalDateTime的副本，其指定时间以纳秒为单位。 LocalDateTime plusSeconds(long seconds) 以指定的时间段返回此 LocalDateTime的副本，以秒为单位。 LocalDateTime plusWeeks(long weeks) 返回这个 LocalDateTime的副本，并以指定的周期添加周数。 LocalDateTime plusYears(long years) 返回这个 LocalDateTime的副本，其中指定的时间段以添加的年数表示。 &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) 使用指定的查询查询此日期时间。 ValueRange range(TemporalField field) 获取指定字段的有效值的范围。 LocalDate toLocalDate() 获得这个日期时间的 LocalDate一部分。 LocalTime toLocalTime() 获得这个日期时间的 LocalTime一部分。 String toString() 将此日期时间输出为 String ，例如 2007-12-03T10:15:30 。 LocalDateTime truncatedTo(TemporalUnit unit) 返回此 LocalDateTime的副本， LocalDateTime时间。 long until(Temporal endExclusive, TemporalUnit unit) 根据指定的单位计算到另一个日期时间的时间量。 LocalDateTime with(TemporalAdjuster adjuster) 返回此日期时间的调整副本。 LocalDateTime with(TemporalField field, long newValue) 返回此日期时间的副本，并将指定的字段设置为新值。 LocalDateTime withDayOfMonth(int dayOfMonth) 返回此 LocalDateTime的副本。 LocalDateTime withDayOfYear(int dayOfYear) 返回这个 LocalDateTime的副本，并更改日期。 LocalDateTime withHour(int hour) 返回此日期值更改的 LocalDateTime的副本。 LocalDateTime withMinute(int minute) 返回这个 LocalDateTime的副本，小时值更改。 LocalDateTime withMonth(int month) 返回此年份更改的 LocalDateTime的副本。 LocalDateTime withNano(int nanoOfSecond) 返回这个 LocalDateTime的副本，纳秒变化值。 LocalDateTime withSecond(int second) 返回这个 LocalDateTime的副本，其中 LocalDateTime了第二分钟的值。 LocalDateTime withYear(int year) 返回这个 LocalDateTime的副本，年份被更改。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Mysql学习总结","slug":"JavaEE基础知识学习-----Mysql学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T11:57:24.843Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习-----Mysql学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习-----Mysql学习总结/","excerpt":"数据库简介数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 数据库相关概念 DB：数据库，保存一组有组织的数据的容器 DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 SQL:结构化查询语言，用于和DBMS通信的语言","text":"数据库简介数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 数据库相关概念 DB：数据库，保存一组有组织的数据的容器 DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 SQL:结构化查询语言，用于和DBMS通信的语言 数据库存储特点 将数据放到表中，表再放到库中 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。 表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性” 表中的数据是按行存储的，每一行类似于java中的“对象”。 Mysql常用命令查看当前所有的数据库 1show databases; 打开指定的库 1use 库名 查看当前库的所有表 1show tables; 查看其它库的所有表 1show tables from 库名; 创建表 1234create table 表名( 列名 列类型, 列名 列类型 ); 查看表结构 1desc 表名; Mysql语法规范 不区分大小写,但建议关键字大写，表名、列名小写 每条命令最好用分号结尾 每条命令根据需要，可以进行缩进 或换行 注释 单行注释：#注释文字 单行注释：– 注释文字 多行注释：/ 注释文字 / SQL语言分类 DQL（Data Query Language）：数据查询语言，例如：select DML(Data Manipulate Language):数据操作语言，例如：insert 、update、delete DDL（Data Define Languge）：数据定义语言，例如：create、drop、alter TCL（Transaction Control Language）：事务控制语言，例如：commit、rollback DQL语言学习基础查询语法 12SELECT 要查询的东西【FROM 表名】; 特点 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据 语法 123456select 要查询的字段|表达式|常量值|函数from 表where 条件 ; 分类 条件表达式，例如：salary&gt;10000，条件运算符：&gt; &lt; &gt;= &lt;= = != &lt;&gt; 逻辑表达式，例如：salary&gt;10000 &amp;&amp; salary&lt;20000，逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true 模糊查询，例如：last_name like ‘a%’ 排序查询语法 1234567select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 常见函数字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数 数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断 日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符 流程控制函数 if 处理双分支 case语句 处理多分支情况1：处理等值判断 情况2：处理条件判断 分组函数 sum 求和 max 最大值 min 最小值 avg 平均值 count 计数 分组函数说明 以上五个分组函数都忽略null值，除了count(*) sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持：字段、*、常量值，一般放1 分组查询语法 123select 查询的字段，分组函数from 表group by 分组的字段 分组查询特点 可以按单个字段分组 和分组函数一同查询的字段最好是分组后的字段 分组筛选 分组前筛选： 原始表 group by的前面 where 分组后筛选： 分组后的结果集 group by的后面 having 可以按多个字段分组，字段之间用逗号隔开 可以支持排序 having后可以支持别名 多表查询语法 12345678select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 子查询子查询含义 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 子查询特点 子查询都放在小括号内 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧 子查询优先于主查询执行，主查询使用了子查询的执行结果 子查询根据查询结果的行数不同分为以下两类 单行子查询：结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= ，非法使用子查询的情况：子查询的结果为一组值或者子查询的结果为空 多行子查询：结果集有多行，一般搭配多行操作符使用：any、all、in、not in，in： 属于子查询结果中的任意一个就行，any和all往往可以用其他查询代替 分页查询语法 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点 起始条目索引从0开始 limit子句放在查询语句的最后 公式：select from 表 limit （page-1）sizePerPage,sizePerPage 联合查询语法 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点 多条查询语句的查询的列数必须是一致的 多条查询语句的查询的列的类型几乎相同 union代表去重，union all代表不去重 DML语言学习插入语法 12insert into 表名(字段名，...)values(值1，...); 特点 字段类型和值类型一致或兼容，而且一一对应 可以为空的字段，可以不用插入值，或用null填充 不可以为空的字段，必须插入值 字段个数和值的个数必须一致 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法 12update 表名 set 字段=新值,字段=新值【where 条件】 修改多表语法 1234update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件 删除单表删除 1delete from 表名 【where 筛选条件】 多表删除 1234delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 使用truncate语句删除 1truncate table 表名 delelte和truncate区别 truncate不能加where条件，而delete可以加where条件 truncate的效率高一丢丢 truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始 delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 truncate删除不能回滚，delete删除可以回滚 DDL语言学习库和表管理库的管理 1234--创建库create database 库名--删除库drop database 库名 表的管理 123456789101112131415161718192021--创建表CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;--修改表 alterALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;--修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;--修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;--修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;--添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;--删除字段ALTER TABLE studentinfo DROP COLUMN email;--删除表DROP TABLE [IF EXISTS] studentinfo; 数据库事务概念通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点 A：原子性：要么都执行，要么都回滚 C：一致性：保证数据的状态操作前和操作后保持一致 I：隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 D：持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 使用事务步骤 开启事务 编写事务的一组逻辑操作单元（多条sql语句） 提交事务或回滚事务 事务分类隐式事务，没有明显的开启和结束事务的标志 例如：insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 12345671、开启事务 取消自动提交事务的功能 2、编写事务的一组逻辑操作单元（多条sql语句） insert update delete 3、提交事务或回滚事务 关键字1234567set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别当多个事务同时操作同一个数据库的相同数据时就会产生事务并发问题，常见的事务并发问题有如下几种 脏读：一个事务读取到了另外一个事务未提交的数据 不可重复读：同一个事务中，多次读取到的数据不一致 如何避免事务的并发问题 通过设置事务的隔离级别 READ UNCOMMITTED READ COMMITTED 可以避免脏读 REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读 SERIALIZABLE可以避免脏读、不可重复读和幻读 如何设置事务的隔离级别 1set session|global transaction isolation level 隔离级别名; 如何查看事务的隔离级别 1select @@tx_isolation; 视图视图可以理解为一张虚拟的表，视图和表的区别如下 使用方式 占用物理空间 视图 完全相同 不占用，仅保存的是SQL逻辑 表 完全相同 占用 使用视图的好处 sql语句提高重用性，效率高 和表实现了分离，提高了安全性 视图的创建123CREATE VIEW 视图名AS查询语句; 视图操作123456789--查看视图的数据 SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners';--插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);--修改视图的数据UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';--删除视图的数据DELETE FROM my_v4; 不能更新的视图 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all 常量视图 Select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表 视图删除1DROP VIEW test_v1,test_v2,test_v3; 查看视图结构12DESC test_v7;SHOW CREATE VIEW test_v7; 存储过程存储过程：一组经过预先编译的sql语句的集合 使用存储过程的好处 提高了sql语句的重用性，减少了开发程序员的压力 提高了效率 减少了传输次数 存储过程分类 无返回无参 仅仅带in类型，无返回有参 仅仅带out类型，有返回无参 既带in又带out，有返回有参 带inout，有返回有参 注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程1234create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 注意 1234567891011CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $-- 存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end-- 参数前面的符号的意思 -- in:该参数只能作为输入 （该参数不能做返回值） -- out：该参数只能作为输出（该参数只能做返回值） -- inout：既能做输入又能做输出 调用存储过程1call 存储过程名(实参列表)","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE日常工作经验总结系列（二）-----代码规范","slug":"JavaEE日常工作经验总结系列（二）-----代码规范","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:08:11.005Z","comments":true,"path":"2019/03/22/JavaEE日常工作经验总结系列（二）-----代码规范/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE日常工作经验总结系列（二）-----代码规范/","excerpt":"2018.06.15代码规范总结 控制层的方法体尽可能小，数据处理代码放在业务处理层 拒绝代码中出现魔法数字，使用常量的形式 字符串使用StringUtils工具类判空 集合list使用CollectionUtils工具类进行判空 遍历Map使用entrySet，避免使用keySet 注意代码的缩进格式，是否进行的格式化","text":"2018.06.15代码规范总结 控制层的方法体尽可能小，数据处理代码放在业务处理层 拒绝代码中出现魔法数字，使用常量的形式 字符串使用StringUtils工具类判空 集合list使用CollectionUtils工具类进行判空 遍历Map使用entrySet，避免使用keySet 注意代码的缩进格式，是否进行的格式化","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习-----Mybatis知识总结","slug":"JavaEE进阶知识学习-----Mybatis知识总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T11:59:46.510Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习-----Mybatis知识总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习-----Mybatis知识总结/","excerpt":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录.","text":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. Mybatis与其他持久化方式对比 MyBatis是一个半自动化的持久化框架 JDBC是SQL夹在Java代码中，耦合度高导致硬编码，维护不易且实际开发中SQL会经常变化 Hibernate和JPA是内部自动产生的SQL语句，不容易做特殊优化，长而复杂的SQL，hibernate处理也不容易，是基于全映射的全自动化框架，大量子弹的pojo进行部分映射比较困难，导致数据库性能下降 对于开发人员，核心SQL需要自己优化，所以需要SQL和java编码分开，功能界面明显，一个专注业务，一个专注数据 文档资料下载地址：https://github.com/mybatis/mybatis-3 中文文档：http://www.mybatis.org/mybatis-3/zh/index.html MyBatis的HelloWord概述随着Maven的流行，现在几乎很少有使用jar的方式来搭建开发环境，这里也就不在单个使用Mybatis去操作数据库，不会的可以自行百度，MyBatis只是一个持久化框架，只有和其他框架整合才能更好的使用，例如SpringMVC，SpringBoot等，与Spring整合后，Mybatis的一些配置文件都会交于Spring管理。 MyBatis的全局配置文件概述MyBatis的全局配置文件可以配置的属性如下 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 properties属性MyBatis使用properties来引入外部properties配置文件的内容，resource：引入类路径下的资源，url引入网络路径或者磁盘路径下的资源。可以用于将数据源连接信息放在properties文件中，与Spring整合后就写在Spring的配置文件中。 引入外部properties文件 1&lt;properties resource=\"org/mybatis/example/config.properties\"&gt;&lt;/properties&gt; 使用引入的properties文件 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; settings运行时设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。 设置参数 描述 有效值 默认值 cacheEnabled 全局开启或关闭配置文件中的所有映射器任何缓存 true \\ false true lazyLoadingEnabled 延迟加载的全局开关 true \\ false false aggressiveLazyLoading 开启，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 true \\ false false multipleResultSetsEnabled 是否允许单一语句返回多结果集 true \\ false true useColumnLabel 使用列标签代替列名。 true \\ false true useGeneratedKeys 允许 JDBC 支持自动生成主键 如果设置为 true 则这个设置强制使用自动生成主键 true \\ false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出提醒 NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 任意正整数 defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 任意正整数 safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。 true \\ false False safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。 true \\ false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true \\ false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION \\ STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始) callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 true \\ false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始） true \\ false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象用到的代理工具。 CGLIB \\ JAVASSIST 常用的Setting设置 设置参数 描述 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名规则映射A_COLUNM到aColumn false defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 Settings设置示例1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases别名类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余,但是往往我们不会使用别名，是为了方便查看代码。 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，给包和子包下的所有类起一个默认的别名（类名小写） 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。 12@Alias(\"author\")public class Author &#123;&#125; typeHandlers 类型处理器无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 类型处理器 Java类型 JDBC类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SHORT INTEGER IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 LONG INTEGER FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）。 InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR or LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE plugins插件MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments环境配置MyBatis可以配置多种环境，default代表指定使用某种环境，这样就可以快速切换环境，尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一 ，所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例 。每个数据库对应一个 SqlSessionFactory 实例 环境配置实例 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 环境配置说明 默认的环境 ID（比如:default=”development”）。 每个 environment 元素定义的环境 ID（比如:id=”development”）。 事务管理器的配置（比如:type=”JDBC”）。 数据源的配置（比如:type=”POOLED”）。 MyBatis映射文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在 。SQL 映射文件有很少的几个顶级元素 ，如下 cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 Select查询查询语句是 MyBatis 中最常用的元素之一 ，简单查询的 select 元素是非常简单的。比如 123&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 该查询接受一个 int（或 Integer）类型的参数，返回一个 HashMap 类型的对象，键是列名，值是结果行中的对应值。 select 元素有很多属性允许你配置，来决定每条语句的作用细节 ，如下 123456789101112&lt;select id=\"selectPerson\" parameterType=\"int\" parameterMap=\"deprecated\" resultType=\"hashmap\" resultMap=\"personResultMap\" flushCache=\"false\" useCache=\"true\" timeout=\"10000\" fetchSize=\"256\" statementType=\"PREPARED\" resultSetType=\"FORWARD_ONLY\"&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 insert update delete数据变更语句 insert，update 和 delete 的实现非常接近 ,如下 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" keyColumn=\"\" useGeneratedKeys=\"\" timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 属性说明 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 示例 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 多行插入 1234567&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username, password, email, bio) values &lt;foreach item=\"item\" collection=\"list\" separator=\",\"&gt; (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;) &lt;/foreach&gt;&lt;/insert&gt; 自动生成主键 12345&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 映射文件小结 Mybatis允许增删改直接定义的返回值：Integer，Long，Boolean,返回的是改变数据库表的记录数和true和false 支持自动生成主键的字段，设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。 数据库还支持多行插入, 你也可以传入一个数组或集合，并返回自动生成的主键 映射文件参数处理 单个参数：MyBatis不会做特殊处理，#{参数名/任意名}：取出参数值 多个参数：MyBatis会做特殊处理，多个参数被封装为一个map,key：param1…param10或者参数的索引 命名参数，多个参数使用#{param1}来取值导致错乱，故使用命名参数，明确指定封装map的key,如下 1public Person getPerson(@Param(\"id\") Integer id,@Param(\"name\") String laseName); 这个时候在xml文件中可以使用#{id}和#{name}来取值 如果传入多个参数正好是POJO：可以使用#{属性名}直接获取。 如果传入多个参数不是POJO,为了方便，我们可以传入map,如下 1public Person getPerson(Map&lt;String,Object&gt; map); 这个时候也就可以在xml文件中使用#{key}直接取出传入map的key对应的值 如果传入多个参数不是POJO,但是查询频率高，使用map不方便，可以编写一个TO(数据传输对象) 如果传入了一个Collection（list，set）类型或者数组，也会特殊处理，也是吧list或者数组封装到map中，传入的类型不一样，对应的key如下：Collection（collection）,List（list），数组（array）,示例如下 1public Person get(List&lt;Integer&gt; ids); 传入的是一个list集合，在xml文件中，我们如果需要取出list中的第一个元素为：#{list[0]} #和$取值区别 取值的方式#{}是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}:取出的值直接拼装在sql语句中；会有安全问题；大多情况下，我们去参数的值都应该去使用#{}； 原生jdbc不支持占位符的地方我们就可以使用${}进行取值比如分表、排序。；按照年份分表拆分 12select * from $&#123;year&#125;_salary where xxx;select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125; select查询返回类型 返回一个集合：resultType写集合中元素的类型 返回一条记录的map，key为列名，value为列对应的值，例如 1public Map&lt;String ,Object&gt; getPersonByMap(Integer id); 123&lt;select id = \"getPersonByMap\" resultType=\"map\"&gt; select * from person where id = #&#123;id&#125;&lt;/select&gt; 返回多条记录封装的一个map，Map&lt;Integer,Person&gt;:key是这条记录的主键，值是记录封装后的pojo,如下 12@MapKey(\"id\")public Map&lt;Integer,Person&gt; getPersonByName(String name); 123&lt;select id = \"getPersonByName\" resultType=\"com.test.Person\"&gt; select * from person where last_name like #&#123;name&#125;&lt;/select&gt; @MapKey(“id”)注解表示使用那个属性作为返回结果map的key。 resultMap自定义结果集示例 1234567&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt;&lt;/restMap&gt;&lt;select id=\"getPerson\" restMap=\"baseMap\"&gt; select * from person&lt;/select&gt; resultMap关联属性_级联属性封装结果集 例如：员工有部门属性，联合查询返回封装结果 123456&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;result column=\"dept_id\" property=\"dept.id\" &gt;&lt;/result&gt; &lt;result column=\"dept_name\" property=\"dept.name\" &gt;&lt;/result&gt;&lt;/restMap&gt; 使用association指定联合的java对象 12345678&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;/association&gt;&lt;/restMap&gt; 使用collection定义关联集合的封装规则 例如，查询部门的时候，查询出当前部门下的所有员工 12345678&lt;restMap id=\"baseMap\" type=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;collection property=\"persons\" javaType=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;/collection&gt;&lt;/restMap&gt; sql标签这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如： 1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如： 1234567&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;, &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; MyBatis的动态SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 如下 if choose (when, otherwise) trim (where, set) foreach if的使用动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如 注意：在xml文件中特殊符号，像&lt;，&gt;要使用转义字符 12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; choose，when，otherwise有时我们不想应用到所有的条件语句，而只想从中择其一项 ，如下 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim, where, set在前面，如果所有的条件都是动态sql,那么可能会出现一下情况的SQL语句 12SELECT * FROM BLOG WHERESELECT * FROM BLOG WHERE AND title like ‘someTitle’ 出现以上错误的sql语句，MyBatis提供了一种解决方式 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除 。注意：WHERE只会去掉开头第一个AND或OR 使用where会出错的情况，And放在后面 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; AND &lt;/if&gt; &lt;if test=\"title != null\"&gt; title like #&#123;title&#125; AND &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 另外一种解决办法就是使用标签，使用where，也可能造成最后一个and，使用trim方法如下 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ... &lt;/trim&gt; prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容（移除前面多余的AND 或者OR），并且插入 prefix 属性中指定的内容。 使用suffixOverrides会移除后面多余的AND或者OR。 set标签与if结合实现动态更新 12345678910&lt;update id=\"updateAuthorIfNecessary\"&gt; update Author &lt;set&gt; &lt;if test=\"username != null\"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=\"password != null\"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"bio != null\"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号,也可以使用trim，注意这里我们删去的是后缀值，同时添加了前缀值。 123&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; ...&lt;/trim&gt; foreach动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： 123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 说明: collection：指定要遍历的集合 item：将当前遍历的每一个元素赋给指定的变量 separator：每一个元素之间的分隔符 open：遍历出所有的结果拼接一个开始的字符 close：遍历出所有的结果拼接一个结束的字符 index：遍历list的就是索引，遍历map的时候就是map的key,item是map的值 Mysql下的批量插入1public void addEmp(@Param(\"emps\") List&lt;Employee&gt; emps); 1234567&lt;insert id=\"addEmp\"&gt; INSERT into employee(name,age)values &lt;foreach item=\"emp\" index=\"index\" collection=\"emps\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;emp.name&#125;, #&#123;emp.age&#125; &lt;/foreach&gt;&lt;/insert&gt; bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如 12345&lt;select id=\"selectBlogsLike\" resultType=\"Blog\"&gt; &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 如果是模糊查询，使用下面的方式是行不通的，如下 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%#&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之一，可以使用$符号(不安全) 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%$&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之二，使用bind标签 1234567&lt;select&gt; &lt;bind name=\"_lastName\" value=\"'%'+lastName+'%'\"&gt;&lt;/bind&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like #&#123;_lastName&#125; &lt;/if&gt;&lt;/select&gt; 1&lt;bind name=\"_lastName\" value=\"'_'+lastName+'%'\"&gt;&lt;/bind&gt;&lt;!--表示以什么开始，后面是参数的模糊查询--&gt; MyBatis的缓存机制概述MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。MyBatis系统中默认定义了两级缓存，一级缓存和二级缓存。 默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存（本地缓存）与数据库同一次会话期间查询的数据会放在本地缓存中，以后如果需要获取相同数据，直接从缓存中拿，不再查询数据库 一级缓存失效的四种情况 一级缓存是sqlSession级别的缓存，也就说一个sqlSession拥有自己的一级缓存，一级缓存是一直开启的，没有使用一级缓存的情况 不同的sqlSession对应不同的一级缓存 同一个sqlSession,但是查询条件不一样 同一个sqlSession两次查询期间执行了任何一次增删改操作 同一个sqlSession两次查询期间手动清空了缓存 二级缓存（全局缓存） 二级缓存基于namespace默认不开启，需要手动配置 MyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口 二级缓存在SqlSession 关闭或提交之后才会生效 工作机制 一个会话，查询一条数据，这个数据就会放在当前会话的一级缓存中 如果会话关闭，一级缓存中的数据就会保存到二级缓存中，新的查询信息，就参照二级缓存 使用步骤 全局配置文件中开启二级缓存 1&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 需要使用二级缓存的映射文件mapper.xml处使用cache配置缓存 1&lt;cach&gt;&lt;/cach&gt; 注意：POJO需要实现Serializable接口 Mybatis提供了整合ehcache缓存，具体整合方法参考官网文档， MyBatis的逆向工程概述MyBatis Generator：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写 官方文档地址：http://www.mybatis.org/generator/ 官方工程地址：https://github.com/mybatis/generator/releases MBG使用步骤 编写MBG的配置文件（重要几处配置） jdbcConnection配置数据库连接信息 javaModelGenerator配置javaBean的生成策略 sqlMapGenerator配置sql映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置要逆向解析的数据表 tableName：表名 domainObjectName：对应的javaBean名 运行代码生成器生成代码 注意： Context标签targetRuntime=“MyBatis3“可以生成带条件的增删改查targetRuntime=“MyBatis3Simple“可以生成基本的增删改查如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。 MBG配置文件12345678910111213141516171819202122232425&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; //数据库连接信息配置 &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/bookstore0629\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; //javaBean的生成策略 &lt;javaModelGenerator targetPackage=\"com.atguigu.bean\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; //映射文件的生成策略 &lt;sqlMapGenerator targetPackage=\"mybatis.mapper\" targetProject=\".\\conf\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; //dao接口java文件的生成策略 &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.atguigu.dao\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; //数据表与javaBean的映射 &lt;table tableName=\"books\" domainObjectName=\"Book\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 生成器代码1234567891011public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new efaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; QBC风格的带条件查询123456789101112131415@Testpublic void test01()&#123; SqlSession openSession = build.openSession(); DeptMapper mapper = openSession.getMapper(DeptMapper.class); DeptExample example = new DeptExample(); //所有的条件都在example中封装 Criteria criteria = example.createCriteria(); //select id, deptName, locAdd from tbl_dept WHERE //( deptName like ? and id &gt; ? ) criteria.andDeptnameLike(\"%部%\"); criteria.andIdGreaterThan(2); List&lt;Dept&gt; list = mapper.selectByExample(example); for(Dept dept : list) &#123; System.out.println(dept);&#125; Mybatis的插件开发PageHelper分页插件项目地址：https://github.com/pagehelper/Mybatis-PageHelper 文档地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md 使用步骤12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 在 MyBatis 配置 xml 中配置拦截器插件 1234567&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=\"param1\" value=\"value1\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 代码中使用方法12345678910111213141516171819202122232425262728293031323334353637//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 常用方法介绍RowBounds方式的调用 1List&lt;Country&gt; list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页 PageHelper.startPage静态方法调用 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 PageInfo用法 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); Mybatis批量保存在MyBatis的全局设置中有设置，defaultExecutorType 配置默认的执行器 SIMPLE 就是普通的执行器； REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新 但是，如果在全局设置中设置批量执行器，那么每一个mapper中的方法都会执行批量操作，所以我们一般都是在与Spring整合后在Application.xml中配置一个可以执行批量操作的sqlSession,如下 123456789101112&lt;!--创建出SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- configLocation指定全局配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!--mapperLocations: 指定mapper文件的位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"executorType\" value=\"BATCH\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 在Service中自动注入SQLSession 123456@Autowiredprivate SqlSession sqlSession;public List&lt;Employee&gt; getEmps()&#123; EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); return mapper.getEmps();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"前端基础知识学习---JavaScript高级学习总结","slug":"前端基础知识学习---JavaScript高级学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:02:22.914Z","comments":true,"path":"2019/03/22/前端基础知识学习---JavaScript高级学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/前端基础知识学习---JavaScript高级学习总结/","excerpt":"[TOC] JavaScript高级学习笔记基础总结数据类型数据类型分为两类，基本(值)类型（Number: 任意数值，String: 任意文本，Boolean: true/false，undefined: undefined，null: null）和对象类型（Object: 一般对象类型，Array: 特别的对象类型(下标/内部数据有序)，Function: 特别的对象类型(可执行)）。 数据类型的判别方法有typeof，instanceof和===，其中typeof可以区别: 数值, 字符串, 布尔值, undefined, function不能区别: null与对象, 一般对象与数组；instanceof专门用来判断对象数据的类型: Object, Array与Function；===可以判断: undefined和null；","text":"[TOC] JavaScript高级学习笔记基础总结数据类型数据类型分为两类，基本(值)类型（Number: 任意数值，String: 任意文本，Boolean: true/false，undefined: undefined，null: null）和对象类型（Object: 一般对象类型，Array: 特别的对象类型(下标/内部数据有序)，Function: 特别的对象类型(可执行)）。 数据类型的判别方法有typeof，instanceof和===，其中typeof可以区别: 数值, 字符串, 布尔值, undefined, function不能区别: null与对象, 一般对象与数组；instanceof专门用来判断对象数据的类型: Object, Array与Function；===可以判断: undefined和null； undefined与null的区别?undefined代表变量没有赋值，null: 代表变量赋值了, 只是值为null 什么时候将变量赋值为null?初始化赋值: 将要作为引用变量使用, 但对象还没有确定，结束时: 将变量指向的对象成为垃圾对象 严格区别变量类型与数据类型?js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型，变量类型包括基本类型( 保存基本类型数据的变量)引用类型(保存对象地址值的变量)，数据对象包括基本类型和对象类型 数据和变量和内存什么是数据？存储于内存中代表特定信息的’东西’, 本质就是0101二进制，具有可读和可传递的基本特性，万物(一切)皆数据, 函数也是数据，程序中所有操作的目标: 数据，例如：算术运算，逻辑运算，赋值，调用函数传参等； 什么是内存? 内存条通电后产生的存储空间(临时的)，产生和死亡: 内存条(集成电路板)==&gt;通电==&gt;产生一定容量的存储空间==&gt;存储各种数据==&gt;断电==&gt;内存全部消失，内存的空间是临时的, 而硬盘的空间是持久的，内存分为栈（全局变量, 局部变量 (空间较小)）和堆（对象 (空间较大)）；一块内存包含2个数据，分别为内部存储的数据(一般数据/地址数据)和内存地址值数据； 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据 释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用) 自动释放: 栈空间的局部变量 垃圾回调器回调: 堆空间的垃圾对象 什么是变量？值可以变化的量, 由变量名与变量值组成,一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容; 三者的关系内存是一个容器, 用来存储程序运行需要操作的数据，变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据 赋值和内存的问题对于var a = xxx,a内存中到底保存的是什么，当xxx是基本数据，对象和变量时保存对应的类型。 引用变量赋值问题2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见；2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象 在js调用函数时传递变量参数时, 是值传递还是引用传递?只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据，如果后一种看成是引用传递, 那就值传递和引用传递都可以有； 对象什么是对象代表现实中的某个事物, 是该事物在编程中的抽象；多个数据的集合体(封装体)；用于保存多个数据的容器 为什么要使用对象便于对多个数据进行统一管理 对象的组成属性：代表现实事物的状态数据，由属性名和属性值组成，属性名都是字符串类型, 属性值是任意类型 方法：代表现实事物的行为数据；是特别的属性==&gt;属性值是函数 如何访问对象内部数据通过.属性名的方式，还可以通过[&#39;属性名&#39;]的方式 函数什么是函数？具有特定功能的n条语句的封装体，只有函数是可执行的, 其它类型的数据是不可执行。 为什么要用函数? 提高代码复用和便于阅读和交流； 如何定义函数？ 函数声明加表达式的方式； 如何调用(执行)函数？可以通过如下几种方式调用定义的函数：test()，new test()，obj.test()，test.call/apply(obj) 回调函数什么函数才是回调函数？回调函数满足以下三个条件，你定义的，你没有直接调用，但最终它执行了(在特定条件或时刻)； 常见的回调函数？DOM事件函数；定时器函数；Ajax回调函数等； 匿名函数自调用IIEF全称: Immediately-Invoked Function Expression 立即调用函数表达式，别名: 匿名函数自调用，他的作用有两点隐藏内部实现和不污染外部命名空间；","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"前端基础知识学习---jQuery学习总结","slug":"前端基础知识学习---jQuery学习总结","date":"2019-03-22T11:42:55.000Z","updated":"2019-03-22T12:02:41.216Z","comments":true,"path":"2019/03/22/前端基础知识学习---jQuery学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/前端基础知识学习---jQuery学习总结/","excerpt":"jQuery学习笔记jQuery简介jQuery是一个优秀的JS函数库,其官网可以看一下，jQuery包含了HTML元素选取，HTML元素操作，CSS操作，HTML事件等内容。 jQuery的两把利器jQuery核心函数jQuery核心函数就是$或者jQuery，它定义了这个全局的函数供我们使用，它既可以用于一般的函数调用，且传递的参数类型不同，格式不同功能就完全不同，也可以作为对象调用其定义好的方法，此时的$就是一个工具对象。","text":"jQuery学习笔记jQuery简介jQuery是一个优秀的JS函数库,其官网可以看一下，jQuery包含了HTML元素选取，HTML元素操作，CSS操作，HTML事件等内容。 jQuery的两把利器jQuery核心函数jQuery核心函数就是$或者jQuery，它定义了这个全局的函数供我们使用，它既可以用于一般的函数调用，且传递的参数类型不同，格式不同功能就完全不同，也可以作为对象调用其定义好的方法，此时的$就是一个工具对象。 作为函数调用 参数为函数即$(function) 参数为选择器字符串即$(&quot;#btn&quot;) 参数为DOM对象即$(div) 参数为html标签字符串即$(&quot;&lt;div&gt;&quot;) 123456789101112&lt;body&gt; &lt;input type=\"text\" name=\"userName\" id=\"userName\" /&gt; &lt;button id=\"search\" value=\"搜索\"&gt;搜索&lt;/button&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.1.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123;/*绑定文档加载完成的监听*/ $('#search').click(function()&#123;/*给按钮添加点击监听事件*/ var userName = $('#userName').val();/*获取DOM元素的值*/ &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 说明：上述代码使用了jQuery核心函数：$/jQuery，使用了jQuery核心对象：执行$()返回的对象，$(&#39;#search&#39;) 作为函数的时候，不同参数实例 123456789101112131415161718192021&lt;body&gt; &lt;div&gt; &lt;button id=\"btn\"&gt;确定&lt;/button&gt; &lt;input type=\"text\" name=\"msg1\" /&gt; &lt;input type=\"text\" name=\"msg2\" /&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.10.1.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123;/*参数为函数即$(function):执行此回调函数*/ /*参数为选择器字符串即$(\"#btn\"):查找所匹配的标签，并将他们封装为jQuery对象*/ $('#btn').click(function()&#123;/*绑定监听事件*/ alert(this.innerHTML)/*this:发生事件的DOM元素*/ /*参数为DOM对象即$(div):此时的this就是一个DOM元素， *此时将dom对象封装为jQuery对象，就可以使用jQuery对象的方法*/ alert($(this).html()) /*参数为html标签字符串即$(\"&lt;div&gt;\"):创建标签对象，并封装为jQuery对象*/ $('&lt;input type=\"text\" name=\"msg3\" /&gt;').appendTo('div'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 作为对象使用作为对象使用的时候，时长用于发送AJAX请求或者遍历数组等，例如$.ajax()，$.each()，$.get()，实例如下： 12345678var arr = [2,3,4];/*$.each():隐式遍历数组 */$.each(arr,function(index,item)&#123; console.log(index,item)&#125;)/*$.trim():去除两端空格*/var str = ' Hello Word 'console.log($.trim(str)); jQuery核心对象即执行jQuery核心函数返回的对象，jQuery对象内部包含的是dom元素对象的伪数组(可能只有一个元素)，jQuery对象拥有很多有用的属性和方法, 让程序员能方便的操作dom 属性和方法 基本行为：size()/length，[index]/get(index)，each()，index() 属性：操作内部标签的属性或值 CSS：操作标签的样式 文档：对标签进行增删改操作 筛选：根据指定的规则过滤内部的标签 事件：处理事件监听相关 效果：实现一些动画效果 使用jQuery核心函数选择器","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----多态","slug":"JavaEE基础知识学习----多态","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:36:51.614Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----多态/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----多态/","excerpt":"","text":"多态Java面向对象编程有三大特性：封装，继承和多态封装隐藏类的内部具体实现机制，保护数据，对外界隐藏内部细节，只向外部提供它所允许访问的方法继承是为了复用代码和实现向上转型，当然继承也是为多态做准备。多态可以说是Java面向对象的精华所在。 什么是多态多态是指允许不同子类型的对象对同一消息做出不同的响应，简单来讲，就是用同样的对象调用同样的方法但是却做了不同的事情。也可以理解为一个事物的多种表现形态。多态性分为编译时的多态性和运行时的多态性。例如：方法重载：实现的是编译时的多态性方法重写：实现的是运行是的多态性子类对象的多态性，这个是Java多态性中最常用的事。 实现多态的条件1.方法重写，也就是说要有继承吧，只有有了继承，子类重写了父类已有的或抽象的方法2.对象造型，也就是说要有父类的引用指向子类对象只有这样，同样的引用调用同样的方法就会作出不同的响应，简单来讲如下代码所示：父类Person有如下方法： 1234567public void walk()&#123; System.out.println(\"人走路\");&#125;public void eat()&#123; System.out.println(\"人吃饭\");&#125; 如果子类Man类没有重写这两个方法，那么我们做如下的事情： 12Person man = new Man(); man.walk(); 输出结果： 1人走路 综上所述：父类引用man指向的是子类对象，这个就是子类对象的多态性（也叫向上转型），man可以调用父类的方法，前提是子类没有重写父类方法。如果子类Man类重写了父类方法 1234567public void walk()&#123; System.out.println(\"男人应该挺拔的走路\");&#125;public void eat()&#123; System.out.println(\"男人应该多吃肉\");&#125; 同样的调用： 12Person man = new Man();man.walk(); 结果就是： 1男人应该挺拔的走路 综上所述：子类对象重写了父类方法，那么man调用父类方法，执行的就是子类的方法。这个也虚拟方法调用，说到这里你应该可以猜到，什么是多态了吧，就是同样的父类对象应用，指向不同的子类对象，就会作出不同的响应，例如子类Woman类也重写了父类的方法： 1234567public void walk()&#123; System.out.println(\"女人应该温柔的走路\");&#125;public void eat()&#123; System.out.println(\"女人应该少吃肉多吃水果蔬菜\");&#125; 调用方法： 1234Person man = new Man();Person woman = new Woman();man.walk();woman.walk(); 结果为： 12男人应该挺拔的走路女人应该温柔的走路 综上所述：应该是很清晰了什么是子类对象的多态性，就是你相同的父类引用，不同的子类对象，就会响应对应的子类对象的方法。 方法重载和方法重写方法重载和方法重写两者都是实现多态的方式，区别在于方法重载实现的是编译时的多态，方法重写实现的是运行时的多态，重载发生在同一个类中，同名的方法有不同的参数列表。 注意：方法的重载与返回值无关，简称两同一不同，同一个类，同一个方法，不同的参数列表方法的重写发生在子类和父类之间，重写要求子类方法返回值，方法名，参数列表与父类爆出一致，权限修饰符大于父类，同时要同为static或同为非static。注意：构造器不能被继承，所以不能被重写，但是却可以被重载 多态的使用例子例如在父类Person类中有如下方法： 123public void show(Person person)&#123; System.out.println(\"这是父类show方法\");&#125; 子类Man类重写了子类方法： 123public void show(Person person)&#123; System.out.println(\"这是子类show方法\");&#125; 如果实例化Man对象，调用man的show(Person person)方法，就应该传入Person对象，这个时候就可以传入父类对象的引用。 12Person man = new Man();man.show(man); 父类引用指向不同的子类对象，作出不同的响应。 多态经典案例摘自http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public class A &#123; public String show(D obj) &#123; return (\"A and D\"); &#125; public String show(A obj) &#123; return (\"A and A\"); &#125; &#125; public class B extends A&#123; public String show(B obj)&#123; return (\"B and B\"); &#125; public String show(A obj)&#123; return (\"B and A\"); &#125; &#125; public class C extends B&#123; &#125; public class D extends B&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--\" + a1.show(b)); System.out.println(\"2--\" + a1.show(c)); System.out.println(\"3--\" + a1.show(d)); System.out.println(\"4--\" + a2.show(b)); System.out.println(\"5--\" + a2.show(c)); System.out.println(\"6--\" + a2.show(d)); System.out.println(\"7--\" + b.show(b)); System.out.println(\"8--\" + b.show(c)); System.out.println(\"9--\" + b.show(d)); &#125; &#125; 输出结果为： 1234567891--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D 结果分析如下： 1234567891011System.out.println(&quot;1--&quot; + a1.show(b)); //a1是A的引用指向是A对象，故调用A中的show方法，传入的是b，b指向的是B对象，因为B继承与A,故传入的也可认为是A，结果为A and ASystem.out.println(&quot;2--&quot; + a1.show(c)); //c指向C对象，C继承B,B继承A,相当于传入A，结果为A and ASystem.out.println(&quot;3--&quot; + a1.show(d)); //d指向D对象，在A中有传入D对象的方法，结果为 A and DSystem.out.println(&quot;4--&quot; + a2.show(b)); //a2是父类引用，指向子类对象，按理说调用show方法会执行子类B的show方法，传入的是b,b指向的是B对象, //但是B中的show(B)是子类特有的方法，故不能被调用，传入的是B,B继承与A，相当于传入A,B类重写了show(B)方法，结果为B and ASystem.out.println(&quot;5--&quot; + a2.show(c)); //传入c,执行B中show(C)的方法，没有，C继承B,执行B中show(B),但是这是B中特有方法，不能被调用， //B继承A,调用B中show(A),结果B and ASystem.out.println(&quot;6--&quot; + a2.show(d)); //传入D,执行B中show(D)方法，没有，但是A中有就会执行父类show(D)方法，所以结果为：A and DSystem.out.println(&quot;7--&quot; + b.show(b)); //b指向B,传入B, 结果为B and BSystem.out.println(&quot;8--&quot; + b.show(c)); //传入c,执行B中show(C),没有，C继承B,执行B中show(B),结果为：B and BSystem.out.println(&quot;9--&quot; + b.show(d)); //传入d,执行B中show(D)方法，没有，当时B继承A,是存在A中show(D)的方法，结果为 A and D 案例总结对于a2.show(c)来讲,a2是A的应用，故先去A中找show(C)方法（this.show(O)）,A中没有，按理应该去A的父类中找（super.show(O)），但是A没有父类，故只能在A中找show(c的父类)方法(this.show(super))，c的父类有B和A,A中找到show(A)的方法，但是B重写了该方法，故执行子类的方法，所以结果为B and A。找的顺序是this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----数据结构","slug":"JavaEE基础知识学习----数据结构","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:13.303Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----数据结构/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----数据结构/","excerpt":"","text":"Java数据结构Java中的数据结构主要分为Collection和map两个接口（接口只提供抽象方法，并不提供实现），程序中主要使用的是数据结构是这两个接口的主要实现类。Java中的数据结构关系如下图所示 List：有序的可重复的Collection使用此接口能够精确的控制每一个元素插入的位置，可以通过索引来访问List中的元素。 ArrayList采用数组实现，数组的访问速度要比链表快，所以ArrayList更适合查询操作， LinkedList采用链表实现，随机插入和删除的效率要高于数组， Vector是一种古老的实现类，采用数组的实现，内部方法使用了Sychronized关键字，是线程安全的。 List相关知识总结如下： Map：‘键值’对映射的抽象接口，不包括重复的键。 HashMap：是基于‘拉链法’实现的散列表，底层采用数组+链表实现，一般用于单线程 HashTable：基于‘拉链法’实现的散列表，一般用于多线程 TreeMap：有序散列表，底层通过红黑树实现。 Map相关知识总结如下：Java数据结构的详细信息可以参考我写的其他博客。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----正则表达式学习","slug":"JavaEE基础知识学习-----正则表达式学习","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:23.163Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习-----正则表达式学习/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习-----正则表达式学习/","excerpt":"","text":"正则表达式简介正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来：（1）检查一个串中是否含有符合某个规则的子串，并且可以得到这个子串；（2）根据匹配规则对字符串进行灵活的替换操作。 正则表达式规则普通字符字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是”普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。 例如 表达式 匹配字符串 匹配结果 匹配得到内容 匹配开始位置 结束位置 “c” “gfgc” 成功 “c” 3 3 “bcd” “abcde” 成功 “bcd” 1 4 简单的转义字符一些不便书写的字符，采用在前面加 “/“ 的方法，还有其他一些有特殊用处的标点符号，在前面加”/“ 后，就代表该符号本身。比如：^, 都有特殊意义，如果要想匹配字符串中 “^” 和 “” 字符，则表达式就需要写成 “/^” 和 “/$”。 例如 表达式 可匹配 /r，/n 代表回车和换行符 /t 制表符 // 代表“/”本身 /^ 匹配^符号本身 /$ 匹配$符号本身 /. 匹配小数点本身 能够与多种字符匹配的表达式正则表达式中的一些表示方法，可以匹配 ‘多种字符’ 其中的任意一个字符。比如，表达式 “/d” 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个 表达式 可匹配 /d 任意一个数字，0~9 中的任意一个 /w 任意一个字母或数字或下划线，也就是A~Z,a~z,0~9,_ 中任意一个 /s 包括空格、制表符、换页符等空白字符的其中任意一个小数点可以匹配除了换行符（/n）以外的任意一个字符 例如 表达式 “/d/d”，在匹配 “abc123” 时，匹配的结果是：成功；匹配到的内容是：”12”；匹配到的位置是：开始于3，结束于5。 表达式 “a./d”，在匹配 “aaa100” 时，匹配的结果是：成功；匹配到的内容是：”aa1”；匹配到的位置是：开始于1，结束于4。 自定义能够匹配多种字符的表达式使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ]包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。 表达式 可匹配 [ab5@] 匹配 “a” 或 “b” 或 “5” 或 “@” [^abc] 匹配 “a”,”b”,”c” 之外的任意一个字符 [f-k] 匹配 “f”~”k” 之间的任意一个字母 [^A-F0-3] 匹配 “A”~”F”,”0”~”3” 之外的任意一个字符 例如 表达式 &quot;[bcd][bcd]&quot;匹配 “abc123” 时，匹配的结果是：成功；匹配到的内容是：”bc”；匹配到的位置是：开始于1，结束于3。 表达式&quot;[^abc]&quot;匹配 “abc123” 时，匹配的结果是：成功；匹配到的内容是：”1”；匹配到的位置是：开始于3，结束于4。 修饰匹配次数的特殊符号前面讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。 使用方法 “次数修饰”放在”被修饰的表达式”后边。比如：&quot;[bcd][bcd]&quot;可以写成 “[bcd]{2}”。 表达式 作用 {n} 表达式重复n 次，比如：”/w{2}” 相当于 “/w/w”；”a{5}” 相当于 “aaaaa” {m,n} 表达式至少重复m 次，最多重复n 次，比如：”ba{1,3}”可以匹配 “ba”或”baa”或”baaa” {m,} 表达式至少重复m 次，比如：”/w/d{2,}”可以匹配”a12”,”_456”,”M12344”… ? 匹配表达式0 次或者1 次，相当于 {0,1}，比如：”a[cd]?”可以匹配 “a”,”ac”,”ad” + 表达式至少出现1 次，相当于 {1,}，比如：”a+b”可以匹配 “ab”,”aab”,”aaab”… * 表达式不出现或出现任意次，相当于 {0,}，比如：”/^*b”可以匹配 “b”,”^^^b”… 例如 表达式 “/d+/.?/d*” 在匹配 “It costs $12.5” 时，匹配的结果是：成功；匹配到的内容是：”12.5”；匹配到的位置是：开始于10，结束于14。 表达式 “go{2,8}gle” 在匹配 “Ads by goooooogle” 时，匹配的结果是：成功；匹配到的内容是：”goooooogle”；匹配到的位置是：开始于7，结束于17。 代表抽象意义的特殊符号一些符号在表达式中代表抽象的特殊意义 表达式 作用 ^ 与字符串开始的地方匹配，不匹配任何字符 $ 与字符串结束的地方匹配，不匹配任何字符 /b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符 例如 表达式 “^aaa” 在匹配 “xxx aaa xxx” 时，匹配结果是：失败。因为 “^” 要求与字符串开始的地方匹配，因此，只有当 “aaa” 位于字符串的开头的时候，”^aaa” 才能匹配，比如：”aaa xxx xxx”。 表达式 &quot;aaa$&quot;在匹配&quot;xxx aaa xxx&quot;时，匹配结果是：失败。因为 &quot;$&quot;要求与字符串结束的地方匹配，因此，只有当 &quot;aaa&quot;位于字符串的结尾的时候，&quot;aaa$&quot;才能匹配，比如：&quot;xxx xxx aaa&quot;。 表达式 “./b.” 在匹配 “@@@abc” 时，匹配结果是：成功；匹配到的内容是：”@a”；匹配到的位置是：开始于2，结束于4。 表达式之间的符号 表达式 作用 \\ 左右两边表达式之间 “或” 关系，匹配左边或者右边 ( ) (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 例如 表达式 “Tom|Jack” 在匹配字符串 “I’m Tom, he is Jack”时，匹配结果是：成功；匹配到的内容是：”Tom”；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是：”Jack”；匹配到的位置时：开始于15，结束于19。 表达式 “(go/s*)+” 在匹配 “Let’s go go go!” 时，匹配结果是：成功；匹配到内容是：”go go go”；匹配到的位置是：开始于6，结束于14。 表达式 “￥(/d+/.?/d*)” 在匹配 “＄10.9,￥20.5” 时，匹配的结果是：成功；匹配到的内容是：”￥20.5”；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是：”20.5” 正则表达式中的高级规则匹配次数中的贪婪和非贪婪在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：”{m,n}”, “{m,}”, “?”, “*”,”+”，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本”dxxxdxxxd”，如下： 表达式 匹配结果 (d)(/w+) “/w+” 将匹配第一个 “d” 之后的所有字符”xxxdxxxd” (d)(/w+)(d) “/w+” 将匹配第一个 “d” 和最后一个 “d” 之间的所有字符 “xxxdxxx”。虽然 “/w+” 也能够匹配上最后一个 “d”，但是为了使整个表达式匹配成功，”/w+” 可以 “让出” 它本来能够匹配的最后一个 “d” 由此可见，”/w+” 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 “d”，但那也是为了让整个表达式能够匹配成功。同理，带 “*” 和 “{m,n}” 的表达式都是尽可能地多匹配，带 “?” 的表达式在可匹配可不匹配的时候，也是尽可能的 “要匹配”。这 种匹配原则就叫作 “贪婪” 模式 。 非贪婪模式 在修饰匹配次数的特殊符号后再加上一个 “?” 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 “不匹配”。这种匹配原则叫作 “非贪婪” 模式，也叫作 “勉强”模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。如下，针对文本 “dxxxdxxxd” 举例： 表达式 匹配结果 (d)(/w+?) “/w+?” 将尽可能少的匹配第一个 “d” 之后的字符结果是：”/w+?” 只匹配了一个 “x” (d)(/w+?)(d) 为了让整个表达式匹配成功，”/w+?” 不得不匹配 “xxx” 才可以让后边的 “d” 匹配，从而使整个表达式匹配成功。因此，结果是：”/w+?” 匹配 “xxx” 例如 表达式 &quot;&lt;td&gt;(.*)&lt;/td&gt;&quot;与字符串 &quot;&lt;td&gt;&lt;p&gt;aa&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;bb&lt;/p&gt;&lt;/td&gt;&quot;匹配时，匹配的结果是：成功；匹配到的内容是 &quot;&lt;td&gt;&lt;p&gt;aa&lt;/p&gt;&lt;/td&gt; &lt;td&gt;&lt;p&gt;bb&lt;/p&gt;&lt;/td&gt;&quot;整个字符串， 表达式中的 &quot;&lt;/td&gt;&quot;将与字符串中最后一个&quot;&lt;/td&gt;&quot;匹配。 相比之下，表达式&quot;&lt;td&gt;(.*?)&lt;/td&gt;&quot;匹配举例1 中同样的字符串时，将只得到 &quot;&lt;td&gt;&lt;p&gt;aa&lt;/p&gt;&lt;/td&gt;&quot;，再次匹配下一个时，可以得到第二个 &quot;&lt;td&gt;&lt;p&gt;bb&lt;/p&gt;&lt;/td&gt;&quot;。 反向引用/1, /2…表达式在匹配时，表达式引擎会将小括号 “( )” 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的&quot;&lt;td&gt;(.*?)&lt;/td&gt;&quot;。 其实，”小括号包含的表达式所匹配到的字符串” 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 “括号内的子匹配已经匹配到的字符串”。引用方法是”/“ 加上一个数字。”/1” 引用第1 对括号内匹配到的字符串，”/2” 引用第2 对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号”(“ 在前，那这一对就先排序号。 例如 表达式 “(‘|”)(.*?)(/1)” 在匹配 “ ‘Hello’, “World” “ 时，匹配结果是：成功；匹配到的内容是：” ‘Hello’ “。再次匹配下一个时，可以匹配到 “ “World” “ 表达式 “(/w)/1{4,}” 在匹配 “aa bbbb abcdefg ccccc111121111 999999999” 时，匹配结果是：成功；匹配到的内容是”ccccc”。再次匹配下一个时，将得到 999999999。这个表达式要求”/w” 范围的字符至少重复5 次，注意与 “/w{5,}” 之间的区别。 表达式 “&lt;(/w+)/s(/w+(=(‘|”).?/4)?/s)&gt;.*?&lt;//1&gt;” 在匹配&quot;&lt;td id=&#39;td1&#39; style=&quot;bgcolor:white&quot;&gt;&lt;/td&gt;&quot;时，匹配结果是成功。如果&quot;&lt;td&gt;&quot;与 &quot;&lt;/td&gt;&quot;不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。 预搜索和反向预搜索前面的章节中，我讲到了几个代表抽象意义的特殊符号：”^”，”$”，”/b”。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 “字符串的两头” 或者 “字符之间的缝隙” 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 “两头” 或者 “缝隙” 附加条件的，更加灵活的表示方法。 正向预搜索：”(?=xxxxx)”，”(?!xxxxx)” 格式：”(?=xxxxx)”，在被匹配的字符串中，它对所处的 “缝隙” 或者 “两头” 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 “/b”，本身不匹配任何字符。”/b” 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。 例如 表达式 “Windows (?=NT|XP)” 在匹配 “Windows 98,Windows NT, Windows 2000” 时，将只匹配 “Windows NT” 中的”Windows “，其他的 “Windows “ 字样则不被匹配。 常用正则表达式校验数字的表达式12345678910111213141516171819数字：^[0-9]*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\\.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)$正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$有两位小数的正实数：^[0-9]+(\\.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(\\.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$非负整数：^\\d+$ 或 ^[1-9]\\d*|0$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 校验字符的表达式123456789101112汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$可以输入含有^%&amp;&apos;,;=?$\\&quot;等字符：[^%&amp;&apos;,;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 特殊校验表达式12345678910111213141516171819202122Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d&#123;11&#125;)|^((\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;)|(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;))$)身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\\u4e00-\\u9fa5]双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----普通工厂模式","slug":"JavaEE基础知识学习----普通工厂模式","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:07.950Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----普通工厂模式/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----普通工厂模式/","excerpt":"","text":"概述在设计原则中有这样的一句话“我们应该针对接口编程，而不是针对实现编程”，但是，在大部分的情况下，我们都是以new关键字来创建对象的，针对接口编程的原因在于多态的使用，我们希望能够调用一个简单的方法，传递一个参数就可以返回一个相应的对象，这个时候我们不在是采用new来创建对象，这个就是普通工厂模式，也叫简单工厂模式。举个例子说吧，现实中车子的种类很多，大巴车，轿车，救护车，越野车等等，每一个种类下面还有很多的型号，一个工厂生产这么多的车很难管理，就会有很多分厂，例如生产轿车的分厂，生产货车的分厂，但是，客户不需要知道工厂是怎么区分的，客户只会告诉客服，他需要什么车，客服会根据客户的需求去找到对应的车长去生产车，对客户来说，工厂只是一个抽象的概念，他只知道有这么一个工厂能满足他的需要。 上述例子的类图 伪代码1234567891011121314151617181920public class ProductFactory&#123; public static IProduct createProduct(String productNo)&#123; switch (productNo) &#123; case \"1\": return new Product1(XXXX); case \"2\": return new Product2(XXXX); case \"3\": return new Product3(XXXX); case \"4\": return new Product4(XXXX); case \"5\": return new Product5(XXXX); default: throw new NotSupportedException(\"不支持此编号的车\"); break; &#125; &#125;&#125; 定义普通工厂模式又称为静态工厂方法，属于创建型模式，在普通工厂模式中，可以根据传递的参数不同，返回不同类的实例，普通工厂模式定义了一个类，这个类专门用于创建其他类的实例，这些被创建的类都有一个共同的父类。 普通工厂模式的实现情景：在一个披萨店中，要根据不同客户的口味，生产不同的披萨，类图如下： 代码实现SimplyPizzaFactory工厂类123456789101112131415161718192021222324/** *生产披萨的工厂类 * @author lky */public class SimplyPizzaFactory &#123; public Pizza createPizza(String type)&#123; Pizza pizza = null; if(type.equals(\"cheese\"))&#123; pizza = new CheesePizza(); &#125; else if(type.equals(\"clam\"))&#123; pizza = new ClamPizza(); &#125; else if(type.equals(\"pepperoni\"))&#123; pizza = new PepperoniPizza(); &#125; else if(type.equals(\"veggie\"))&#123; pizza = new VeggiePizze(); &#125; return pizza; &#125;&#125; 抽象披萨类12345678910public abstract class Pizza &#123; public abstract void prepare(); public abstract void bak(); public abstract void cut(); public abstract void box();&#125; 具体披萨CheesePizza1234567891011121314151617181920212223public class CheesePizza extends Pizza&#123; @Override public void prepare() &#123; System.out.println(\"CheesePizza披萨正在准备\"); &#125; @Override public void bak() &#123; System.out.println(\"CheesePizza披萨正在烘烤\"); &#125; @Override public void cut() &#123; System.out.println(\"CheesePizza披萨正在切片\"); &#125; @Override public void box() &#123; System.out.println(\"CheesePizza披萨正在装盒\"); &#125;&#125; 具体披萨ClamPizza123456789101112131415161718192021public class ClamPizza extends Pizza&#123; @Override public void prepare() &#123; System.out.println(\"ClamPizza披萨正在准备\"); &#125; @Override public void bak() &#123; System.out.println(\"ClamPizza披萨正在烘烤\"); &#125; @Override public void cut() &#123; System.out.println(\"ClamPizza披萨正在切片\"); &#125; @Override public void box() &#123; System.out.println(\"ClamPizza披萨正在装盒\"); &#125;&#125; 具体披萨PepperoniPizza123456789101112131415161718192021public class PepperoniPizza extends Pizza&#123; @Override public void prepare() &#123; System.out.println(\"PepperoniPizza披萨正在准备\"); &#125; @Override public void bak() &#123; System.out.println(\"PepperoniPizza披萨正在烘烤\"); &#125; @Override public void cut() &#123; System.out.println(\"PepperoniPizza披萨正在切片\"); &#125; @Override public void box() &#123; System.out.println(\"PepperoniPizza披萨正在装盒\"); &#125;&#125; 具体披萨VeggiePizze123456789101112131415161718192021public class VeggiePizze extends Pizza&#123; @Override public void prepare() &#123; System.out.println(\"VeggiePizze披萨正在准备\"); &#125; @Override public void bak() &#123; System.out.println(\"VeggiePizze披萨正在烘烤\"); &#125; @Override public void cut() &#123; System.out.println(\"VeggiePizze披萨正在切片\"); &#125; @Override public void box() &#123; System.out.println(\"VeggiePizze披萨正在装盒\"); &#125;&#125; 披萨商店类1234567891011121314151617public class PizzaStore &#123; SimplyPizzaFactory factory; public PizzaStore(SimplyPizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza orderPizza(String type)&#123; Pizza pizza; pizza = factory.createPizza(type);//采用工厂对象的创建方法实例化 pizza.prepare(); pizza.bak(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 总结 普通工厂模式实现了对责任的分割，提供了专门的工厂用于创建对象。 客户端不需要知道所创建的具体产品的类名，只要知道产品类对应的编号即可。 要点就是当你需要什么，只需要传入一个正确的参数就可以，不需要关心它具体的实现细节。 如果产品过多就会导致工厂类的代码十分的复杂。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----装饰者模式","slug":"JavaEE基础知识学习----装饰者模式","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:27.753Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----装饰者模式/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----装饰者模式/","excerpt":"","text":"定义动态的将责任附加到对象上，若要扩展功能，装饰者模式提供了比继承更具有弹性的方案。 为什么会出现这个设计模式给对象扩展行为的方法有两种，一种是通过继承，继承是给类添加扩展行为比较有效的办法，通过使用继承，可以使得子类有自己的行为，还可以获得父类的行为方法，但是使用继承是静态的，在编译的时候就已经决定了子类有哪些行为。当然还可以使用关联，将一个对象嵌入到另一个对象中，有一个对象来决定是否引用该对象来扩展自己的行为，这是一种动态的方式，我们可以在程序中动态的决定和控制。前面所说的两种都会导致一种‘类爆炸’的情况出现，所以就出现了装饰者模式。 认识装饰者模式例如为咖啡店设计一个点咖啡的程序，采用饮料为主体，在运行时以调料来‘装饰’饮料，如果顾客要摩卡和奶泡深焙咖啡，那么， 拿一个深焙咖啡（DarkRoast）对象 以摩卡（Mocha）对象装饰它 一奶泡（Whip）对象装饰它 调用cost方法，并依赖委托（delegate）将调料的钱加上去。 装饰者类图结构 实现装饰者模式情景：购买咖啡时，会加入不同的调料，根据不同的调料来收费，也就是说不同的咖啡与不同的调料有N中不同的组合方式，也就是出现了不同组合就应该有不同的价格。结构图如下： 代码实现Beverage组件基类12345678public abstract class Beverage &#123; protected String description = \"\"; public String getDescription() &#123; return description; &#125; public abstract double cost();&#125; HouseBlend组件123456789public class HouseBlend extends Beverage &#123; public HouseBlend() &#123; description = \"这是一杯综合咖啡\"; &#125; @Override public double cost() &#123; return 0.89; &#125;&#125; Espresso组件123456789public class Espresso extends Beverage&#123; public Espresso() &#123; description = \"这是一杯浓缩咖啡\"; &#125; @Override public double cost() &#123; return 1.99; &#125;&#125; Decat组件123456789public class Decat extends Beverage &#123; public Decat() &#123; description = \"这是一杯深焙咖啡\"; &#125; @Override public double cost() &#123; return 0.99; &#125;&#125; DarkRoast123456789public class DarkRoast extends Beverage&#123; public DarkRoast() &#123; description = \"这是一杯低咖啡因咖啡\"; &#125; @Override public double cost() &#123; return 1.05; &#125;&#125; 配料基本类123public abstract class CondimentDecorator extends Beverage&#123; public abstract String getDescription();&#125; Milk配料123456789101112131415public class Milk extends CondimentDecorator&#123; Beverage beverage; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return beverage.getDescription()+\",牛奶\"; &#125; @Override public double cost() &#123; return beverage.cost()+0.1; &#125;&#125; Mocha配料123456789101112131415public class Mocha extends CondimentDecorator &#123; Beverage beverage; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return beverage.getDescription()+\",摩卡\"; &#125; @Override public double cost() &#123; return beverage.cost()+0.2; &#125;&#125; Soy配料123456789101112131415public class Soy extends CondimentDecorator&#123; Beverage beverage; public Soy(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return beverage.getDescription()+\",豆浆\"; &#125; @Override public double cost() &#123; return beverage.cost()+0.15; &#125;&#125; Whip配料1234567891011121314public class Whip extends CondimentDecorator&#123; Beverage beverage; public Whip(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return beverage.getDescription()+\",奶泡\"; &#125; @Override public double cost() &#123; return beverage.cost()+0.1; &#125;&#125; 测试类12345678910111213public class StartbuzzCoffee &#123; public static void main(String[] args) &#123; Beverage beverage = new Espresso(); System.out.println(beverage.getDescription()+\",$\"+beverage.cost()); System.out.println(\"========================\"); Beverage beverage2 = new DarkRoast(); beverage2 = new Mocha(beverage2); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(beverage2.getDescription()+\",$\"+beverage2.cost()); &#125;&#125; 测试结果这是一杯浓缩咖啡,$1.99 ======================== 这是一杯低咖啡因咖啡,摩卡,摩卡,奶泡,$1.55 总结 装饰者可以提供比继承更多的灵活性。 可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的的装饰器，从而实现不同的行为。 具体组件类和装饰类可以独立变化，用户可以根据自己的需要增加具体的组件类和装饰类，原有的代码无需改变，负荷”开闭原则“。 但是也会产生很多的小对象，增加了系统的负责性。 建议在不影响其他对象的时候使用，以动态，透明的方式给单个对象添加职责。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----泛型","slug":"JavaEE基础知识学习----泛型","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:13.079Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----泛型/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----泛型/","excerpt":"","text":"泛型Java泛型是jdk1.5的一个新特性，jdk的性特性还包括：泛型，枚举，装箱和拆箱，可变参数等。这里先主要学习泛型。这些特性，现在都在广泛的使用。因为现在使用IDE编写代码，都是标准的代码提示，所以泛型也就变得理所应当，但还是应该学习记录一下。 泛型的声明interface List和class 名称&lt;K,V&gt;,其中T,K,V代表的是类型。例如12List&lt;String&gt; list = new ArrayList&lt;String&gt;();Inerator&lt;Customer&gt; iterator = customers.iterator(); 说明：T只能是类，不能是基本数据类型为什么要有这个新特性123456789101112public static void main(String[] args) &#123; List list = new ArrayList(); list.add(12); list.add(23); list.add(45); list.add(65); list.add(new String(\"AA\")); for(int i = 0 ; i &lt; list.size(); i++)&#123; int age = (Integer)list.get(i); System.out.println(age); &#125;&#125; 上述代码就是用一个集合存储年龄，如果不使用泛型的话就是任何元素就都可添加到集合中，导致类型不安全，其次在遍历的时候需要强转，如果不小心在Integer类型的集合中放入一个String类型的，那么在遍历就会出现一个类型转换异常。 为了解决元素存储的安全性问题 解决获取数据元素时，需要类型强转的问题，例如 String类型的对象→集合Object类型对象→读取为Object对象→强转为String对象，集合使用Object类型会导致类型不安全，简单说就是任何元素都可以添加进去。 使用泛型集合中使用泛型可以达到类型安全，读取出来的对象不需要强转，使得程序简单快捷。同上的代码，如果集合的声明为： 1List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 使用泛型声明集合，就只能向集合添加相同类型的数据，在遍历的数据类型也是声明泛型的类型，不需要再强转。下面是使用泛型的一个例子。 1234567891011public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"AA\", 98); map.put(\"BB\", 86); map.put(\"CC\", 75); map.put(\"DD\", 62); Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); for(Map.Entry&lt;String, Integer&gt; o: set)&#123; System.out.println(o.getKey()+\"====\"+o.getValue()); &#125;&#125; List源码解释泛型1.为什么List接口可以使用泛型，源码如下： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; 其中代表的就是泛型，再看里面的方法， 12boolean add(E e);E get(int index); 其中的方法都是传入泛型的对象，得到的也是泛型的对象。 自定义泛型类，泛型方法当实例化泛型类的对象时，明确指明泛型的类型，自定义泛型类的类中所有使用泛型的位置，都变成实例化中指定的泛型的类型。例如如下自定义泛型类： 1234567891011121314151617181920212223242526272829303132333435public class TestGeneric&lt;T&gt; &#123; private String name; private String sex; private T t; List&lt;T&gt; list = new ArrayList&lt;&gt;(); public void add()&#123; list.add(t); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125; public static void main(String[] args) &#123; TestGeneric&lt;String&gt; generic = new TestGeneric&lt;String&gt;(); generic.setT(\"AA\"); generic.add(); List&lt;String&gt; list = generic.list; System.out.println(list); &#125;&#125; 泛型的更多使用是为了代码的通用性。在使用jdbc编写查询数据的DAO就可以使用泛型来编写通用的父类DAO。让子类继承来决定类型。对于集合类的泛型需要注意以下几点： 对象实例化不指定泛型，默认为Object 泛型不同的引用不能相互赋值 加入集合中的对象类型必须和指定的泛型类型保持一致 静态方法中不能使用泛型 如果泛型类是一个接口或抽象类，则不可以创建泛型类的对象","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----继承","slug":"JavaEE基础知识学习----继承","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:49.412Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----继承/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----继承/","excerpt":"","text":"继承 Java面向对象的第二个特性：继承，继承是指新的类可以获得已有类（称为父类或基类）的属性和行为，称新类为已有类的派生类或子类， 继承是一种联结类的层次模型，为类的重用提供方便，也可以说复用代码，例如有如下两个类Man类和Woman类： 以上两个类中，我们可以看出，男人和女人的属性有很多相同的地方，男人和女人都是人，他们都具备人所具备的属性和行为，例如，姓名。年龄，性别，吃饭，睡觉等等，如果我们可以最大限度的复用代码，提取出两个类所共有的属性和行为，那么如何来实现代码的复用，这就要Java面向对象的特性二，继承性， 继承就是使用已经存在类来定义新的类，新类可以增加新的属性和行为，也可以使用父类的属性和行为，但是不能选择性的继承父类，使用继承可以方便的复用代码，提高开发效率，使用继承可以使程序结构清晰，但是会增加代码耦合度。使用继承后的类设计如下：使用继承需要明确的是： Java继承使用extends关键字实现 Java是支持单继承。 子类拥有父类非private的属性和方法 子类可以拥有自己的属性和方法，也就是说子类可以对父类进行扩展 子类可以重写父类的方法，涉及到方法的重写，将会在后面学习讲到继承，就会说到构造器，protected关键字，向上转型。构造器子类可以继承父类非private的属性和方法，还存在一种是子类不能继承的，那就是构造器，对于构造器来说，他允许被子类调用，不允许被子类继承，调用父类的构造方法使用super()即可。这里就涉及到构造器初始化顺序的事，父类构造器如下：12345678910public Person() &#123; System.out.println(\"我是父类构造器\");&#125;public Person(String name, String sex, int age) &#123; System.out.println(\"我是父类含参构造器\"); this.name = name; this.sex = sex; this.age = age;&#125; 子类构造器如下:1234567public Man() &#123; System.out.println(\"我是子类构造器\");&#125;public Man(boolean smook) &#123; System.out.println(\"我是子类含参构造器\");&#125; 初始化对象：1Man man = new Man(); 输出结果如下：12我是父类构造器我是子类构造器 初始化子类对象时会默认调用父类默认构造器，前提是父类要有默认的无参构造器，如果父类没有默认的无参构造器，我们就必须通过super()来调用父类构造器。例如：父类有构造器：123public Person(String name) &#123; System.out.println(\"我是父类含参构造器=====\"+name);&#125; 子类默认构造器如下：1234public Man() &#123; super(\"张三\"); System.out.println(\"我是子类构造器\");&#125; 初始化子类对象：1Man man = new Man(); 输出结果：12我是父类含参构造器=====张三我是子类构造器 综上所述：对于继承来讲，子类会默认调用父类的默认无参构造器（前提是父类存在默认无参构造器），如果父类没有默认的构造器，子类就必须明确的指定自己要调用的是父类哪一个构造器，而且必须是在子类构造器中最前面做的事，就是代码写在最前面。 protected关键字首先protected是一个权限修饰符，所以我们先看看权限修饰符的相关知识： 四种不同修饰符的权限如下所示： public：当前类，同包，子类，其他包 protected：当前类，同包，子类 default:当前类，同包 private:当前类 类的成员不写访问修饰符就相当于default，default对于同一个包中的其他类相当于公开，对于不是同一个包的其他类相当于私有。protected对于子类相当于公开，对于不是同包也没有子类关系的类相关于私有。对于Java面向对象的封装性来讲，private是最好的选择，但是有时候我需要将一些属性尽可能的向外界隐藏，但是允许子类可以访问，天下父母都一样，尽可能的向多给子类一些，但是又不想给全世界，毕竟没有那么伟大，所以就使用到了protercted关键字。例如：父类protected 方法：1234567protected void setName(String name) &#123; this.name = name;&#125;@Overridepublic String toString() &#123; return \"父类toString方法==\"+name;&#125; 子类toString方法：12345@Overridepublic String toString() &#123; setName(\"我是张三\");//调用父类protected方法 return super.toString();//调用父类toString方法&#125; 实例化子类对象：12Man man = new Man();System.out.println(man.toString()); 输出结果为：1父类toString方法==我是张三 综上所述：我们可以看出子类Man类可以调用父类Person的setName(),因为改方法使用protected权限修饰符，尽管可以如此，但是最好将属性的权限保持为private，更好的体现Java面向对象的封装性，通过protected方法来控制继承者的访问权限。 向上转型这个其实也叫子类对象的多态性，Java面向对象的特性之多态性将在后续的学习中，向上转型就是父类的应用指向子类对象，例如：1Person person = new Man(); 具体实例如下所示，例如在父类Person中有如下方法：123456public void show()&#123; System.out.println(\"我是父类show方法\");&#125;static void show(Person person)&#123; person.show();&#125; Man类继承Person类，在外部直接调用Man类的父类的静态方法如下：1Man.show(person); 按理说我们应该在show方法中传入Person对象，但是我们可以参这样做：12Person man = new Man();Man.show(man); 另外：在这里可以通过man调用父类的方法，如果子类重写了父类的方法，那么调用就会执行子类的方法，这个也叫虚拟方法调用，也就是说man不能调用子类所特有的方法。当然，如果你想调用子类所特有的方法，那么可以使用强转，1Man m = (Man)man; 使用m来调用子类所特有的方法。 注意虽然说继承可以带来很多好处，可以实现代码复用，但是使用继承要慎重，为什么这么讲呢？原因是： 增强了代码之间的耦合度。父类变，子类也就必须跟着变，有点像家族企业的兴衰一样 继承破坏了封装，对于父类而言，实现细节对子类是很清晰的 继承有优点也有缺点，不知道应不应该使用继承，主要看自己的代码需不需要继承带来的好处，例如需要向上转型不，如果需要，那肯定需要继承。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----集合之ConcurrentHashMap","slug":"JavaEE基础知识学习----集合之ConcurrentHashMap","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:33.577Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----集合之ConcurrentHashMap/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----集合之ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap基本知识概述 ConcurrentHashMap是map接口的实现类，因为HashMap是线程不安全的，因此ConcurrentHashMap可以看成是HashMap的线程安全版本。 线程安全的有ConcurrentHashMap，ConcurrentSkipListMap，HashTable，Properties，但是HashTable是过时的类库，所以在并发中使用最多的是是ConcurrentHashMap和ConcurrentSkipListMap。 ConcurrentHashMap在并发的开发中使用频率高，所以他的主要方法和HashMap基本一样。ConcurrentHashMap实现原理概述 ConcurrentHashMap是由Segment数组和HashEntry数组组成， Segment的结构和HashMap差不多，是数组和链表结合的数组结构，Segment是一种可重入锁，在ConcurrentHaspMap中就是锁的角色， HashEntry是存放键值对数据，在源码中我们可以出一个Segment中包含一个HashEntry， 换句话说，一个Segment守护一个HashEntry，当我们要对HashEntry中的数据进行修改时，首先要获得HashEntry数据所对应的Segment锁。 源码分析如下12public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable &#123; 源码中可以看出ConcurrentHashMap继承了AbstractMap这个类，实现了ConcurrentMap和Serializable这两个接口，说明这个类具备了Map基本的骨干方法。 1.构造方法1.ConcurrentHashMap()创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。 2.ConcurrentHashMap(int initialCapacity)创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。 3.ConcurrentHashMap(int initialCapacity, float loadFactor)创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。 4.ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)创建一个带有指定初始容量、加载因子和并发级别的新的空映射。 5.ConcurrentHashMap(Map&lt;? extends K,? extends V&gt; m)构造一个与给定映射具有相同映射关系的新映射 2.属性ConcurrentHashMap使用segments数组来保存锁，源码如下： 1final Segment&lt;K,V&gt;[] segments; ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁，在ConcurrentHashMap中保证HashEntry几乎不可变，使用final关键字。源码如下：12345static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; 3.如何初始化segments数组1234567891011121314151617181920212223242526272829 public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; int sshift = 0; int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); this.segments = ss;&#125; 说明： 构造方法中initialCapacity代表数组容量，loadFactor代表负载因子，concurrencyLevel代表并发级别。 segment数组是ConcurrentHashMap保存锁的数组，segment数组的初始化由段偏移量segmentShift，段掩码segmentmask和HashEntry数组组成。 segment数组的长度ssize通过concurrencyLevel计算得出，为了通过按位与的哈希算法类定位segment的索引，就必须保证segment数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的n次方值来作为segment数组的长度，concurrencyLevel的最大并发级别是655535，所以segment数组的最大长度为66636.对应的二进制是16位。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----抽象类和接口","slug":"JavaEE基础知识学习----抽象类和接口","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:40:07.143Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----抽象类和接口/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----抽象类和接口/","excerpt":"abstract关键字abstract：抽象的，可以用来修饰类和方法，当abstract修饰类的时候，该类就叫抽象类，修饰方法时，就叫抽象方法。","text":"abstract关键字abstract：抽象的，可以用来修饰类和方法，当abstract修饰类的时候，该类就叫抽象类，修饰方法时，就叫抽象方法。 什么叫抽象类在java中，因为继承，使得类越来越具体化，类的设计使得父类越来越通用，在类的设计里应该保证父类和子类能够共享特征，有时候就把父类设计的非常抽象，让它没有具体的实例。这样的类就叫抽象类，例如人可以说话，但是不同的人可能说的话不一样，所以让说话的内容由子类自己决定。 1.抽象类不可以被实例化，实例化应该是它的子类来完成123456789101112131415161718192021222324252627282930public class TestAbstract &#123; public static void main(String[] args) &#123; Person person = new Person(); person.eat(); &#125;&#125;class Person&#123; public void eat()&#123; System.out.println(\"人吃饭\"); &#125; public void walk()&#123; System.out.println(\"人走路\"); &#125;&#125;class Teacher extends Person&#123; public void eat()&#123; System.out.println(\"教师吃饭\"); &#125; public void walk()&#123; System.out.println(\"教师走路\"); &#125;&#125;class Student extends Person&#123; public void eat()&#123; System.out.println(\"学生吃饭\"); &#125; public void walk()&#123; System.out.println(\"学生走路\"); &#125;&#125; 从上述代码可以看出，如果Person类没有被abstract修饰，在main方法里是可以被实例化的，如果我们加上了abstract关键字修饰，那么Person person = new Person();就会被报错。 2.抽象类是类的一种，也有构造器很神奇的是，抽象类不能被实例化，但是却可以存在构造器， 123456789101112131415161718abstract class Person&#123; String name; int age; public void eat()&#123; System.out.println(\"人吃饭\"); &#125; public void walk()&#123; System.out.println(\"人走路\"); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person() &#123; super(); &#125;&#125; 3.抽象方法所在的类一定是抽象类1234abstract class Person&#123; public abstract void eat(); public abstract void walk();&#125; abstract修饰方法abstract修饰的方法也叫抽象方法，关于抽象方法需要说明以下几点：1.抽象方法的格式，没有方法体，就是不包括{},例如public abstract void eat();2.抽象方法值保留方法的功能，具体的实现过程由继承他的子类来实现，3.如果子类继承了抽象类没有全部实现父类抽象方法，则表明子类还是一个抽象类，也必须用abstract修饰类，4.如果子类继承了抽象类，并且全部重写了父类抽象方法，则该子类就可以被实例化。 4.抽象类中可以没有抽象方法12345678abstract class Person&#123; public void eat()&#123; System.out.println(\"人吃饭\"); &#125; public void walk()&#123; System.out.println(\"人走路\"); &#125;&#125; 5.抽象方法必须由子类来重写123456789101112abstract class Person&#123; public abstract void eat(); public abstract void walk();&#125;class Teacher extends Person&#123; public void eat()&#123; System.out.println(\"教师吃饭\"); &#125; public void walk()&#123; System.out.println(\"教师走路\"); &#125;&#125; 从上述代码也能得出，子类继承一个抽象类，要么全部实现父类的抽象方法，要么本身还是一个抽象类。 6.子类中的抽象方法不能和父类的抽象方法同名7.abstract不能与final修饰同一个类，原因很简单，final修饰的类不能被继承，8.abstract不能与private，static，final，native并列修饰同一个方法这三点大家都可以试试，道理也很简单。下面一个例子说明抽象类的相关知识； 1234567891011121314151617181920212223242526272829303132public class TestAbstract &#123; public static void main(String[] args) &#123; Person p1 = new Teacher(); p1.eat(); Person p2 = new Student(); p2.eat(); Teacher t1 = new Teacher(); t1.eat(); Student s1 = new Student(); s1.eat(); &#125;&#125;abstract class Person&#123; public abstract void eat(); public abstract void walk();&#125;class Teacher extends Person&#123; public void eat()&#123; System.out.println(\"教师吃饭\"); &#125; public void walk()&#123; System.out.println(\"教师走路\"); &#125;&#125;class Student extends Person&#123; public void eat()&#123; System.out.println(\"学生吃饭\"); &#125; public void walk()&#123; System.out.println(\"学生走路\"); &#125;&#125; 结果为： 1234教师吃饭学生吃饭教师吃饭学生吃饭 模板方法设计模式抽象类体现的就是一种模板设计模式，抽象类作为多个子类通用的模板，子类在抽象类的基础上进行扩展，这种模式解决的就是一部分功能不确定，就把不确定的功能部分暴露出去，让子类自己去实现。 案例123456789101112131415161718192021222324252627282930313233public class TestTemplate &#123; public static void main(String[] args) &#123; new subTemplate().spendTime(); &#125;&#125;abstract class Template&#123; public abstract void testAbstract(); public void spendTime()&#123; long start = System.currentTimeMillis(); this.testAbstract(); long end = System.currentTimeMillis(); System.out.println(\"执行testAbstract方法花费的时间为\"+(end-start)); &#125;&#125;class subTemplate extends Template&#123; @Override public void testAbstract() &#123;//求10000以内的素数 boolean flag = false; for(int i = 2; i &lt;= 10000;i++)&#123; for(int j = 2;j &lt;=Math.sqrt(i);j++)&#123; if(i % j == 0)&#123; flag = true; break; &#125; &#125;if(!flag)&#123; System.out.println(i); &#125; flag = false; &#125; &#125; &#125; 接口接口是一种比抽象类还抽象的东西，它不是类，不能被实例化，只能实例化他的子类。使用关键字interface，实现接口的类就必须实现接口中的所有方法，这个在javaee中的三层架构中会经常使用。在使用接口的过程中需要注意一下几点： 一个类可以实现多个接口，也可以继承其他接口。 接口中只能有常量和抽象方法。 接口的权限只能是public，你可以手动声明为其他，编译就会报错。 接口中定义的“成员变量”，也加不可变的常量，因为会自动加上public static final，可以通过接口名.常量名进行访问。 接口主要用于定义规范，接触耦合关系 1234public interface TestInterface &#123; public void show(); public void updateEmployee();&#125; 这就是一个接口，只是说接口没有太多说的，主要是接口有什么用，java为什么会提供这么一个东西，接口在JAVAEE中使用很多，例如Mybatis基于接口的mapper开发。JavaEE三层模式开发都会大量使用接口。下面主要学习接口的应用。 接口的多态性12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; Duck duck = new Duck(); Test.test1(duck); Test.test2(duck); Test.test3(duck); &#125; public static void test1(Swim s)&#123; s.swim(); &#125; public static void test2(Runner r)&#123; r.runner(); &#125; public static void test3(Fly f)&#123; f.fly(); &#125;&#125;interface Swim&#123; public abstract void swim();&#125;interface Runner&#123; public abstract void runner();&#125;interface Fly&#123; public abstract void fly();&#125;class Duck implements Swim,Fly,Runner&#123; @Override public void runner() &#123; System.out.println(\"鸭子跑起来了\"); &#125; @Override public void fly() &#123; System.out.println(\"鸭子飞起来了\"); &#125; @Override public void swim() &#123; System.out.println(\"鸭子游起来了\"); &#125; &#125; 继承的多态是子类重写父类方法，父类引用指向不同的子类实例，就会调用对应子类的方法，从而执行不同的响应，接口的多态是实现类实现多个接口，方法参数列表里可以带接口的引用参数，方法的具体可以通过接口引用调用接口里的抽象方法，调用该方法时传入接口实现类，实际执行的是实现类中的方法。这是相同的实例，不同的接口体现的多态性。 接口应用-工厂方法的设计模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。简单来讲就是暴露接口给用户，根据用户传入的参数返回特定的实例对象的一种模式。例如：一个生产汽车的工厂，有很多分厂，生产火车的，生产轿车的，生产货车的，用户不知道有这些分厂，用户只知道有一个工厂可以生产车，这个工厂是虚拟的，用户在接口传入编号，由工厂返回用户指定的车实例。案例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestFactory &#123; public static void main(String[] args) &#123; IWorkFactory factory = new StudentWorkFactory(); factory.getWork().doWork(); IWorkFactory factory2 = new TeacherWorkFactory(); factory2.getWork().doWork(); &#125;&#125;interface IWorkFactory&#123; Work getWork();&#125;class StudentWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new StudentWork(); &#125; &#125;class TeacherWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new TeacherWork(); &#125; &#125;interface Work&#123; void doWork();&#125;class StudentWork implements Work&#123; @Override public void doWork() &#123; System.out.println(\"学生写作业\"); &#125; &#125;class TeacherWork implements Work&#123; @Override public void doWork() &#123; System.out.println(\"教师批改作业\"); &#125; &#125; 抽象类和接口的区别总的来说：抽象类和接口都不能被实例化，但是都可以定义抽象类和接口的引用。 抽象类可以有抽象方法，也可以有方法的具体实现，接口中不能。 抽象类中的成员修饰可以为private，默认，protected,public但是接口中只能为public。 抽象类可以定义成员变量，但是接口中其实都是不可变的常量。 抽象类如下： 1234567abstract class TestAbstractDemo&#123; String name; abstract void test1(); void test2()&#123; System.out.println(\"我是具体方法\"); &#125;&#125; 接口如下： 12345interface TestInterfaceDemo&#123; String name=\"Hello\"; abstract void test1(); abstract void test2(); &#125; 总结：程序设计中，什么时候使用接口，什么时候使用抽象类，这是一个架构的难点，只有对问题充分了解才能选择合适的设计方法，抽象类在java中表示的是一种继承关系，一个子类只存在一个父类，但是却可以实现多个接口。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----Java8-1-Lambda表达式","slug":"JavaEE进阶知识学习----Java8-1-Lambda表达式","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:34.001Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Java8-1-Lambda表达式/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Java8-1-Lambda表达式/","excerpt":"","text":"###lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 ####语法格式 #####1.无参数，无返回值（）-&gt; System.out.print(“Hello Word”);示例如下： @Test public void test1(){ Runnable r = new Runnable() { @Override public void run() { System.out.print(&quot;Hello Word&quot;); } }; r.run(); System.out.print(&quot;===============================&quot;); Runnable r1 = () -&gt; System.out.print(&quot;Hello Word&quot;); r1.run(); } #####2.一个参数，无返回值（x）-&gt; System.out.print(x); @Test public void test2(){ Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept(&quot;Hello Word&quot;); } 如果只有一个参数，无返回值可以省略小括号不写。 #####3.两个参数，有返回值，并且有多条执行语句 @Test public void test3(){ Comparator&lt;Integer&gt; com = (x,y) -&gt;{ System.out.println(&quot;函数式接口&quot;); return Integer.compare(x,y); }; int max = com.compare(4,5); System.out.println(max); } #####4.如果只有一条返回语句 @Test public void test4(){ Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y); } #####4.lambda表达式中的参数类型可以省略不写，JVM可以根据上下文推断出类型 ####Lambda表达式需要函数式接口的支持。 ###函数式接口接口中只有一个抽象方法的接口，就叫函数式接口。可以使用注解@FunctionalInterface检查是否为函数式接口。 @FunctionalInterface public interface MyPredicat &lt;T&gt;{ public boolean test(T t); } 示例如下：1.定义一个函数式接口 @FunctionalInterface public interface MyFun { public Integer getValue(Integer num); } 2.定义一个方法，方法的参数为函数式接口 public Integer operation(Integer num,MyFun mf){ return mf.getValue(num); } 3.使用Lambda表达式 @Test public void test5(){ Integer num = operation(100,(x)-&gt; x*x); System.out.println(num); } Lambda表达式左侧是函数式接口的参数，右侧是函数式接口的实现。 ####Lambda练习将集合中的员工排序，按照年龄从小到大排序，如果年龄相同就按照名称排序 public class TestLambda { List&lt;Employee&gt; emps = Arrays.asList( new Employee(&quot;张三&quot;,13,9999.99), new Employee(&quot;李四&quot;,67,444.44), new Employee(&quot;王五&quot;,45,55.55), new Employee(&quot;赵六&quot;,45,6666.66) ); @Test public void test1(){ Collections.sort(emps,(e1,e2) -&gt; { if(e1.getAge() == e2.getAge()){ return e1.getName().compareTo(e2.getName()); }else{ return Integer.compare(e1.getAge(),e2.getAge()); } }); for(Employee emp:emps){ System.out.println(emp); } } } 练习二，对字符串进行处理1.申明一个函数式接口，用于处理字符串 @FunctionalInterface public interface MyFunction { public String getValue(String str); } 2.申明一个处理字符串的方法，返回处理后的结果 public String strHandle(String str,MyFunction mf){ return mf.getValue(str); } 3.调用处理方法，使用Lambda表达式实现字符串的不同处理 @Test public void test2(){ //将传入的字符串做去除空格处理 String trimStr = strHandle(&quot; \\t\\t\\t\\tHello Word&quot;,(str) -&gt; str.trim()); System.out.println(trimStr); //将传入的字符串做大写转换处理 String uper = strHandle(&quot;abce&quot;,(str) -&gt; str.toUpperCase()); System.out.println(uper); //将传入的字符串做截取处理 String subStr = strHandle(&quot;我要好好学习，成为一个大神&quot;,(str) -&gt; str.substring(1,5)); System.out.println(subStr); } 练习三，计算两个long型参数做处理1.声明一个函数式接口 @FunctionalInterface public interface MyFunction2 &lt;T,R&gt;{ public R getValue(T t1,T t2); } 2.定义处理方法 public void operator(Long l1,Long l2,MyFunction2&lt;Long,Long&gt; mf){ System.out.println(mf.getValue(l1,l2)); } 3.使用Lambda表达式 @Test public void test4(){ operator(100L,200L,(x,y) -&gt; x+y); operator(100L,200L,(x,y) -&gt; x*y); } ####总结从上述代码中，我们可以看出Lambda表达式的好处，但是我们会发现，每次使用都会新建一个函数式接口，增加了很多麻烦，所以，Java8给我们增加了很多函数式接口，将在下一pain博客中学习。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----Static关键字","slug":"JavaEE基础知识学习----Static关键字","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:51.167Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----Static关键字/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----Static关键字/","excerpt":"Static关键字static静态的，可以用来修饰变量，修饰方法，代码块，静态内部类和静态导包。static关键字表明一个成员变量或方法在没有所属类的实例的情况下被访问。","text":"Static关键字static静态的，可以用来修饰变量，修饰方法，代码块，静态内部类和静态导包。static关键字表明一个成员变量或方法在没有所属类的实例的情况下被访问。 明确的是Java内存分为，栈，堆，方法去和静态域。栈：存放的是局部变量，对象的引用名，数组的引用名。堆：主要存放一些对象，也就是new出来的“东西”。方法区：也叫字符串常量池。静态域：存放类中静态的变量。先看如下代码： 123456789101112131415161718192021public class TestStatic &#123; public static void main(String[] args) &#123; Supperman s1 = new Supperman(\"奥特曼\", 800); Supperman s2 = new Supperman(\"孙悟空\", 1000); System.out.println(s1); System.out.println(s2); &#125;&#125;class Supperman&#123; String name; int age; public Supperman(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"man [name=\" + name + \", age=\" + age + \"]\"; &#125;&#125; 结果很简单： 12Supperman [name=奥特曼, age=800]Supperman [name=孙悟空, age=1000] 再看看这段代码的内存解析如下：综上所述：如果不是静态的，他就会在堆空间独立占有一块，你修改s1属性的值，不会影响到s2对应的值。同样是上面的代码 123456789101112131415161718192021222324public class TestStatic &#123; public static void main(String[] args) &#123; Supperman s1 = new Supperman(\"奥特曼\", 800); Supperman s2 = new Supperman(\"孙悟空\", 1000); s1.sex = \"男\"; System.out.println(s1); System.out.println(s2); &#125;&#125;class Supperman&#123; String name; int age; String sex; public Supperman(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Supperman [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\"; &#125;&#125; 结果： Supperman [name=奥特曼, age=800, sex=男] Supperman [name=孙悟空, age=1000, sex=null]现在更可以看出，你改变一个对象的属性值，不会影响其他的对象，但是如果我们加上static呢？ 1static String sex; 结果为： 12Supperman [name=奥特曼, age=800, sex=男]Supperman [name=孙悟空, age=1000, sex=男] 再看上述代码的内存解析图简单来讲就是：s1.name=””仅仅改变的是s1对象中name属性值，不会影响s2中的name的值，但是s1.sex=””改变的可是所有该类的实例对象的sex的属性值。 static修饰属性（类变量）当static修饰属性时，由类创建的所有对象都共用这一个属性。当其中一个对象对此属性修改时，会导致其他对象对此属性的一个调用，静态变量可以通过类.类变量的形式来调用。类变量随类的加载而加载的，而且只有一份，类变量的加载是早于对象的，类变量存在与静态域中。例如所有的中国人都有一个国家名称，每一个中国人都共享这个国家名称，所以我们不必为中国人这个实例对象都单独分配一个代表国家名称的变量吧，这个时候就用到了static修饰变量。 static修饰方法（类方法）static修饰方法需要说明的是：1.随之类的加载而加载，在内存中也只有一份。2.可以直接通过类.类方法，普通的方法只能通过对象来调用。3.内部可以调用静态的属性和静态方法，不能调用非静态的属性和方法，反之，非静态的方法却可以调用静态的属性和方法。4.静态方法里不可以有this关键字和super关键字。5.静态的结构，例如静态属性，静态方法，静态代码块，内部类等等的生命周期要早于非静态结构，被回收也要晚于非静态结构。 12345678910111213public class TestStatic &#123; public static void main(String[] args) &#123; Supperman.run(); &#125;&#125;class Supperman&#123; String name; int age; static String sex; public static void run()&#123; System.out.println(\"sex\"+sex); System.out.println(\"超人飞走了！\");&#125; 先说说属性赋值的方法 默认的初始化 显示的初始化或者使用代码块进行初始化 使用构造器 通过属性的setter方法进行修改 代码块代码块的作用是用来初始化类的属性，根据是否有static关键字修饰分为静态代码块和非静态代码块例如有如下类： 123456789101112131415161718192021222324252627class Order&#123;private int orderId;private String orderName;public Order() &#123; super();&#125;public Order(int orderId, String orderName) &#123; super(); this.orderId = orderId; this.orderName = orderName;&#125;public int getOrderId() &#123; return orderId;&#125;public void setOrderId(int orderId) &#123; this.orderId = orderId;&#125;public String getOrderName() &#123; return orderName;&#125;public void setOrderName(String orderName) &#123; this.orderName = orderName;&#125;@Overridepublic String toString() &#123; return \"Order [orderId=\" + orderId + \", orderName=\" + orderName + \"]\";&#125; 测试代码如下： 1234public static void main(String[] args) &#123; Order o1 = new Order(); System.out.println(o1);&#125; 结果为： Order [orderId=0, orderName=null]下面就使用代码块来对属性赋值。 静态代码块1.里面可以有输出语句。2.随着类的加载而加载，而且只被加载一次。3.多个静态代码块按照顺序一次执行4.静态代码快的执行要早于非静态的5.静态的代码块里只能执行静态的结构（静态属性，静态方法） 123static&#123; System.out.println(\"我是静态代码块\"); &#125; 非静态代码块1.可以对类的属性（静态的或者非静态）进行初始化操作，同时也可以调用自身类中的方法（静态的或者非静态的）2.里面也可以有输出语句3.一个类也可以有多个非静态的代码块，彼此之间顺序执行，4.每创建一个对象，非静态类就加载一次，这个和静态代码块不一样5.非静态代码块的执行要在于构造器在上述Order类中加入如下代码 1234567private int orderId = 1000;private String orderName;//初始化块&#123; orderId=1001; orderName=\"AA\";&#125; 同样的测试语句，结果为： 1Order [orderId=1001, orderName=AA] 代码块总结关于代码块的所有知识可以通过下面这个代码来解释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestOrder &#123; public static void main(String[] args) &#123; Order o1 = new Order(); System.out.println(o1); System.out.println(\"============我是帅气分隔符========\"); Order o2 = new Order(); System.out.println(o2); &#125;&#125;class Order&#123; private int orderId = 1000; private String orderName; //初始化块 static&#123; System.out.println(\"我是静态代码块\"); &#125; &#123; orderId=1001; orderName=\"AA\"; System.out.println(\"我是非静态代码块1\"); &#125; &#123; orderId=1002; orderName=\"BB\"; System.out.println(\"我是非静态代码块2\"); &#125; public Order() &#123; super(); &#125; public Order(int orderId, String orderName) &#123; super(); this.orderId = orderId; this.orderName = orderName; &#125; public int getOrderId() &#123; return orderId; &#125; public void setOrderId(int orderId) &#123; this.orderId = orderId; &#125; public String getOrderName() &#123; return orderName; &#125; public void setOrderName(String orderName) &#123; this.orderName = orderName; &#125; @Override public String toString() &#123; return \"Order [orderId=\" + orderId + \", orderName=\" + orderName + \"]\"; &#125;&#125; 执行结果为： 12345678我是静态代码块我是非静态代码块1我是非静态代码块2Order [orderId=1002, orderName=BB]============我是帅气分隔符========我是非静态代码块1我是非静态代码块2Order [orderId=1002, orderName=BB] static导包如果我们要使用静态成员（方法和变量）我们就要用类.类方法（类变量）。如果使用了静态导包，就不用在给出类了，如下TestStaticPackge类 12345public class TestStaticPackge &#123; public static void output()&#123; System.out.println(\"Hello world\"); &#125;&#125; 如果我们不使用静态导包，访问就是这个样子的： 123public static void main(String[] args) &#123; TestStaticPackge.output();&#125; 静态导包的方法：import static 包名.类名.静态成员变量; import static 包名.类名.静态成员函数; 注意导入的是成员变量和方法名。例如上述： 12345678import static com.java.study.TestStaticPackge.output;public class TestOrder &#123; public static void main(String[] args) &#123; TestStaticPackge.output();//不使用静态导包 output();//使用静态导包 &#125;&#125; 总结：有static可以脱离对象而执行，没有就必须依赖对象","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----Java8-3-方法引用和构造器引用","slug":"JavaEE进阶知识学习----Java8-3-方法引用和构造器引用","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:44.525Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Java8-3-方法引用和构造器引用/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Java8-3-方法引用和构造器引用/","excerpt":"","text":"###方法引用当要传递给Lambda体的操作，已经有了实现的方法，可以使用方法引用.(实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致)。方法引用：使用操作符“::”将方法名和对象或类的名字分割开，例如： 对象::实例方法 类::静态方法 类::实例方法 ####对象::实例方法示例如下： @Test public void test1(){ //注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 Consumer&lt;String&gt; com = (x) -&gt; System.out.println(x); PrintStream ps = System.out; Consumer&lt;String&gt; con = ps::println; } 例如打印一个字符串： @Test public void test1(){ Consumer&lt;String&gt; con = System.out::println; con.accept(&quot;Hello Word&quot;); } #####注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 ####类::静态方法方法引用的实质就是使用更简单的方式代替Lambda表达式。下述代码就是类::静态方法的一个实例。例如，如下 @Test public void test2(){ Comparator&lt;Integer&gt; con = (x,y) -&gt; Integer.compare(x,y); //上述代码中Lambda表达体中的compare方法已经被实现，可以简写为 Comparator&lt;Integer&gt; con1 = Integer::compare; } ####类::实例方法如下 @Test public void test3(){ BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); //上述代码简写为 BiPredicate&lt;String,String&gt; bp2 = String::equals; } ###构造器引用 @Test public void test4(){ Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); //构造器引用 Supplier&lt;Employee&gt; sup2 = Employee::new; Employee employee = sup.get(); System.out.println(employee.getName()); } 其中构造器方法调用哪一个构造器取决与接口Supplier中的方法参数，Supplier就是调用的无参构造器，例如Function函数接口就是传入一个参数，并返回一个结果。如下 @Test public void test5(){ Function&lt;String,Employee&gt; fun = (x) -&gt; new Employee(x); //构造器引用 Function&lt;String,Employee&gt; fun2 = Employee::new; Employee emp = fun2.apply(&quot;王五&quot;); System.out.println(emp); } Function&lt;String,Employee&gt;中的String是传入参数类型，Employee是返回结果类型。如果我们想传入两个参数，并返回一个结果，就必须要在Employee中创建两个含两个参数的构造器，如下 @Test public void test6(){ BiFunction&lt;String,Integer,Employee&gt; fun = Employee::new; Employee emp = fun.apply(&quot;赵六&quot;,123); System.out.println(emp); } #####注意：Employee中构造器参数列表和接口中的方法fun.apply(“赵六”,123);参数列表保持一致。 ###数组引用格式：type[]::new @Test public void test7(){ Function&lt;Integer,String[]&gt; fun = (x) -&gt; new String[x]; String[] str= fun.apply(10); System.out.println(str.length); } 上述代码就是使用Lambda表达式传入一个数组大小，从而创建一个指定大小和类型的数组。使用数组引用为： Function&lt;Integer,String[]&gt; fun2 = String[]::new; String[] str2 = fun2.apply(10); System.out.println(str2.length);","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----异常","slug":"JavaEE基础知识学习----异常","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:18.308Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----异常/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----异常/","excerpt":"","text":"异常在使用计算机语言进行项目开发的过程中，不可能把代码写的完美，在系统的运行过程中仍然会遇到一些问题，例如用户输入数据的格式，读取文件但是文件是否存在等等。在java中，将程序执行过程中发生的不正常情况称为异常，当然开过程中的语法错误和逻辑错误就不是异常了。 异常体系结构 分类java程序在执行过程中所发生的异常可分为两类：Error:Java虚拟机无法解决的严重问题，例如：JVM系统内部错误，资源耗尽等严重情况，一般不会编写代码进行处理。Exception：因编程错误或偶然的外在因素导致的一般问题，可以编写代码进行针对性处理，例如空指针访问，试图读取不存在的文件等等 解决办法1.遇见错误就终止程序的运行。2.编写程序时就考虑到这些错误，并编写了错误检测，错误提示，错误处理的代码 。捕获错误最理想的就是在编译期间，就是生成.class文件前，但是有的错误只有在运行期间才会发生，例如除数为0，数组下标越界等等，所以又分为编译时异常和运行时异常。 常见异常1.IndexOutOfBoundsException下标越界异常。例如12345public static void main(String[] args) &#123; int a[] = new int[10]; System.out.println(a[10]); System.out.println(a[-10]);&#125; 2.ArithmeticException算术异常，例如1234public static void main(String[] args) &#123; int i = 10; System.out.println(i/0);&#125; 3.ClassCastException类转换异常，例如1234public static void main(String[] args) &#123; Object obj = new Date(); String str = (String) obj;&#125; 4.NullPointerException空指针异常，例如12345678910public class TestException &#123; public static void main(String[] args) &#123; TestPerson person = new TestPerson(); person = null; System.out.println(person.toString()); &#125;&#125;class TestPerson&#123; &#125; 说明：程序有异常，如果没有处理，就会结束继续向下执行，例如 12345678910111213public class TestException &#123; public static void main(String[] args) &#123; TestPerson person = new TestPerson(); person = null; System.out.println(person.toString()); String str = new String(\"AA\"); System.out.println(str.length()); &#125;&#125;class TestPerson&#123; &#125; 在上述代码中，会抛出NullPointerException空指针异常，也不会打印str的长度。 异常处理方式java采用异常处理机制，将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁，并易于维护。java提供的异常处理是抓抛模型。 抛java程序在执行过程中如果遇见异常，就会生成一个异常类对象，该异常类对象将被提交给java运行时系统，这个过程称为抛出异常。抛出异常分为自动抛出和手动抛出，一旦抛出异常类的对象，程序就终止执行，异常类的对象是抛给方法的调用者。 抓抓住上一把抛出的异常类的对象，如何抓，就是异常类的处理方式，有两种方式。 异常处理方式一123456789try&#123;//可能出现异常的代码&#125;catch(Exception1 e1)&#123;//处理方式1&#125;catch(Exception2 e2)&#123;//处理方式2&#125;finally&#123;//一定要执行的代码&#125; 解释：try中的代码如果抛出了异常，就会抛给catch，catch根据Exception类型执行不同的解决方式，catch可以有多个，就和if-else一样的道理。其中try中申明的变量类似局部变量，在try外就不能访问。例如下面的代码，解决异常的方式： 123456789101112public class TestException &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); try &#123; int i= scanner.nextInt(); System.out.println(i); &#125; catch (InputMismatchException e) &#123; System.out.println(\"出现了类型不匹配异常\"); &#125; &#125;&#125; 说明：1.使用try-catch时候，出现了异常就会进入catch语句中，如果有多个catch，也只会进入一个catch，然后继续执行下面的代码。2.如果catch里的异常类型是包含关系，必须将子类放在父类的上面，进行处理，否则就会报错。3.finally存放的就是一定会处理的代码，不管try-catch中是否有异常未被处理，以及里面是否有return语句。4.try-catch是可以嵌套的。 异常处理方式二使用try-catch处理的异常是知道可能会产生异常，并且知道怎么处理这个异常，如果一个方法中可能产生某种异常，但是并不明确知道该如何处理这种异常，这个时候就要显示的 声明抛出异常，表明我这个方法不进行异常处理，谁调用谁处理。在方法的声明中使用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中可能产生的异常类型，也可以是他的父类。例如如下： 1234public void readFile()throws FileNotFoundException&#123; //可能产生文件找不到异常 FileInputStream fis = new FileInputStream(file);&#125; 在上述代码中抛出的是系统自带的异常对象，还可以自己定义一个异常处理类。在程序中还可以手动的抛出异常，例如： 1234567public int compareTo(Object obj)&#123; if(obj instanceof Person)&#123; return 0; &#125;else&#123; throw new RuntimeException(\"传入的类型有误\"); &#125;&#125; 在上述代码中1.我们手动抛出 RuntimeException，代码编译不会报错，如果抛出了Exception，程序就会报错，因为运行时异常在编译不会报错，这个时候要么用try-catch，要么在方法声明上使用throws.2.我们使用throw手动抛出异常，这个throw和throws有很大的区别： 注意的是在继承后，子类重写父类异常方法时，抛出的异常要比父类小才行。 throw和throws的区别1.throws+异常类型，是在方法的声明处，是解决异常处理的两种方式之一，2.在处理异常的方式中有自动抛出异常和手动抛出异常（就使用到了throw后面是一个异常类对象） 自定义异常类使用java自定义异常需要注意以下几点：1.定义一个类继承Throwable类或者他的子类2.在某个方法类抛出异常3.捕捉和解决该异常 自定义异常类步骤1.新建一个类，并继承Throwable类或者他的子类2.类中提供一个序列号，作为唯一标识，具体看RuntimeException源码。3.提供几个重载的构造器例如： 12345678910public class MyException extends RuntimeException &#123; static final long serialVersionUID = -7034897190745766939L; public MyException()&#123; &#125; public MyException(String message)&#123; super(message); &#125;&#125; 在处理异常就可以手动的抛出自定义的异常类。 1throw new MyException(\"传入的类型有误\"); 异常面试题1.Error和Exception有什么区别？答：Error表示系统级别的错误和程序不必处理的异常，比如内存溢出。Exception表示需要捕捉或者程序处理的异常，是一种设计和实现问题，简单来讲就是如果程序运行正常就不会发生这样的情况。 2.try{}里有一个return语句，那么紧跟在try后面的finally{}里的代码会不会执行，什么时候执行？return前还是后？答：会执行，在方法返回调用者前执行。简单说就是不管catch是否有return，finally里的代码都会执行。 3.Java如何进行异常处理？throws、throw、try、catch、finally分别如何使用？答：java通过面向对象的方法进行异常处理，把各种异常进行分类，并提供的接口，在java中每一个异常都是一个对象，他是Throwable的子类的实例，java异常处理使用五个关键字：try、catch、finally、throws、throw一般情况下是try来执行一段程序，如果系统会抛出throw一个异常类对象，就用catch来捕获，或者使用finally来处理。try-catch是知道怎么处理异常，如果不知道就使用throws抛出异常，将异常交给方法调用者处理。 4.列出你常见的运行时异常？①.ArithmeticException算术异常，当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 ②.ClassCastException类转换异常当试图将对象强制转换为不是实例的子类时，抛出该异常。例如，以下代码将生成一个 ClassCastException： 12Object x = new Integer(0);System.out.println((String)x); ③.IllegalArgumentException非法参数异常抛出的异常表明向方法传递了一个不合法或不正确的参数。 ④.IndexOutOfBoundsException下标越界异常指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 ⑤.NullPointerException空指针异常当应用程序试图在需要对象的地方使用 null 时，抛出该异常。这种情况包括： 12345调用 null 对象的实例方法。访问或修改 null 对象的字段。将 null 作为一个数组，获得其长度。将 null 作为一个数组，访问或修改其时间片。将 null 作为 Throwable 值抛出。 ⑥.SecurityException安全异常由安全管理器抛出的异常，指示存在安全侵犯。 5.阐述final、finally、finalize区别？答：final:修饰符，修饰类表明该类不能被继承，修饰方法表明该方法不能被重写，修饰变量，则必须赋值，成为常量。finally：是异常处理try-catch的后面总要执行的代码块，可以将资源的关闭写在里面。finalize:Object类中定义的方法，java中允许使用finalize()方法在垃圾收集器里讲对象从内存中清除出去之前做必要的工作，这个方法是有垃圾收集器在销毁对象时候调用的。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----观察者模式","slug":"JavaEE基础知识学习----观察者模式","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:18.600Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----观察者模式/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----观察者模式/","excerpt":"","text":"定义出版社+订阅者=观察者模式，其中出版社改成为‘主题’，订阅者改称为‘观察者’。观察者模式定义了对象之间的一对多依赖关系，当一个对象改变状态时，他的所有依赖者都会收到通知并且自动更新。这里和订阅报纸是一样的道理，当出版社有了新报纸，那么所有订阅了该报纸的人都会收到新的报纸。在这里，发生改变的对象（出版社）称为观察目标（主题），被通知的对象（订阅报纸的人）称为观察者，一个观察目标可以对应多个观察者，而这些观察者之间没有相互联系，所以可以根据需要增加和删除观察者，使得系统更易于扩展。 类图 实例需求在气象观测站中，有三个布告板，分别显示目前状况，气象统计和天气预报。WeatherData类中具有setter和getter方法，可以取得三个测量值，当有新的数据时，WeatherData类中的measurementsChanged()方法就会被调用，我们要做的就是，一旦WeatherData类有新数据，我们就要更新布告板。 类图设计 代码实现Subject 主题接口12345678public interface Subject &#123; //观察者注册 public void registerObserver(Observer o); //移除观察者 public void removeObserver(Observer o); //当主题状态该变时，这个方法就会被调用，以通知所有的观察者 public void notifyObserver();&#125; Observer 观察者接口12345public interface Observer &#123; //当气象观测值改变时，主题就会将这些状态值当做方法的参数，传送给观察者 //所有的的观察者都必须实现update方法，以实现观察者接口 public void update(float temperature,float humidity,float pressure);&#125; DisplayElement 布告板显示接口1234public interface DisplayElement &#123; //当布告板需要显示的，就会调用此方法 public void display();&#125; WeatherData实现主题接口 WeatherData.java12345678910111213141516171819202122232425262728293031323334353637383940414243public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; //使用一个集合来记录观察值 public WeatherData() &#123; observers = new ArrayList&lt;Observer&gt;(); &#125; //注册成为观察者 @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if(i &gt;=0)&#123; observers.remove(o); &#125; &#125; //这里就是将状态循环的通知给每一个观察者，因为每一个观察者都实现了update方法， @Override public void notifyObserver() &#123; for(int i=0; i &lt; observers.size();i++)&#123; Observer observer = observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; //当气象站得到更新数据中，就通知观察者 public void measurementsChanged()&#123; notifyObserver(); &#125; public void setMeasurements(float temperature,float humidity, float pressure)&#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; CurrentConditionsDisplay 布告板123456789101112131415161718192021222324252627282930/** * 显示目前状况的布告板：显示温度，湿度和气压 *@author lky *@date 2018年1月16日 */public class CurrentConditionsDisplay implements Observer,DisplayElement &#123; private float temperature;// 温度 private float humidity;// 湿度 private float pressure; // 气压 private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; @Override public void display() &#123; System.out.println(\"我是目前状况布告板，现在温度是：\"+temperature+ \"℃\"+\"湿度是：\"+humidity+\"气压是：\"+pressure); &#125; @Override public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; display(); &#125;&#125; 天气预报布告板123456789101112131415161718192021222324252627282930313233/** * 天气预报布告板：显示当前的天气状况 *@author lky *@date 2018年1月16日 */public class ForecastDisplay implements Observer,DisplayElement&#123; private float currentPressure = 29.92f; //当前的气压 private float lastPressure; // 最后的气压 private WeatherData weatherData; public ForecastDisplay(WeatherData weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature,float humidity,float pressure) &#123; lastPressure = currentPressure;// 将当前的气压赋给最后的气压 currentPressure = pressure;// 将更新的气压赋给当前气压 display(); &#125; public void display() &#123; if (currentPressure &gt; lastPressure) &#123; System.out.println(\"我是天气预报布告板，现在是：气压升高，天气转好！\"); &#125; else if (currentPressure == lastPressure) &#123; System.out.println(\"我是天气预报布告板，现在是：气压不变，天气维持！\"); &#125; else if (currentPressure &lt; lastPressure) &#123; System.out.println(\"我是天气预报布告板，现在是：气压降低，天气变坏！\"); &#125; &#125;&#125; 天气统计布告板1234567891011121314151617181920212223242526272829303132333435363738/** * 天气统计布告板：显示最高温度，最低温度和平均温度 *@author lky *@date 2018年1月16日 */public class StatisticsDisplay implements Observer,DisplayElement&#123; private float maxTemp = 0.0f; private float minTemp = 200; private float tempSum= 0.0f; private int numReadings; private WeatherData weatherData; public StatisticsDisplay(WeatherData weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; tempSum += temperature; numReadings++; if (temperature &gt; maxTemp) &#123; maxTemp = temperature; &#125; if (temperature &lt; minTemp) &#123; minTemp = temperature; &#125; display(); &#125; public void display() &#123; System.out.println(\"我是天气统计布告板，平均温度是： \" + (tempSum / numReadings) + \"，最高温度是：\" + maxTemp + \"，最低温度是：\" + minTemp); &#125;&#125; 酷热指数布告板1234567891011121314151617181920212223242526272829303132333435/** * 酷热指数布告板，根据温度和湿度采用特定的公式镜像计算的。 *@author lky *@date 2018年1月16日 */public class HeatIndexDisplay implements Observer,DisplayElement &#123; float heatIndex = 0.0f; private WeatherData weatherData; public HeatIndexDisplay(WeatherData weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature,float humidity,float pressure) &#123; heatIndex = computeHeatIndex(temperature, humidity); display(); &#125; //在布告板中自定义方法。 private float computeHeatIndex(float t, float rh) &#123; float index = (float)((16.923 + (0.185212 * t) + (5.37941 * rh) - (0.100254 * t * rh) + (0.00941695 * (t * t)) + (0.00728898 * (rh * rh)) + (0.000345372 * (t * t * rh)) - (0.000814971 * (t * rh * rh)) + (0.0000102102 * (t * t * rh * rh)) - (0.000038646 * (t * t * t)) + (0.0000291583 * (rh * rh * rh)) + (0.00000142721 * (t * t * t * rh)) + (0.000000197483 * (t * rh * rh * rh)) - (0.0000000218429 * (t * t * t * rh * rh)) + 0.000000000843296 * (t * t * rh * rh * rh)) - (0.0000000000481975 * (t * t * t * rh * rh * rh))); return index; &#125; public void display() &#123; System.out.println(\"我是酷热指数布告板，现在的酷热指数为： \" + heatIndex); &#125;&#125; 测试123456789101112131415public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay conditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay observer2 = new StatisticsDisplay(weatherData); ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); HeatIndexDisplay heatIndexDisplay = new HeatIndexDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); System.out.println(\"===================================\"); weatherData.setMeasurements(70, 55, 20.4f); System.out.println(\"===================================\"); weatherData.setMeasurements(90, 75, 40.4f); &#125;&#125; 结果1234567891011121314我是目前状况布告板，现在温度是：80.0℃湿度是：65.0气压是：30.4我是天气统计布告板，平均温度是： 80.0，最高温度是：80.0，最低温度是：80.0我是天气预报布告板，现在是：气压升高，天气转好！我是酷热指数布告板，现在的酷热指数为： 82.95535===================================我是目前状况布告板，现在温度是：70.0℃湿度是：55.0气压是：20.4我是天气统计布告板，平均温度是： 75.0，最高温度是：80.0，最低温度是：70.0我是天气预报布告板，现在是：气压降低，天气变坏！我是酷热指数布告板，现在的酷热指数为： 75.9113===================================我是目前状况布告板，现在温度是：90.0℃湿度是：75.0气压是：40.4我是天气统计布告板，平均温度是： 80.0，最高温度是：90.0，最低温度是：70.0我是天气预报布告板，现在是：气压升高，天气转好！我是酷热指数布告板，现在的酷热指数为： 108.19608 执行流程分析 实例化一个主题对象（WeatherData） 实例化一个现实目前状况的布告板，并传入主题对象。 在目前状况的布告板的构造函数中，将当前布告板注册为传入的主题的观察者 同理，将天气统计布告板，天气预报布告板，酷热指数布告板都注册为WeatherData的观察者 调用主题对象的setMeasurements方法，模拟主题对象的值发生改变。 第一次传入不同的温度，湿度和气压。主题对象调用measurementsChanged()方法。 measurementsChanged()方法中调用notifyObserver()方法。 notifyObserver()方法中循环调用observer的update()方法，调用的是接口方法，具体执行的是每一个实例类型的update()方法， 每一个布告板实例的update()方法，是具体的数据准备，然后调用display()方法，显示布告板信息。 整体分析图 总结 观察者模式定义了对象之间的一对多关系，多个观察者监听同一个主题（被观察者），当主题的状态发生改变时，会通知所有的观察者。 观察者模式中具体主题是主题的子类，通常包含经常发生改变的数据，当他的状态发生改变时，会通知所有他的观察者对象，主题用一个共同的接口来更新观察者。 观察者实现的是同一个接口，也就是主题发生改变时通知的接口，不同的观察者具体的实现方法不一样。 观察者与被观察者之间用松耦合的方式结合。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----集合","slug":"JavaEE基础知识学习----集合","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:24.650Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----集合/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----集合/","excerpt":"","text":"集合 首相明确的是java是一门面向对象的语言，在Java中，对事物的体现都是以对象的形式，为了方便对多个对象进行操作，就有了要对对象进行存储的要求，于是就有了集合的概念，java集合就像是一种容器，可以动态的将多个对象的引用存放在java集合这个容器当中。 java集合类可以存储数量不等的多个对象，还可以用于保存具有映射关系的关联数组。 在编写java程序的中，集合是每时每刻都在使用，例如常用的ArrayList，HashMap，HashSet，也有不常用的Stack，Queue,有线程安全的Vector,HashTable也有线程不安全的LinkedList，TreeMap。 说到存储对象，除了集合可以存储对象，数组也可以存储对象，但是数组存储对象有如下弊端：1.数组长度一旦初始化就不可改变，存储对象的个数就不能改变2.数组中真实存储的对象的个数也没有现成方法可用Java集合概述Java集合可分为Collection和Map两种体系，具体的要自己看源码，其中Collection和Map如下； 在Collection体系中，存在了Iterator迭代器和Comparable，Comparator对象排序接口 Collection接口 Collection接口是最基本的集合接口，它不提供直接的实现，而是由子接口来提供实现，它是List，Set和Queue的父接口， Set是元素无序，不可重复的接口 List是元素有序，可重复的接口Collection常用方法 注意：这里集合的创建使用了java中的泛型。 1.size();返回集合中元素个数12Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();int size = collection.size(); 2.add(“AA”);向集合中添加元素12Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();collection.add(\"AA\"); 3.addAll(List);向集合中添加一个集合中的全部元素123Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();Collection&lt;String&gt; List = Arrays.asList(\"AA\",\"BB\",\"CC\");collection.addAll(List); 4.isEmpty();判断集合是否为空12Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();boolean empty = collection.isEmpty(); 5.clear();清空集合元素12Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();collection.clear(); 注意：以下方法都依赖与对象的equals方法。6.contains(“AA”);查看集合中是否包含某一个元素，返回一个布尔类型的值12345Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();collection.add(\"AA\");collection.add(\"BB\");collection.add(\"CC\");boolean contains = collection.contains(\"AA\"); 关于这个contains方法需要仔细对待，上述代码没什么问题，现在集合中存入对象，如下12345678910111213141516171819202122232425262728293031323334public class TestCollection &#123; public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); Person person = new Person(\"AA\", 12); collection.add(person); boolean contains = collection.contains(person); System.out.println(contains); &#125; &#125;class Person&#123; String name; int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person() &#123; super(); &#125;&#125; 上述代码是collection.add(person);这样返回的是true，1234Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;();collection.add(new Person(\"AA\", 12));boolean contains = collection.contains(new Person(\"AA\", 12));System.out.println(contains); 如果这样写就会返回false，这是因为两个对象的引用不一样，如果想两个对象的值一样就返回true的话，那么Person类就重写equals方法，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestCollection &#123; public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); boolean contains = collection.contains(new Person(\"AA\", 12)); System.out.println(contains); &#125;&#125;class Person&#123; String name; int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person() &#123; super(); &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125;&#125; 一般而言集合中的对象元素都应该重写equals方法。7.containsAll(list);当前集合是否包含list中的所有元素，只有全部包含才返回true1234567891011public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); collection.add(new Person(\"BB\", 13)); collection.add(new Person(\"CC\", 14)); Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"BB\", 13)); boolean containsAll = collection.containsAll(list); System.out.println(containsAll);&#125; 8.retainAll(list);求当前集合与形参集合所共有的元素，并返回给当前集合，简单说就是将当前集合中与形参集合一样的元素移除。1234567891011public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); collection.add(new Person(\"BB\", 13)); collection.add(new Person(\"CC\", 14)); Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"BB\", 13)); boolean retainAll = collection.retainAll(list); System.out.println(collection);&#125; 9.remove(new Person(“DD”, 12));删除集合中某一个元素，删除成功返回true，否则false，这里返回false。1234567891011public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); collection.add(new Person(\"BB\", 13)); collection.add(new Person(\"CC\", 14)); Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"BB\", 13)); boolean remove = collection.remove(new Person(\"DD\", 12)); System.out.println(remove);&#125; 10.removeAll(list);在当前集合中产出包含形参的元素。123456789101112public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); collection.add(new Person(\"BB\", 13)); collection.add(new Person(\"CC\", 14)); Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"BB\", 13)); boolean removeAll = collection.removeAll(list); System.out.println(removeAll); System.out.println(collection);&#125; 11.equals(list);判断当前集合是否与形参集合完全相同，这里返回true,123456789101112public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); collection.add(new Person(\"BB\", 13)); collection.add(new Person(\"CC\", 14)); Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"BB\", 13)); list.add(new Person(\"CC\", 14)); boolean equals = collection.equals(list); System.out.println(equals);&#125; 同样的代码，顺序不一样，返回的结果也就不一样，这里返回false，只是交换了想集合中存储对象的顺序。123456789101112public static void main(String[] args) &#123; Collection&lt;Person&gt; collection = new ArrayList&lt;Person&gt;(); collection.add(new Person(\"AA\", 12)); collection.add(new Person(\"BB\", 13)); collection.add(new Person(\"CC\", 14)); Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); boolean equals = collection.equals(list); System.out.println(equals);&#125; 12.toArray();将集合装换为数组。12345678910public static void main(String[] args) &#123; Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); Object[] array = list.toArray(); for(int i = 0; i&lt;array.length; i++)&#123; System.out.println(array[i]); &#125;&#125; 13.iterator();返回一个Iterator接口实现类，实现集合遍历12345678910public static void main(String[] args) &#123; Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); Iterator&lt;Person&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 说到遍历就顺便学了遍历集合的三种方式1.for循环12345678910public static void main(String[] args) &#123; List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); for(int i = 0 ; i &lt;list.size(); i++)&#123; Person person = list.get(i); System.out.println(person); &#125;&#125; 注意：Collection没有get方法，意味着不能使用for遍历，可以使用迭代器进行遍历。2.增强for循环123456789public static void main(String[] args) &#123; List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); for (Person person : list) &#123; System.out.println(person); &#125;&#125; 注意：增强for循环没有index,如果需要使用就要在外部定义，如下：1234567891011public static void main(String[] args) &#123; List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); int index = 0; for (Person person : list) &#123; System.out.println(\"index==\"+index+\"=========\"+person); index++; &#125;&#125; 3.iterator迭代器遍历12345678910public static void main(String[] args) &#123; Collection&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(new Person(\"AA\", 12)); list.add(new Person(\"CC\", 14)); list.add(new Person(\"BB\", 13)); Iterator&lt;Person&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; Collection和collections的区别 Collection是一个接口，他是Set、List等容器的父接口。 Collections是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索，排序等，具体参考API","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----集合之ArrayList","slug":"JavaEE基础知识学习----集合之ArrayList","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:28.873Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----集合之ArrayList/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----集合之ArrayList/","excerpt":"","text":"ArrayList首先明确的是：Collection的子接口是List接口,Listc存储的是有序可重复的元素，ArrayList是List接口的主要实现类，List接口的主要实现类有： 1.ArrayList由数组方式实现数据存储，当然数组的访问速度比链表快。源码如下：12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;private static final long serialVersionUID = 8683452581122892189L;/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. */private transient Object[] elementData; 2.LinkedList由连接实现数据的存储，随机添加和删除元素的的操作的效率要高于数组，简单说就更适用于频繁的插入和实现操作。 3.Vector是一种古老的实现类，在Vector类中，里面的方法添加了synchronized修饰，是线程安全的，关于线程的相关知识会在后续的学习中，他的性能比ArrayList差，用的地方比较少， ArrayList常用方法ArrayList常用的方法和Collection基本一样，也大致看看吧，就当复习吧。 1.add(“AA”);向集合中添加一个元素1234public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\");&#125; 2.add(2, “CC”);将指定的元素插入此列表中的指定位置。索引从0开始123456789public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\"); list.add(\"BB\"); list.add(\"DD\"); System.out.println(list); list.add(2, \"CC\"); System.out.println(list);&#125; 结果为：12[AA, BB, DD][AA, BB, CC, DD] 3.addAll(list2);将形参中的集合元素全部添加到当前集合中的尾部。1234567891011public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\"); list.add(\"BB\"); list.add(\"DD\"); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); list2.add(\"CC\"); list2.add(\"EE\"); list.addAll(list2); System.out.println(list);&#125; 结果为：1[AA, BB, DD, CC, EE] 4.addAll(2, list2);将形参中集合元素添加到当前集合指定的位置。1234567891011public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\"); list.add(\"BB\"); list.add(\"DD\"); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); list2.add(\"CC\"); list2.add(\"EE\"); list.addAll(2, list2); System.out.println(list);&#125; 结果为：1[AA, BB, CC, EE, DD] 5.clear();清空当前集合中所有元素1list.clear(); 注意：以下方法和Collection一样，都依赖元素对象的equals方法。更多的时候都需要重写equals方法。 6.contains(“aa”);返回当前 元素是否包含某一个对象。当前放回false。12345678public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\"); list.add(\"BB\"); list.add(\"DD\"); boolean contains = list.contains(\"aa\"); System.out.println(contains);&#125; 7.get(1);获取当前集合中指定位置的元素，这里返回BB12345678public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\"); list.add(\"BB\"); list.add(\"DD\"); String string = list.get(1); System.out.println(string);&#125; 8.indexOf(“BB”);返回当前集合中首次出现形参对象的位置，如果集合中不存在就返回-1.12345678public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"AA\"); list.add(\"BB\"); list.add(\"BB\"); int indexOf = list.indexOf(\"BB\"); System.out.println(indexOf);&#125; 简单的方法就查询jdkAPI文档吧，下面做简要的说明： size();放回当前集合元素个数. isEmpty();判断集合是否为空，返回布尔类型的结果。 lastIndexOf(Object o);返回集合中最后一次出现形参元素的索引，不存在就返回-1。 toArray();将集合转换为数组 set(int index,E element);用指定元素替代集合中指定位置的元素。 remove(Object o);移除集合中首次出现的元素。 remove(int index);移除集合中指定位置的元素。ArrayList实现原理（源码解读） ArrayList是List接口的可变数组的实现，允许包括null在内的所有元素，既然是数组，那么该类肯定会存在改变存储列表的数组大小的方法。 每一个ArrayList实例都有一个容量，该容量是用来存储列表元素的数组的大小，他总是等于列表的大小，随着往ArrayList中添加元素，这个容量也会相应的总动增长，自动增长就会带来数据向新数组的重新拷贝。1.底层使用数组实现1private transient Object[] elementData; 2.构造方法如下：1234567891011121314151617public ArrayList() &#123; this(10);&#125; public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity];&#125; public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 在初始化ArrayList实例时，可以构造一个初始容量为10的空列表，也可以构造一个指定初始容量的空列表以及构造一个包含指定Collection元素的列表。 3.如何实现存储的？3.1使用set(int index, E element) ;方法，用指定的元素替代指定位置的元素1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 3.2add(E e);将指定的元素添加到集合尾部12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 3.3add(int index, E element)将指定的元素插入此列表中的指定位置123456789101112public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(\"Index: \"+index+\", Size: \"+size); // 如果数组长度不足，将进行扩容。 ensureCapacity(size+1); // Increments modCount!! // 将 elementData中从Index位置开始、长度为size-index的元素， // 拷贝到从下标为index+1位置开始的新的elementData数组中。 // 即将当前位于该位置的元素以及所有后续元素右移一个位置。 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 4.如何读取元素？12345public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 5.删除元素12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 注意：从集合中移除一个元素，如果这个元素不是最后一个元素，那么这个元素的后面元素会想向左移动一位。 5.如何实现扩容的？123456789101112131415161718192021public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) ensureCapacityInternal(minCapacity);&#125; private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 从上面的代码可以看出，数组进行扩容时，会将老数组的所有元素拷贝到新数组中，其中新数组的大小是老数组大小右移一位再加上老数组的大小。 6.手动调整底层数组的容量为列表实际元素大小的方法1234567public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----集合之LinkList","slug":"JavaEE基础知识学习----集合之LinkList","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:44.462Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----集合之LinkList/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----集合之LinkList/","excerpt":"","text":"LinkList概述LinkList是List接口的实现类，与ArrayList不同的是，ArrayList采用的是大小可变的数组实现，LinkList采用的是双向链表的实现方式，基于链表的实现方式使得在插入和删除是比ArrayList要好一些，但是随机访问则数组要好一些。 实现原理（源码分析）实现原理要点概括1.LinkList采用的是双向链表非同步的方式实现，允许null在内的所有元素。 LinkList类的定义123public class LinkedList&lt;E&gt;extends AbstractSequentialList&lt;E&gt;implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125; 从上面的代码可以看出一下几点； LinkList继承了AbstractSequentialList的双向链表，这个和ArrayList不同 ArrayList继承的是AbstractList。 LinkList实现了List接口，能对它进行队列操作。 LinkList实现了Deque接口，表明可以用作双向队列操作。 LinkList实现了Cloneable接口，表明可以实现克隆操作。 Linklist实现了Serializable接口，表明支持序列化，可以通过序列化传输。继承AbstractSequentialList的必然性 AbstractSequentialList的源码如下：1public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; 可以看出AbstractSequentialList这个类是一个抽象类，而且也继承了AbstractList类，再看里面的方法，如下：12345678910111213141516171819202122232425262728293031323334353637public E get(int index) &#123; try &#123; return listIterator(index).next(); &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException(\"Index: \"+index); &#125; &#125; public E set(int index, E element) &#123; try &#123; ListIterator&lt;E&gt; e = listIterator(index); E oldVal = e.next(); e.set(element); return oldVal; &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException(\"Index: \"+index); &#125; &#125;public void add(int index, E element) &#123; try &#123; listIterator(index).add(element); &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException(\"Index: \"+index); &#125; &#125;public E remove(int index) &#123; try &#123; ListIterator&lt;E&gt; e = listIterator(index); E outCast = e.next(); e.remove(); return outCast; &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException(\"Index: \"+index); &#125; &#125; 从上述代码可以看出，AbstractSequentialList类实现了这个操作集合的基本也是骨干的方法，LinkList是双向链表，他继承了AbstractSequentialList这个类，就相当于已经实现了这些方法。 双向链表因为我还是小白，对于数据结构方面的知识，还有很多不知道，简单说说什么是链表吧， 链表：链式存储的线性表，简称链表，链表由多个链表元素组成，这些元素称之为节点，节点之间通过逻辑连接，形成链式存储结构。 链表分为两个域：值域和链域，值域用来存放节点的值，链域用来存放下一个节点的地址或位置。 双向链表中的节点，保存业务数据和前一个节点信息和后一个节点信息，如下： LinkList类属性123transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; first是双向链表的头结点，last是尾节点，size是双向链表中节点实例的个数。其中Node类如下：1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node节点类很简单，item存放数据，next和prev分别存放前后节点信息。 LinkList构造器方法12345public LinkedList() &#123;&#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; LinkList集合中添加单一元素向LinkList中添加元素，调用add(E e);方法，源码如下：123456789101112131415public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123;final Node&lt;E&gt; l = last;final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);last = newNode;if (l == null) first = newNode;else l.next = newNode;size++;modCount++;&#125; 源码分析：调用add(E e)方法添加元素，方法中调用linkLast(E e)方法，得到当前集合的最后节点，再创建一个新的节点，创建节点的方法，如下：12345Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev;&#125; 将最后节点改为型创建的节点，在判断添加元素之前的末尾节点是否为空，不为空，就指向新节点，同时将节点实例个数加1。 LinkList集合移除指定元素123456789101112131415161718192021222324252627282930313233343536public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;E unlink(Node&lt;E&gt; x) &#123;// assert x != null;final E element = x.item;final Node&lt;E&gt; next = x.next;final Node&lt;E&gt; prev = x.prev;if (prev == null) &#123; first = next;&#125; else &#123; prev.next = next; x.prev = null;&#125;if (next == null) &#123; last = prev;&#125; else &#123; next.prev = prev; x.next = null;&#125;x.item = null;size--;modCount++;return element;&#125; 源码分析：从LinkList集合中移除一个元素时调用remove(int index)，先调用 checkElementIndex(index);方法对要移除的位置进行判断，判断是否大于0并且小于当前集合的大小，否则抛出IndexOutOfBoundsException异常。在执行unlink(node(index));方法，根据node(index)方法得到指定位置的节点，在执行删除操作。 LinkList清除元素123456789101112public void clear() &#123; for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; 取LinkList元素1234567891011121314151617public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 数据包含1234567891011121314151617181920public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125; public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 从前往后找，返回形参元素在集合中的索引，不存在就返回-1。 迭代器，使用listIterator(int index)1234public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; 由于LinkList也继承了AbstractSequentialList，也可以使用iterator遍历，如下： 12345678910111213public static void main(String[] args) &#123; LinkedList&lt;String&gt; linkedList = new LinkedList&lt;String&gt;(); linkedList.add(\"AA\"); linkedList.add(\"BB\"); ListIterator&lt;String&gt; listIterator = linkedList.listIterator(); while(listIterator.hasNext())&#123; System.out.println(listIterator.next()); &#125; Iterator&lt;String&gt; iterator = linkedList.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 反向迭代器，使用descendingIterator()方法。123456789101112131415public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator();&#125;private class DescendingIterator implements Iterator&lt;E&gt; &#123; private final ListItr itr = new ListItr(size()); public boolean hasNext() &#123; return itr.hasPrevious(); &#125; public E next() &#123; return itr.previous(); &#125; public void remove() &#123; itr.remove(); &#125;&#125; 使用方法同正向迭代器一样。 总结：LinkList的相关用法和ArrayList一样，我们学习的是他们的实现原理，重点在于源码解析和数据结构，有关数据结构的深层次学习将在后续学习中。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----集合之HashMap","slug":"JavaEE基础知识学习----集合之HashMap","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:39.073Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----集合之HashMap/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----集合之HashMap/","excerpt":"","text":"HashMap基本知识概述 Map与Collection并列存在，Map用于保存具有映射关系的数据。 Map中的key和value都是可以是任何引用类型的数据。key和value存在单向一对一的关系。 Map接口的实现类有HashTable，HashMap等。 常用String类来作为Map中的key。 HashMap是Map接口的实现类，继承了AbstractMap类，以key-value的形式存在，系统根据hash算法来计算key-value的存储位置。 HashMap中key用Set来存放，key不允许重复，value是用Collection存放，可重复，一个key-value对，就是一个Entry,所有的Entry是用Set存放，不可重复。 如果key用自定义的类，那么自定义的类就必须重写equals方法和hashCode方法。使用方法1HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); 说明：hashMap这个map的key是String类型的，value是Object类型的。 常用方法1.Object put(Object key,Object value);添加方法12345678public static void main(String[] args) &#123; HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;(); hashMap.put(\"AA\", \"张三\"); hashMap.put(null, null); hashMap.put(new Person(\"孙悟空\", 5000), \"美猴王\"); hashMap.put(new Person(\"孙悟空\", 5000), \"七天大圣\"); System.out.println(hashMap);&#125; 说明： HashMap可以放入null的键值对。 HashMap的key是不允许重复的，如果用自定义的类做key,那么就必须重写equals和hashCode方法。 如果添加两个相同的key,后面的会替换前面的。2.Object remove(Object key);移除方法1234567public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); hashMap.remove(\"BB\"); System.out.println(hashMap);&#125; 3.void putAll(Map t);添加一个map12345678910public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); HashMap&lt;String,Object&gt; hashMap2 = new HashMap&lt;String, Object&gt;(); hashMap2.put(\"CC\", new Person(\"孙悟空\", 500)); hashMap2.put(\"DD\", new Person(\"嫦娥\", 700)); hashMap.putAll(hashMap2); System.out.println(hashMap);&#125; 4.void clear();清除数据1234567public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); hashMap.clear(); System.out.println(hashMap);&#125; 5.Object get(Object key);根据key取出value1234567public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); Person person = (Person) hashMap.get(\"AA\"); System.out.println(person.name);&#125; 6.boolean containsKey(Object key);是否包含这个key，这里返回false。1234567public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); boolean containsKey = hashMap.containsKey(\"aa\"); System.out.println(containsKey);&#125; 7.boolean containsValue(Object value);HasHMap是否包含这个value12345678public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); hashMap.put(\"CC\", new Person(\"李四\", 14)); boolean containsValue = hashMap.containsValue(new Person(\"李四\", 14)); System.out.println(containsValue);&#125; 说明： 自定义类做key就必须重写equals方法，这里如果不重写就返回false，否则就返回true。 8.int size();输出HashMap中键值对的个数。123456789public static void main(String[] args) &#123; HashMap&lt;String,Object&gt; hashMap = new HashMap&lt;String, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\", 12) ); hashMap.put(\"BB\", new Person(\"李四\", 13)); hashMap.put(\"BB\", new Person(\"李四\", 13)); hashMap.put(null, null); int size = hashMap.size(); System.out.println(size);&#125; 说明：这里是3，其中hashMap.put(“BB”, new Person(“李四”, 13));重复添加。 9.boolean isEmpty();判断HashMap是否为空1234567public static void main(String[] args) &#123; HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;(); hashMap.put(\"AA\", \"张三\"); hashMap.put(null, null); hashMap.isEmpty(); System.out.println(hashMap);&#125; 10.boolean equals(Object obj);比较两个Map是否相同123456789public static void main(String[] args) &#123; HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\",12)); hashMap.put(\"BB\", new Person(\"李四\",13)); HashMap&lt;Object,Object&gt; hashMap2 = new HashMap&lt;Object, Object&gt;(); hashMap2.put(\"AA\", new Person(\"张三\",12)); boolean equals = hashMap.equals(hashMap2); System.out.println(equals);&#125; 11.Set keySet();遍历HashMap中的所有Key1234567891011public static void main(String[] args) &#123; HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\",12)); hashMap.put(\"BB\", new Person(\"李四\",13)); hashMap.put(\"CC\", new Person(\"王五\",14)); hashMap.put(\"DD\", new Person(\"陈六\",14)); Set&lt;Object&gt; entrySet = hashMap.keySet(); for (Object entry : entrySet) &#123; System.out.println(entry); &#125;&#125; 12.Collection values();遍历HashMap中的value1234567891011121314151617public static void main(String[] args) &#123; HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\",12)); hashMap.put(\"BB\", new Person(\"李四\",13)); hashMap.put(\"CC\", new Person(\"王五\",14)); hashMap.put(\"DD\", new Person(\"陈六\",14)); Collection&lt;Object&gt; values = hashMap.values(); //values的遍历方式一 for (Object object : values) &#123; System.out.println(object); &#125; //values的遍历方式二 Iterator&lt;Object&gt; iterator = values.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 13.Set entrySet();遍历HashMap的键值对1234567891011public static void main(String[] args) &#123; HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;(); hashMap.put(\"AA\", new Person(\"张三\",12)); hashMap.put(\"BB\", new Person(\"李四\",13)); hashMap.put(\"CC\", new Person(\"王五\",14)); hashMap.put(\"DD\", new Person(\"陈六\",14)); Set&lt;Entry&lt;Object,Object&gt;&gt; entrySet = hashMap.entrySet(); for (Entry&lt;Object, Object&gt; entry : entrySet) &#123; System.out.println(entry); &#125;&#125; 小结 HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。 HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。HashMap底层实现原理在HashMap的源码中我们可以看出HashMap是一个数组和链表结合的一种数据结构，1.HashMap属性123456transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; 可以看出，HashMap底层是一个数组，数据中的每一个元素就是Entry类型，Entry又是一个链表结构。 2.HashMap构造方法12345678910111213141516171819202122232425262728//构建一个初始容量为16，负载因子为0.75的HashMap。 public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); table = new Entry[DEFAULT_INITIAL_CAPACITY]; init();&#125;//构建一个指定容量和负载因子的HashMap public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)(capacity * loadFactor); table = new Entry[capacity]; init();&#125; 说明： HashMap的容量就是底层table数组的长度。 负载因子：散列表的实际元素数目/散列表的容量，负载因子衡量的是一个散列表的空间使用程度，值越大代表装填程度越高，反之越小，如果负载因子越大代表空间利用充分，但是查询，搜索效率就降低，过小，空间利用率就降低，3.添加数据方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 public V put(K key, V value) &#123; //判断key是否为空 if (key == null) return putForNullKey(value); //根据key的hashcode值来计算hash值。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); //如果索引i出的Entry不为null，通过循环遍历e的下一个元素 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; //如果索引i出的Entry为null,说明此处没有Entry modCount++; //将key-value放在次索引处 addEntry(hash, key, value, i); return null;&#125; //如果key为空就将value放在数组的第一个位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125;//计算hashcode的 public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125;//计算hash值的static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;//搜索指定Hash在对应table中的索引 static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125;//根据hash值，将key-value放在数组table的索引i位置上。void addEntry(int hash, K key, V value, int bucketIndex) &#123; //获取指定bucketIndex索引处的Entry Entry&lt;K,V&gt; e = table[bucketIndex]; //将新创建的Entry放入bucketIndex索引位置，并让新的Entry指向原来的Entry。 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //如果数组长度不够，就扩容 if (size++ &gt;= threshold) //将table数组的长度扩展到原来的2倍 resize(2 * table.length);&#125; 说明： &amp;是与运算符，将int转为二进制，只有两个位都是1，结果才是1。 小结：从上面的源码可以看出，当我们向HashMap中添加一个元素时，先根据key的hashCode重新计算hash值，根据这个hash值得到这个元素在数组中的位置，也就是数组的下标，如果这个位置已经存放了其他元素，那么他就会以链表的方式存放，新加入的放在链头，最先加入的放在链尾，如果数组上该位置没有元素，就直接放到该位置上。 4.读取数据12345678910111213public V get(Object key) &#123;if (key == null) return getForNullKey();int hash = hash(key.hashCode());for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value;&#125;return null;&#125; 小结：当我们从HashMap中读取一个元素时，首先判断key是否为空，不为空就根据key计算hash值，根据hash值找到数组中对应位置的元素，然后通过key的equals方法，在对应位置的链表中找到需要元素的值。 ##HashMap 总结 HashMap是数组和链表的结合体，允许插入null的key和value。 HashMap是线程不安全的，采用Fail-Fast机制。 HashMap进行数组扩容时，需要重新计算每个元素在数组中的位置，耗性能。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----Java8-2-函数式接口","slug":"JavaEE进阶知识学习----Java8-2-函数式接口","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:39.107Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Java8-2-函数式接口/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Java8-2-函数式接口/","excerpt":"","text":"###四大核心函数接口 Consumer消费型接口： 参数类型 T 返回类型 void 对类型T的对象应用操作 Supplier供给型接口： 参数类型 无 返回类型 T 返回类型为T的对象 Function&lt;T,R&gt;函数型接口： 参数类型 T 返回类型 R 对了类型为T的对象应用操作，并返回结果 Predicate断言型接口： 参数类型 T 返回类型 boolean 确定类型为T的对象是否满足某约束，并返回布尔值。 Consumer示例如下： @Test public void test1(){ happy(10000,(m) -&gt; System.out.println(&quot;购买笔记本电脑，每次消费&quot;+m+&quot;元&quot;)); } public void happy(double money, Consumer&lt;Double&gt; con){ con.accept(money); } Supplier示例如下： @Test public void test2(){ List&lt;Integer&gt; list = getNumList(10, () -&gt; (int)(Math.random()*100)); for(Integer num: list){ System.out.println(num); } } public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;num ; i++) { Integer n = sup.get(); list.add(n); } return list; } 上述使用Lambda表达式就是产生10个100以内的随机数。Function示例如下 @Test public void test3(){ String upperStr = strHandle(&quot;abce&quot;,(str) -&gt; str.toUpperCase()); System.out.println(upperStr); } public String strHandle(String str, Function&lt;String,String&gt; fun){ return fun.apply(str);//对str进行处理，具体处理方式调用的时候使用Lambda表达式指定 } Predicate示例如下，将满足条件的字符串添加到集合中 @Test public void test4(){ List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;,&quot;www.baidu.com&quot;,&quot;zhangsan&quot;,&quot;lisi&quot;); List&lt;String&gt; strList = filterStr(list,(s) -&gt; s.length() &gt; 4); for(String str: strList){ System.out.println(str); } } public List&lt;String&gt; filterStr(List&lt;String&gt; list , Predicate&lt;String&gt; per){ List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str: list) { if(per.test(str)){//对str进行过滤操作，具体操作调用的时候才执行 strList.add(str); } } return strList; } ####小结 Consumer消费型是传入一个参数，进行处理 Supplier供给型是得到一些结果 Function函数型是传入一个参数，处理后返回一个结果 Predicate断言型就是做一些判断操作 有无参数和返回值是指Predicate per等调用的方法需不需要参数和有无返回值，例如：per.test(str)、fun.apply(str)、sup.get()等。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----Java8-4-2-StreamAPI","slug":"JavaEE进阶知识学习----Java8-4-2-StreamAPI","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:04.866Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Java8-4-2-StreamAPI/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Java8-4-2-StreamAPI/","excerpt":"","text":"###StreamAPI练习1.给定一个数字列表，返回一个由每一个数的平方构成的列表。 @Test public void test(){ Integer[] nums = new Integer[]{1,2,3,4,5}; Arrays.stream(nums) .map((x) -&gt; x*x) .forEach(System.out::println); } 2.使用map和reduce方法数一数流中有多少个Employee @Test public void test1(){ Optional&lt;Integer&gt; count = employees.stream() .map((e) -&gt; 1) .reduce(Integer::sum); System.out.println(count.get()); } ####交易员类 public class Trader { private String name; private String city; public Trader() { } public Trader(String name, String city) { this.name = name; this.city = city; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } @Override public String toString() { return &quot;Trader [name=&quot; + name + &quot;, city=&quot; + city + &quot;]&quot;; } } ####交易类 public class Transaction { private Trader trader; private int year; private int value; public Transaction() { } public Transaction(Trader trader, int year, int value) { this.trader = trader; this.year = year; this.value = value; } public Trader getTrader() { return trader; } public void setTrader(Trader trader) { this.trader = trader; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } @Override public String toString() { return &quot;Transaction [trader=&quot; + trader + &quot;, year=&quot; + year + &quot;, value=&quot; + value + &quot;]&quot;; } } ####练习 public class TestTransaction { List&lt;Transaction&gt; transactions = null; @Before public void before(){ Trader raoul = new Trader(&quot;Raoul&quot;, &quot;Cambridge&quot;); Trader mario = new Trader(&quot;Mario&quot;, &quot;Milan&quot;); Trader alan = new Trader(&quot;Alan&quot;, &quot;Cambridge&quot;); Trader brian = new Trader(&quot;Brian&quot;, &quot;Cambridge&quot;); transactions = Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); } //1. 找出2011年发生的所有交易， 并按交易额排序（从低到高） @Test public void test1(){ transactions.stream() .filter((t) -&gt; t.getYear() == 2011)//过滤2011年的交易 .sorted((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())) .forEach(System.out::println); } //2. 交易员都在哪些不同的城市工作过？ @Test public void test2(){ transactions.stream() .map((t) -&gt; t.getTrader().getCity()) .distinct() .forEach(System.out::println); } //3. 查找所有来自剑桥的交易员，并按姓名排序 @Test public void test3(){ new ArrayList&lt;Integer&gt;(); transactions.stream() .filter((t) -&gt; t.getTrader().getCity().equals(&quot;Cambridge&quot;)) .map(Transaction::getTrader) .sorted((t1,t2) -&gt; t1.getName().compareTo(t2.getName())) .distinct() .forEach(System.out::println); } //4. 返回所有交易员的姓名字符串，按字母顺序排序 @Test public void test4(){ transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .forEach(System.out::println); System.out.println(&quot;====================================&quot;); String str = transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .reduce(&quot;&quot;,String::concat); System.out.println(str); } //5. 有没有交易员是在米兰工作的？ @Test public void test5(){ Boolean b1 = transactions.stream() .anyMatch((t) -&gt; t.getTrader().getCity().equals(&quot;Milan&quot;)); System.out.println(b1); } //6. 打印生活在剑桥的交易员的所有交易额 @Test public void test6(){ Optional&lt;Integer&gt; sum = transactions.stream() .filter((e) -&gt; e.getTrader().getCity().equals(&quot;Cambridge&quot;)) .map(Transaction::getValue) .reduce(Integer::sum); System.out.println(sum.get()); } //7. 所有交易中，最高的交易额是多少 @Test public void test7(){ Optional&lt;Integer&gt; max = transactions.stream() .map((t) -&gt; t.getValue()) .max(Integer::compare); System.out.println(max); } //8. 找到交易额最小的交易 @Test public void test8(){ Optional&lt;Transaction&gt; op = transactions.stream() .min((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())); System.out.println(op.get()); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----JavaNIO-1-缓冲区-通道","slug":"JavaEE进阶知识学习----JavaNIO-1-缓冲区-通道","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:15.535Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----JavaNIO-1-缓冲区-通道/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----JavaNIO-1-缓冲区-通道/","excerpt":"","text":"###Java NIO简介Java NIO是一个全新的IO API,可以代替标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式却完全不同，NIO支持面向缓冲区，基于通道的IO操作方式，NIO可以更加高效的进行文件的读写操作。 ###NIO与IO的区别 IO：面向流、阻塞IO、无选择器 NIO：面向缓冲区、非阻塞IO、有选择器 ###IO传输数据模式程序与文件之间的传输是单向字节流的流动，所以叫面向流的一种传输方式。 ###NIO传输数据的模式在NIO中通道只是负责连接，数据存储在缓冲区中，移动缓冲区就可以实现文件的传输，这就是NIO面向缓冲区的双向文件传输模式。 ###什么是通道和缓冲区通道Channel表示打开IO设备（文件，套接字）的连接，如需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理，简单来讲，就是通过负责传输，缓冲区负责存储。 ####缓冲区在Java NIO中缓冲区负责数据的存储，缓冲区就是数组，用于不同数据类型的数据，因此，根据数据类型不同，就会有不同的数据类型的缓冲区，例如ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer（没有boolean类型的缓冲区），上述的缓冲区都是通过allocate()方式获取。缓冲区存储数据的核心方法： put()：存入数据到缓冲区。 get()：获取缓冲区数据。 ####缓冲区的四个核心属性 private int mark = -1;//标记，表示记录当前position位置，可以通过reset()恢复到mark的位置 private int position = 0;//位置，表示缓冲区正在操作数据的位置 private int limit;//界限：表示缓冲区可以操作数据的大小（limit后面的数据不能进行读写） private int capacity;//容量，表示缓冲区中最大存储数据的容量，一旦声明就不能改变 图解属性 ###Buffer基本用法实现 public void test1(){ String str = &quot;Hello&quot;; //分配一个指定大小的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); //利用put方法存储数据 buffer.put(str.getBytes()); //切换到读数据模式 buffer.flip(); //利用get方法读数据 byte [] dst = new byte[buffer.limit()]; buffer.get(dst); //打印读到的数据 System.out.println(new String(dst,0,dst.length)); //rewind():可重复读数据 buffer.rewind(); //clear():清空缓冲区,但是缓冲区中的数据依然被存在，但是数据处于“被遗忘”状态 buffer.clear(); } ####mark属性的用法 public void test2(){ String str = &quot;abcde&quot;; ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.put(str.getBytes()); buffer.flip(); System.out.println(&quot;没有读数据=====&quot;+buffer.position()); //第一次读数据 byte[] dst = new byte[buffer.limit()]; buffer.get(dst,0,2); System.out.println(new String(dst,0,2)); System.out.println(&quot;mark标记前的position=====&quot;+buffer.position()); //Mark标记 buffer.mark(); System.out.println(&quot;mark标记后============&quot;); //第二次读数据 buffer.get(dst,2,2); System.out.println(new String(dst,2,2)); System.out.println(&quot;第二次读取数据后=====&quot;+buffer.position()); //reset()方法后 buffer.reset(); System.out.println(&quot;reset方法后的position=====&quot;+buffer.position()); //判断缓冲区是否还有数据 if(buffer.hasRemaining()){ //输出还有数据的数量 System.out.println(buffer.remaining()); } } ###直接缓冲区和非直接缓冲区非直接缓冲区：通过allocate()方法分配缓冲区，将缓冲区建立在JVM的内存中。直接缓冲区：通过allocateDirect()方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率。非直接缓冲区图解如下直接缓冲区图解如下 ###通道通道是由java.nio.channels包定义的，channel表示IO源与目标打开的连接，channel类似于传统的“流”，只不过channel本身不能直接访问数据，channel只能与buffer交互。channel本身不存储数据，因此需要配合缓冲区进行传输。通过的主要实现类有如下： FileChannel SocketChannel ServerSocketChannel DatagramChannel 获取通道的三种方式 java针对支持通道的类提供了getChannel()方法。本地IO:FileInputStream/FileOutputStream、RandomAcsessFile。网络IO:Socket、ServerSocket、DatagramSocket。 在jdk1.7中的NIO.2针对各个通道提供了静态方法open(); Files工具类的newByteChannel() //利用通道完成文件的复制(非直接缓冲区) @Test public void test1(){ FileInputStream fis = null; FileOutputStream fos = null; //获取通道 FileChannel inChannel = null; FileChannel outChannel = null; try { fis = new FileInputStream(&quot;1.jpg&quot;); fos = new FileOutputStream(&quot;2.jpg&quot;); inChannel = fis.getChannel(); outChannel = fos.getChannel(); //分配指定大小的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); //将通道中的数据存入缓存区中 while(inChannel.read(buffer) !=-1){ buffer.flip();//切换到数据模式 //将缓冲区中的数据写入通道中 outChannel.write(buffer); buffer.clear();//清空缓存区 } }catch (IOException e) { e.printStackTrace(); }finally{ if(outChannel != null){ try { outChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(inChannel != null){ try { inChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } ####使用直接缓冲区完成文件的复制 @Test public void test2() throws IOException{ FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.jpg&quot;), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE_NEW); //内存映射文件 MappedByteBuffer inMapperBuf = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMapperBuf = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size()); //直接对缓冲区进行数据的读写操作 byte[] dst = new byte[inMapperBuf.limit()]; inMapperBuf.get(dst); outMapperBuf.put(dst); inChannel.close(); outChannel.close(); } ###通道之间的数据传输使用上面的两种方式实现文件的复制，有不少的麻烦，使用通道之间的数据传输就方便很多。 @Test public void test3() throws IOException{ FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(&quot;4.jpg&quot;), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE_NEW); inChannel.transferTo(0, inChannel.size(), outChannel); inChannel.close(); outChannel.close(); } 还有transferFrom也可以实现。 outChannel.transferFrom(inChannel, 0, inChannel.size());","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----JavaNIO-3-非阻塞式-DatagramChannel","slug":"JavaEE进阶知识学习----JavaNIO-3-非阻塞式-DatagramChannel","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:25.273Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----JavaNIO-3-非阻塞式-DatagramChannel/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----JavaNIO-3-非阻塞式-DatagramChannel/","excerpt":"####使用非阻塞式实现(重点)","text":"####使用非阻塞式实现(重点) //客户端 @Test public void client() throws IOException{ //获取通道 SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(“127.0.0.1”,9898)); //切换到非阻塞模式 sChannel.configureBlocking(false); //分配指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); //发送数据给服务端 Scanner scan = new Scanner(System.in); while(scan.hasNext()){ String string = scan.next(); buf.put((new Date().toString()+”\\n”+string).getBytes()); buf.flip(); sChannel.write(buf); buf.clear(); } //关闭通道 sChannel.close(); } //服务端 @Test public void server() throws IOException{ //获取通道 ServerSocketChannel ssChannel = ServerSocketChannel.open(); //切换为非阻塞模式 ssChannel.configureBlocking(false); //绑定连接 ssChannel.bind(new InetSocketAddress(9898)); //获取选择器 Selector selector = Selector.open(); //将通道注册到选择器上,并且指定监听接收事件 ssChannel.register(selector, SelectionKey.OP_ACCEPT); //通过轮询式的方式获取选择器中准备就绪的事件 while(selector.select() &gt; 0){ //获取当前选择器中所有注册的选择键（已就绪的监听事件） Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) { //获取准备就绪的事件 SelectionKey sk = it.next(); //判断是什么事件就绪（接收事件|连接事件|读事件|写事件就绪） if(sk.isAcceptable()){ //若接收事件就绪，获取客户端连接 SocketChannel sChannel = ssChannel.accept(); //切换到非阻塞模式 sChannel.configureBlocking(false); //将通道注册到选择器上 sChannel.register(selector, SelectionKey.OP_READ); }else if(sk.isReadable()){ //获取当前选择器上读就绪状态的通道 SocketChannel sChannel = (SocketChannel) sk.channel(); //读取数据 ByteBuffer buf = ByteBuffer.allocate(1024); int len = 0; while((len = sChannel.read(buf)) &gt; 0){ buf.flip(); System.out.println(new String(buf.array(),0,len)); buf.clear(); } } //取消选择键（SelectionKey） it.remove(); } } } 说明： 创建Selector，通过调用Selector.open()方法 向选择器中注册通道sChannel.register(selector, SelectionKey.OP_READ); 当调用register将通道注册时，选择器对通道的监听事件，需要通过第二个参数指定，可以监听的事件如下 读事件：SelectionKey.OP_READ 写事件：SelectionKey.OP_WRITE 连接事件:SelectionKey.OP_CONNECT 接收事件：SelectionKey.OP_ACCEPT 如果注册时不止监听一个事件，则可以使用“位或”操作符连接。如下 int interestSet = SelectionKey.OP_RED|SelectionKey.OP_WRITE SelectionKey：表示的是SelectableChannel和Selector之间的注册关系，每次向选择器注册通道时就会选择一个事件，选择键包含两个表示为整数的操作集，操作集的每一位都表示该键的通道所支持的一类可选择操作。其中SelectionKey的实例方法如下; int interestOps() 获取此键的 interest 集合。 SelectionKey interestOps(int ops) 将此键的 interest 集合设置为给定值。 boolean isAcceptable() 测试此键的通道是否已准备好接受新的套接字连接。 boolean isConnectable() 测试此键的通道是否已完成其套接字连接操作。 boolean isReadable() 测试此键的通道是否已准备好进行读取。 boolean isValid() 告知此键是否有效。 isWritable() 测试此键的通道是否已准备好进行写入。 int readyOps()获取此键的 ready 操作集合。 ####Selector的常用方法 Set keys() 返回SelectionKey集合，代表注册在该Selector上的channel Set selectedKeys()被选择的SelectionKey集合，返回此Selector的已选择键集。 int select() 监控所有注册的Channel，当他们中间有需要处理的IO操作时，该方法返回，并将对应得SelectionKey加入被选择的SelectionKey集合中，该方法返回这些Channel的数量。 int select(long timeout) 选择一组键，其相应的通道已为 I/O 操作准备就绪。 Set selectedKeys() 返回此选择器的已选择键集。 int selectNow() 选择一组键，其相应的通道已为 I/O 操作准备就绪。 Selector wakeup() 使尚未返回的第一个选择操作立即返回。 SocketChannel是一个连接到TCP网络套接字的通道，操作步骤如下: 打开SocketChannel 读写数据 关闭SocketChannel ServerSocketChannel是一个可以监听新进来的TCP连接的通道。 ###DatagramChannelDatagramChannel是一个能收发UDP包的通道，操作步骤如下： 打开DatagramChannel 接收和发送数据 DatagramChannel实例如下 public class TestNonBlockingNIO2 { @Test public void send() throws IOException{ DatagramChannel dc = DatagramChannel.open(); dc.configureBlocking(false); ByteBuffer buf = ByteBuffer.allocate(1024); Scanner scan = new Scanner(System.in); while(scan.hasNext()){ String str = scan.next(); buf.put((new Date().toString()+&quot;:\\n&quot;+str).getBytes()); buf.flip(); dc.send(buf, new InetSocketAddress(&quot;127.0.0.1&quot;,9898)); buf.clear(); } dc.close(); } @Test public void receive() throws IOException{ DatagramChannel dc = DatagramChannel.open(); dc.configureBlocking(false); dc.bind(new InetSocketAddress(9898)); Selector selector = Selector.open(); dc.register(selector, SelectionKey.OP_READ); while(selector.select() &gt; 0){ Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while(it.hasNext()){ SelectionKey sk = it.next(); if(sk.isReadable()){ ByteBuffer buf = ByteBuffer.allocate(1024); dc.receive(buf); buf.flip(); System.out.println(new String(buf.array(),0,buf.limit())); } } it.remove(); } } } ###管道（Pipe）管道是两个线程之间的单向数据连接，Pipe有一个source通道和一个sink通道，数据会被写入sink通道，从source通道读取图解如下所示Pipe管道实例如下 @Test public void testPipe() throws IOException{ //获取管道 Pipe pipe = Pipe.open(); //将缓冲区中的数据写入管道 ByteBuffer buf = ByteBuffer.allocate(1024); Pipe.SinkChannel sinkChannel = pipe.sink(); buf.put(&quot;通过管道发送数据&quot;.getBytes()); buf.flip(); sinkChannel.write(buf); //在一个线程中共用一个pipe读取数据，可以开两个线程 Pipe.SourceChannel sourceChannel = pipe.source(); buf.flip(); int len = sourceChannel.read(buf); System.out.println(new String(buf.array(),0,len)); sourceChannel.close(); sinkChannel.close(); }","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----JavaNIO-4-NIO2-File类","slug":"JavaEE进阶知识学习----JavaNIO-4-NIO2-File类","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:30.476Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----JavaNIO-4-NIO2-File类/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----JavaNIO-4-NIO2-File类/","excerpt":"###NIO.2在jdk7之后，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，我们称之为NIO.2主要有Path、Paths、Files。java.nio.Path接口代表一个与平台无关的平台路径，描述目录结构中文件的位置。 Paths提供了get()方法用来获取Path对象，Path get(String first…..)用于将多个字符串串联成路径","text":"###NIO.2在jdk7之后，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，我们称之为NIO.2主要有Path、Paths、Files。java.nio.Path接口代表一个与平台无关的平台路径，描述目录结构中文件的位置。 Paths提供了get()方法用来获取Path对象，Path get(String first…..)用于将多个字符串串联成路径 Path常用的方法如下: boolean endsWith(Path other)判断是否以Path路径结束 boolean endsWith(String other)判断是否以Path路径开始 Path getFileName()返回与调用Path对象关联的文件名 Path getName(int index)返回指定索引位置index的路径名称 int getNameCount()返回Path根目录后面元素的数量 Path getParent()返回Path对象包含整个路径，不包含Path对象指定的文件路径 Path getRoot()返回调用Path对象的根路径 boolean isAbsolute()判断是否为绝对路径 Path resolve(Path other)将相对路径解析为绝对路径 Path toAbsolutePath()作为绝对路径返回调用Path对象 String toString()返回调用Path对象的字符串表示形式 ####Files类java.nio.file.Files用于操作文件或目录的工具类Files关于文件的常用方法如下： Path copy(InputStream in, Path target, CopyOption… options);文件的复制 createDirectory(Path dir, FileAttribute&lt;?&gt;… attrs)创建一个目录 createFile(Path path, FileAttribute&lt;?&gt;… attrs)创建一个文件 delete(Path path)删除一个文件 move(Path source, Path target, CopyOption… options)将src移动到dest位置 size(Path path)返回Path指定文件的大小 Files关于判断的常用方法如下： exists(Path path, LinkOption… options)判断文件是否存在 isDirectory(Path path, LinkOption… options)判断是否是目录 isExecutable(Path path)判断是否是可执行文件 isHidden(Path path)判断是否是隐藏文件 isReadable(Path path)判断文件是否可读 isWritable(Path path)判断文件是否可写 notExists(Path path, LinkOption… options)判断文件是否不存在 Files关于操作内容的常用方法如下： newByteChannel(Path path, Set&lt;? extends OpenOption&gt; options, FileAttribute&lt;?&gt;… attrs)获取与指定文件的连接 newDirectoryStream(Path dir, DirectoryStream.Filter&lt;? super Path&gt; filter)打开Path指定目录 newInputStream(Path path, OpenOption… options)获取inputStream对象 newOutputStream(Path path, OpenOption… options)获取outputStream对象 ###暂告一段落，这是一场无情的战争！！！","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----P3C问题总结","slug":"JavaEE基础知识学习-----P3C问题总结","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:46.109Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习-----P3C问题总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习-----P3C问题总结/","excerpt":"P3C常用问题整理Object的equals方法容易抛出空指针异常，应使用常量和确定有值的对象来调用equals方法，如下","text":"P3C常用问题整理Object的equals方法容易抛出空指针异常，应使用常量和确定有值的对象来调用equals方法，如下12if(str == \"2\" || \"2\".equals(str))&#123;&#125; // 正确写法if(str == \"2\" || str.equals(\"2\"))&#123;&#125; // 错误写法","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----Java8-6-时间API","slug":"JavaEE进阶知识学习----Java8-6-时间API","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:10.963Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Java8-6-时间API/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Java8-6-时间API/","excerpt":"","text":"###LocalDateTimeLocalDateTime是一个不可变的日期时间对象，代表日期时间，通常被视为年 - 月 - 日 - 时 - 分 - 秒。 ####方法摘要 Temporal adjustInto(Temporal temporal) 调整指定的时间对象与此对象具有相同的日期和时间。 OffsetDateTime atOffset(ZoneOffset offset) 将此日期时间与偏移量相结合以创建 OffsetDateTime 。 ZonedDateTime atZone(ZoneId zone) 将此日期时间与时区相结合以创建 ZonedDateTime 。 int compareTo(ChronoLocalDateTime&lt;?&gt; other) 将此日期时间与其他日期时间进行比较。 boolean equals(Object obj) 检查这个日期时间是否等于另一个日期时间。 String format(DateTimeFormatter formatter) 使用指定的格式化程序格式化此日期时间。 static LocalDateTime from(TemporalAccessor temporal) 从时间对象获取一个 LocalDateTime的实例。 int get(TemporalField field) 从此日期时间获取指定字段的值为 int 。 int getDayOfMonth() 获取月份字段。 DayOfWeek getDayOfWeek() 获取星期几字段，这是一个枚举 DayOfWeek 。 int getDayOfYear() 获得日期字段。 int getHour() 获取时间字段。 long getLong(TemporalField field) 从此日期时间获取指定字段的值为 long 。 int getMinute() 获取小时字段。 Month getMonth() 使用 Month枚举获取月份字段。 int getMonthValue() 将月份字段从1到12。 int getNano() 获得纳秒第二场。 int getSecond() 获得第二分钟的字段。 int getYear() 获取年份字段。 int hashCode() 这个日期时间的哈希码。 boolean isAfter(ChronoLocalDateTime&lt;?&gt; other) 检查这个日期时间是否在指定的日期之后。 boolean isBefore(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否在指定的日期时间之前。 boolean isEqual(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否等于指定的日期时间。 boolean isSupported(TemporalField field) 检查指定的字段是否受支持。 boolean isSupported(TemporalUnit unit) 检查指定的单位是否受支持。 LocalDateTime minus(long amountToSubtract, TemporalUnit unit) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minus(TemporalAmount amountToSubtract) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minusDays(long days) 返回此 LocalDateTime的副本，其中指定的时间间隔以天为单位。 LocalDateTime minusHours(long hours) 以指定的时间段返回此 LocalDateTime的副本，以减少的小时数。 LocalDateTime minusMinutes(long minutes) 返回此 LocalDateTime的副本，以指定的时间间隔减去。 LocalDateTime minusMonths(long months) 返回此 LocalDateTime的副本，指定的时间以月为单位减去。 LocalDateTime minusNanos(long nanos) 返回这个 LocalDateTime的副本，以指定的时间减去纳秒。 LocalDateTime minusSeconds(long seconds) 返回此 LocalDateTime的副本，其中指定的时间间隔以秒为单位。 LocalDateTime minusWeeks(long weeks) 返回此 LocalDateTime的副本，其中指定的周期以周为单位减去。 LocalDateTime minusYears(long years) 返回此 LocalDateTime的副本，并以减去的年份为单位。 static LocalDateTime now() 从默认时区的系统时钟获取当前的日期时间。 static LocalDateTime now(Clock clock) 从指定的时钟获取当前的日期时间。 static LocalDateTime now(ZoneId zone) 从指定时区的系统时钟获取当前的日期时间。 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得LocalDateTime的实例，将第二和纳秒设置为零。 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) 获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得 LocalDateTime的实例，将第二和纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) 获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(LocalDate date, LocalTime time) 从日期和时间获取 LocalDateTime一个实例。 static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) 使用从1970-01-01T00：00：00Z的时代开始的秒数获得一个 LocalDateTime的实例。 static LocalDateTime ofInstant(Instant instant, ZoneId zone) 从 Instant和区域ID获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text) 从一个文本字符串（如 2007-12-03T10:15:30获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) 使用特定的格式化 LocalDateTime从文本字符串获取 LocalDateTime的实例。 LocalDateTime plus(long amountToAdd, TemporalUnit unit) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plus(TemporalAmount amountToAdd) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plusDays(long days) 返回此 LocalDateTime的副本，并以指定的时间段添加天数。 LocalDateTime plusHours(long hours) 以指定的时间（以小时为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMinutes(long minutes) 以指定的时间（以分钟为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMonths(long months) 返回这个 LocalDateTime的副本，其中指定的时间段以月为单位。 LocalDateTime plusNanos(long nanos) 返回这个 LocalDateTime的副本，其指定时间以纳秒为单位。 LocalDateTime plusSeconds(long seconds) 以指定的时间段返回此 LocalDateTime的副本，以秒为单位。 LocalDateTime plusWeeks(long weeks) 返回这个 LocalDateTime的副本，并以指定的周期添加周数。 LocalDateTime plusYears(long years) 返回这个 LocalDateTime的副本，其中指定的时间段以添加的年数表示。 &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) 使用指定的查询查询此日期时间。 ValueRange range(TemporalField field) 获取指定字段的有效值的范围。 LocalDate toLocalDate() 获得这个日期时间的 LocalDate一部分。 LocalTime toLocalTime() 获得这个日期时间的 LocalTime一部分。 String toString() 将此日期时间输出为 String ，例如 2007-12-03T10:15:30 。 LocalDateTime truncatedTo(TemporalUnit unit) 返回此 LocalDateTime的副本， LocalDateTime时间。 long until(Temporal endExclusive, TemporalUnit unit) 根据指定的单位计算到另一个日期时间的时间量。 LocalDateTime with(TemporalAdjuster adjuster) 返回此日期时间的调整副本。 LocalDateTime with(TemporalField field, long newValue) 返回此日期时间的副本，并将指定的字段设置为新值。 LocalDateTime withDayOfMonth(int dayOfMonth) 返回此 LocalDateTime的副本。 LocalDateTime withDayOfYear(int dayOfYear) 返回这个 LocalDateTime的副本，并更改日期。 LocalDateTime withHour(int hour) 返回此日期值更改的 LocalDateTime的副本。 LocalDateTime withMinute(int minute) 返回这个 LocalDateTime的副本，小时值更改。 LocalDateTime withMonth(int month) 返回此年份更改的 LocalDateTime的副本。 LocalDateTime withNano(int nanoOfSecond) 返回这个 LocalDateTime的副本，纳秒变化值。 LocalDateTime withSecond(int second) 返回这个 LocalDateTime的副本，其中 LocalDateTime了第二分钟的值。 LocalDateTime withYear(int year) 返回这个 LocalDateTime的副本，年份被更改。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----Java8-4-1-StreamAPI","slug":"JavaEE进阶知识学习----Java8-4-1-StreamAPI","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:52.641Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----Java8-4-1-StreamAPI/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----Java8-4-1-StreamAPI/","excerpt":"","text":"###什么是StreamStream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行测操作，可以执行非常复杂的查找，过滤和映射数据的操作，使用Stream API对集合数据进行操作就类似于使用SQL执行的数据库查询查询，Stream API提供了一种高效且易于使用的处理数据的方式。流（Stream）是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列，“集合讲的是数据，流讲的是计算”，需要注意的是以下三点 Stream自己不会存储元素 Stream不会改变源对象，相会，他们会返回一个持有结果的新的Stream Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。 ###Stream使用方法 创建Stream：一个数据源（集合、数组）获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作：一个终止操作，执行中间操作链，并产生结果。####创建Stream的方法 通过Collection系列提供的stream()或parallelStream()，如下： 通过Arrays中的静态方法stream()方法获取流 通过Stream类中的静态方法of() 创建无限流 示例如下： @Test public void test1(){ // 1.通过Collection系列提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); // 2.通过Arrays中的静态方法stream()方法获取流 Employee[] emps = new Employee[10]; Stream&lt;Employee&gt; stream1 = Arrays.stream(emps); // 3.通过Stream类中的静态方法of() Stream&lt;String&gt; stream2 = Stream.of(&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;); // 4.创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0,(x) -&gt; x+2); //只要前10个（中间操作） stream3.limit(10).forEach(System.out::println); //打印了所有的中间流操作 //stream3.forEach(System.out::println); //4.2生成 Stream.generate(() -&gt; Math.random()) .limit(10) .forEach(System.out::println); } ####中间操作 filter—-接受lambda,从流中排除某一些元素 limit—-截断流，使其元素不超过给定的数量 skip(n)—-跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流 distinct—-筛流，通过流生成元素的hashcode()和equals()去除重复元素 #####filter示例 @Test public void test1(){ //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; { System.out.println(&quot;中间操作&quot;); return e.getAge() &gt; 16; }); //终止操作 stream.forEach(System.out::println); } ######惰性求值和内部迭代 如果没有终止操作，是不会打印中间操作的，这就是流只有需要结果的时候才会被调用，这就是惰性求值。 上述打印是Stream自己给我们迭代输出的，这个就是内部迭代。 #####筛选和切片示例如下 @Test public void test1(){ //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; e.getAge() &gt; 15) .limit(4) .skip(1) .distinct(); //终止操作 stream.forEach(System.out::println); } 说明：由于distinct是根据hashcode()和equals()去重，所以Employee中要重写equals和hashCode方法。 ####映射 map(Function f) 接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 ####map示例如下 @Test public void test2(){ List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println); System.out.println(&quot;================&quot;); employees.stream() .map(Employee::getName) .forEach(System.out::println); } ####flatMap示例 @Test public void test3(){ List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;); Stream&lt;Character&gt; sm = list.stream() .flatMap(TestMiddle::filterCharacter); sm.forEach(System.out::println); } public static Stream&lt;Character&gt; filterCharacter(String str){ List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(Character ch: str.toCharArray()){ list.add(ch); } return list.stream(); } ####排序 #####sorted()-自然排序（comparable） @Test public void test4(){ List&lt;String&gt; list = Arrays.asList(&quot;ccc&quot;,&quot;aaa&quot;,&quot;bbb&quot;,&quot;eee&quot;); list.stream() .sorted() .forEach(System.out::println); } } #####sorted(Comparator com)-定制排序（Comparator） @Test public void test5(){ employees.stream() .sorted((e1,e2) -&gt; { if(e1.getAge().equals(e2.getAge())){ return e1.getName().compareTo(e2.getName()); }else{ return e2.getAge().compareTo(e2.getAge()); } }).forEach(System.out::println); } ####终止操作终止操作会从流的流水线生成结果，该结果可以是任何不是流的值，例如：List、Integer、void。 #####查找和匹配 allMatch(Predicate p) 检查是否匹配所有的元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有的元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素个数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代 示例如下： public class TestStreamAPI { List&lt;Employee&gt; employees = Arrays.asList( new Employee(&quot;张三&quot;,16,9999.99, Employee.Status.FREE), new Employee(&quot;李四&quot;,18,8888.99, Employee.Status.VOCATION), new Employee(&quot;王五&quot;,20,7777.99, Employee.Status.BUSY), new Employee(&quot;赵六&quot;,22,6666.99, Employee.Status.FREE), new Employee(&quot;田七&quot;,24,5555.99, Employee.Status.BUSY), new Employee(&quot;小八&quot;,26,4444.99, Employee.Status.VOCATION), new Employee(&quot;陈九&quot;,28,3333.99, Employee.Status.VOCATION), new Employee(&quot;王五&quot;,32,9999.99, Employee.Status.BUSY), new Employee(&quot;王五&quot;,34,9999.99, Employee.Status.FREE), new Employee(&quot;王五&quot;,36,9999.99, Employee.Status.BUSY) ); @Test public void test1(){ //检查是否所有的状态为BUSY状态 Boolean b1 = employees.stream() .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否至少匹配一个元素 Boolean b2 = employees.stream() .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否没有匹配元素 Boolean b3 = employees.stream() .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //先按照工资排序，再去除第一个元素放在Option容器中 Optional&lt;Employee&gt; op = employees.stream() .sorted((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())) .findFirst(); System.out.println(op.get()); //findAny返回当前流中的任意元素，先过滤再返回一个， //mployees.stream()实现的是串行流，每次返回的值一定的。 //employees.parallelStream()实现的是并行流 ，返回的就是满足条件的随机结果。 Optional&lt;Employee&gt; op2 = employees.parallelStream() .filter((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)) .findAny(); System.out.println(op2.get()); //返回流中元素个数 Long count = employees.stream() .count(); //返回流中最大值 Optional&lt;Employee&gt; op1 = employees.stream() .max((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())); System.out.println(op1.get()); //返回流中最低工资 Optional&lt;Double&gt; op3 = employees.stream() .map(Employee::getSalay) .min(Double::compare); System.out.println(op3.get()); } } #####归约reduce(T iden,BinaryOperator b)可以将流中元素反复结合起来，得到一个值，返回T,示例如下： @Test public void test2(){ List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0,(x,y) -&gt; x+y); System.out.println(sum); //计算工资的总和 Optional&lt;Double&gt; op = employees.stream() .map(Employee::getSalay) .reduce(Double::sum); System.out.println(op.get()); } 上述代码中使用map得到所有的工资，再有reduce将所有的工资累加，map和reduce配合使用情况比较多。 #####收集collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。Colletor接口中的方法实现决定了如何对流执行收集操作（如收集到List，Set,Map）,但是Collectors实用类提供了很多静态的方法，可以方便的创建常用收集器实例，具体方法与实例如下： toList 返回List 将流中元素搜集到List toSet 返回Set 将流中元素手机到Set toCollection 返回Collection 把流中元素收集到创建的集合中 counting 返回Long 计算流中元素的个数 summinglnt 返回Integer 对流中元素的整数属性求和 averaginglnt 返回Double 计算流中元素Integer属性的平均值 summarizinglnt 返回IntSummaryStatistics 计算流中Integer属性的统计值，如平均值。 joining 返回String 连接流中每一个字符串 maxBy 返回Optional 根据比较器选择最大值 minBy 返回Optional 根据比较器选择最小值 reducing 归约产生的类型 collectionAndThen 转换函数返回的类型 实例如下： @Test public void test3(){ //将名字添加到list中 List&lt;String&gt; list = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); //将名字添加到Set中 Set&lt;String&gt; set = employees.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); //将名字添加到特定的数据结构中 HashSet&lt;String&gt; hashSet = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); //总数 Long count = employees.stream() .collect(Collectors.counting()); //平均数 Double avg = employees.stream() .collect(Collectors.averagingDouble(Employee::getSalay)); //总和 Double sum = employees.stream() .collect(Collectors.summingDouble(Employee::getSalay)); //最大值，返回工资最大的员工信息 Optional&lt;Employee&gt; max = employees.stream() .collect(Collectors.maxBy((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay()))); //最小值，返回最小工资 Optional&lt;Double&gt; min = employees.stream() .map(Employee::getSalay) .collect(Collectors.minBy(Double::compare)); //按照状态分组 Map&lt;Employee.Status,List&lt;Employee&gt;&gt; map = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus)); map.get(Employee.Status.BUSY); //多级分组 Map&lt;Employee.Status,Map&lt;String,List&lt;Employee&gt;&gt;&gt; map1 = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus,Collectors.groupingBy((e) -&gt;{ if(((Employee)e).getAge() &lt;= 18){ return &quot;少年&quot;; }else if(((Employee)e).getAge() &lt;= 26){ return &quot;中年&quot;; }else{ return &quot;老年&quot;; } }))); System.out.println(map1); //分区。满足条件一个区，不满足条件的一个区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map2 = employees.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalay() &gt;5000)); System.out.println(map2); //其他的一种获取方式 DoubleSummaryStatistics dss = employees.stream() .collect(Collectors.summarizingDouble(Employee::getSalay)); System.out.println(dss.getSum()); System.out.println(dss.getAverage()); System.out.println(dss.getMax()); //连接字符串 String str = employees.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;,&quot;,&quot;====&quot;,&quot;===&quot;)); }","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习----JavaNIO-2-分散读取和聚集写入-阻塞网络通信","slug":"JavaEE进阶知识学习----JavaNIO-2-分散读取和聚集写入-阻塞网络通信","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:20.377Z","comments":true,"path":"2019/03/22/JavaEE进阶知识学习----JavaNIO-2-分散读取和聚集写入-阻塞网络通信/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE进阶知识学习----JavaNIO-2-分散读取和聚集写入-阻塞网络通信/","excerpt":"","text":"###分散读取和聚集写入分散读取：将通道中的数据分散到多个缓冲区中。聚集写入：将多个缓冲区中的数据聚集到通道中。分散读取实例 @Test public void test4() throws IOException{ RandomAccessFile rFile = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;); //获取通道 FileChannel channel = rFile.getChannel(); //分配指定大小的缓冲区 ByteBuffer buffer1 = ByteBuffer.allocate(100); ByteBuffer buffer2 = ByteBuffer.allocate(1024); //分散读取 ByteBuffer[] bufs = {buffer1,buffer2}; channel.read(bufs); for (ByteBuffer byteBuffer : bufs) { byteBuffer.flip(); } System.out.println(new String(bufs[0].array(),0,bufs[0].limit())); System.out.println(&quot;==================================&quot;); System.out.println(new String(bufs[1].array(),0,bufs[1].limit())); 聚集写入实例 @Test public void test4() throws IOException{ RandomAccessFile rFile = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;); //获取通道 FileChannel channel = rFile.getChannel(); //分配指定大小的缓冲区 ByteBuffer buffer1 = ByteBuffer.allocate(100); ByteBuffer buffer2 = ByteBuffer.allocate(1024); //分散读取 ByteBuffer[] bufs = {buffer1,buffer2}; channel.read(bufs); for (ByteBuffer byteBuffer : bufs) { byteBuffer.flip(); } System.out.println(new String(bufs[0].array(),0,bufs[0].limit())); System.out.println(&quot;==================================&quot;); System.out.println(new String(bufs[1].array(),0,bufs[1].limit())); //聚集写入 RandomAccessFile rfile2 = new RandomAccessFile(&quot;2.txt&quot;, &quot;rw&quot;); FileChannel channel2 = rfile2.getChannel(); channel2.write(bufs); } ###NIO的字符集查看支持的字符集 @Test public void test5(){ //支持的字符集 Map&lt;String, Charset&gt; map = Charset.availableCharsets(); //遍历map Set&lt;Entry&lt;String, Charset&gt;&gt; set = map.entrySet(); for (Entry&lt;String, Charset&gt; entry : set) { System.out.println(entry.getKey()+&quot;===&quot;+entry.getValue()); } } 通过一个字符集得到的编码器和解码器就不会出现乱码，如下 @Test public void test6() throws IOException{ Charset cs1 = Charset.forName(&quot;GBK&quot;); //获取编码器 CharsetEncoder ce = cs1.newEncoder(); //获取解码器 CharsetDecoder cd = cs1.newDecoder(); //创建buffer，并存入文字 CharBuffer cBuff = CharBuffer.allocate(1024); cBuff.put(&quot;疾风知劲草&quot;); cBuff.flip(); //编码，字符-字节 ByteBuffer bBuf = ce.encode(cBuff); //查看是否编码成功 for(int i = 0; i &lt; 10; i++){ System.out.println(bBuf.get()); } //解码，字节-字符 bBuf.flip(); CharBuffer cBuf2 = cd.decode(bBuf); System.out.println(cBuf2.toString());// 疾风知劲草 } 如果使用GBK进行编码，使用UTF-8进行解码，就会出现乱码，如下所示。 @Test public void test6() throws IOException{ Charset cs1 = Charset.forName(&quot;GBK&quot;); //获取编码器 CharsetEncoder ce = cs1.newEncoder(); //获取解码器 CharsetDecoder cd = cs1.newDecoder(); //创建buffer，并存入文字 CharBuffer cBuff = CharBuffer.allocate(1024); cBuff.put(&quot;疾风知劲草&quot;); cBuff.flip(); //编码，字符-字节 ByteBuffer bBuf = ce.encode(cBuff); //查看是否编码成功 for(int i = 0; i &lt; 10; i++){ System.out.println(bBuf.get()); } //解码，字节-字符 bBuf.flip(); CharBuffer cBuf2 = cd.decode(bBuf); System.out.println(cBuf2.toString());// 疾风知劲草 System.out.println(&quot;=========================&quot;); //如果按照UTF-8解码，就会出现乱码 Charset cs2 = Charset.forName(&quot;UTF-8&quot;); bBuf.flip(); CharBuffer cBuf3 = cs2.decode(bBuf); System.out.println(cBuf3.toString()); } #####以上都是使用通道解决本地的数据传输，NIO的核心是网络数据传输。 ###NIO的非阻塞网络通信选择器（Selector）：将每一个通道注册到选择器上，选择器就是监控每一个通道的IO状况（读，写，连接等情况）。只有当通道中的请求时间准备就绪时，才会将任务分配到服务端的一个线程或者多个线程上运行。NIO非阻塞模式图解如下：使用NIO非阻塞式进行网络通信，我们先来看一个阻塞式的网络通信。使用NIO完成网络通信的三个核心： 通道（channel）：负责连接，实现类有SocketChannel、ServerSocketChanel、DatagramChannel。 缓冲区：负责数据的读取。 选择器：是是SelectableChannel的多路复用器，用于监控selectablechannel的IO状况。 网络通信如下： public class TestBlockingNIO { //客户端 @Test public void client(){ SocketChannel sChannel = null; FileChannel inChannel = null; try { sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;,9898)); inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ); //分配指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); //读取本地文件，并发送到服务端 while(inChannel.read(buf) != -1){ buf.flip(); sChannel.write(buf); buf.clear(); } } catch (IOException e) { e.printStackTrace(); }finally{ if(inChannel != null){ try { inChannel.close(); } catch (IOException e) { e.printStackTrace(); } } if(sChannel != null){ try { sChannel.close(); } catch (IOException e) { e.printStackTrace(); } } } } //服务端(异常处理应该使用try-catch) @Test public void server() throws IOException{ //获取通道 ServerSocketChannel ssChannel = ServerSocketChannel.open(); FileChannel outChannel = FileChannel.open(Paths.get(&quot;44.jpg&quot;), StandardOpenOption.WRITE,StandardOpenOption.CREATE); //绑定连接 ssChannel.bind(new InetSocketAddress(9898)); //获取客户端连接的通道 SocketChannel sChannel = ssChannel.accept(); //分配指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); //接收客户端的数据，并保存在本地 while(sChannel.read(buf) != -1){ buf.flip(); outChannel.write(buf); buf.clear(); } //关闭通道 sChannel.close(); outChannel.close(); ssChannel.close(); } } 说明：先启动服务端，在启动客户端，就会发现项目中多了一个文件。这就是使用socket进行网络通信的一个实例，如果我们想客户端运行成功后，服务端返回一个信息，表明已经成功了。看如下程序 //客户端 @Test public void client() throws IOException{ SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;,9898)); FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ); ByteBuffer buf = ByteBuffer.allocate(1024); while (inChannel.read(buf) != -1) { buf.flip(); sChannel.write(buf); buf.clear(); } //接收服务端返回的信息 int len = 0; while(sChannel.read(buf)!= -1){ buf.flip(); System.out.println(new String(buf.array(),0,len)); buf.clear(); } inChannel.close(); sChannel.close(); } //服务端(异常处理应该使用try-catch) @Test public void server() throws IOException{ ServerSocketChannel ssChannel = ServerSocketChannel.open(); FileChannel outChannel = FileChannel.open(Paths.get(&quot;66.jpg&quot;), StandardOpenOption.WRITE,StandardOpenOption.CREATE); ssChannel.bind(new InetSocketAddress(9898)); SocketChannel sChannel = ssChannel.accept(); ByteBuffer buf = ByteBuffer.allocate(1024); while (sChannel.read(buf)!= -1) { buf.flip(); outChannel.write(buf); buf.clear(); } //发送反馈请求给客户端 buf.put(&quot;服务端接收数据成功&quot;.getBytes()); buf.flip(); sChannel.write(buf); sChannel.close(); outChannel.close(); ssChannel.close(); } 说明：以上程序运行后就会导致阻塞，服务端不知道客户端是否发送结束，解决办法有两种，一种是使用shutdownOutPut，另外一种就是换成非阻塞模式。使用sChannel.shutdownOutput();方法。 //客户端 @Test public void client() throws IOException{ SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;,9898)); FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ); ByteBuffer buf = ByteBuffer.allocate(1024); while (inChannel.read(buf) != -1) { buf.flip(); sChannel.write(buf); buf.clear(); } sChannel.shutdownOutput(); //接收服务端返回的信息 int len = 0; while((len = sChannel.read(buf))!= -1){ buf.flip(); System.out.println(new String(buf.array(),0,len)); buf.clear(); } inChannel.close(); sChannel.close(); } //服务端(异常处理应该使用try-catch) @Test public void server() throws IOException{ ServerSocketChannel ssChannel = ServerSocketChannel.open(); FileChannel outChannel = FileChannel.open(Paths.get(&quot;66.jpg&quot;), StandardOpenOption.WRITE,StandardOpenOption.CREATE); ssChannel.bind(new InetSocketAddress(9898)); SocketChannel sChannel = ssChannel.accept(); ByteBuffer buf = ByteBuffer.allocate(1024); while (sChannel.read(buf)!= -1) { buf.flip(); outChannel.write(buf); buf.clear(); } //发送反馈请求给客户端 buf.put(&quot;服务端接收数据成功&quot;.getBytes()); buf.flip(); sChannel.write(buf); sChannel.close(); outChannel.close(); ssChannel.close(); } ###未完，待续","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Typora常用快捷键","slug":"JavaEE基础知识学习-----Typora常用快捷键","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:56.058Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习-----Typora常用快捷键/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习-----Typora常用快捷键/","excerpt":"Typora是什么Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。","text":"Typora是什么Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。 常用快捷键 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 代码块：ctrl+alt+f 加粗：ctrl+b 倾斜：ctrl+i 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 下划线：ctrl+u 删除线：alt+shift+5 无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 表格：ctrl+t 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl+k","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----Object类","slug":"JavaEE基础知识学习----Object类","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:40.437Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----Object类/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----Object类/","excerpt":"Object类java.lang.Object类，是所有类的根父类，Object类中只有一个空参的构造器equals(Object obj)方法这是Object类中很常用的方法，在学习equals(Object obj)方法之前，先学习“==”相关知识。 “==”的相关知识1.“==”两端比较的是基本数据类型，判断基本数据类型的值是否相等，相等就返回true，否则返回false，重点是值，数据类型可能不同，例如：","text":"Object类java.lang.Object类，是所有类的根父类，Object类中只有一个空参的构造器equals(Object obj)方法这是Object类中很常用的方法，在学习equals(Object obj)方法之前，先学习“==”相关知识。 “==”的相关知识1.“==”两端比较的是基本数据类型，判断基本数据类型的值是否相等，相等就返回true，否则返回false，重点是值，数据类型可能不同，例如：123456789101112public static void main(String[] args) &#123; int i = 110; int j = 110; char c = 110; float f = 110.0F; int k = 65; char a = 'A'; System.out.println(i==j);//true System.out.println(i==c);//true System.out.println(i==f);//true System.out.println(k==a);//true&#125; 2.“==”两端比较的是引用类型，判断的是引用类型变量的地址值是否相等，例如： 12345Object obj1 = new Object();Object obj2 = new Object();Object obj3 = obj1;System.out.println(obj1 == obj2);//falseSystem.out.println(obj3 == obj1);//true equals(Object obj)的相关知识源码如下所示： 123public boolean equals(Object obj) &#123;return (this == obj);&#125; equals(Object obj)处理引用类型变量，在源码中发现还是比较的还是地址值。 123Object obj1 = new Object();Object obj2 = new Object();System.out.println(obj1.equals(obj2));//false 但是，在下面的例子中，仿佛又不是这个样子的，请看 123String str1 = new String(\"AA\");String str2 = new String(\"AA\");System.out.println(str1.equals(str2));//true String类也是继承了Object类，按理说比较的是地址值也，应该为false，怎么会为true呢？因为String类重写了equals()方法，源码如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 其实不仅String类重写了equals()方法，还有包装类，File类，Date类都重写了Object类的equals()方法，比较两个对象的“实体内容”是否相同，如果我们自己定义的类，希望两个对象的属性值都相同的情况下返回true，就需要重写equals()方法。当然，我们可以仿照String类重写equals()方法来重写自己的定义类中的equals()方法，还是有难度，可以使用eclipse自动生成的equlas()方法，例如Person类，如下所示： 1234567891011121314151617181920212223242526272829private String name;//姓名private String sex;//性别private int age;//年龄@Overridepublic boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; if (sex == null) &#123; if (other.sex != null) return false; &#125; else if (!sex.equals(other.sex)) return false; return true;&#125; 当然这里也存在一些常识性的操作，例如对于非空对象引用x,y,z1234x.equals(x);返回truex.equals(y);返回true,那么y.equals(x);也应该返回truex.equals(y);返回true,y.equals(z);返回true,那么x.equals(z);也应该返回truex.equals(null);返回false equals()方法和“==”使用场景12345671.对象域，使用equals方法 。2.类型安全的枚举，使用equals或== 。3.可能为null的对象域 : 使用 == 和 equals 。4.数组域 : 使用 Arrays.equals 。5.除float和double外的原始数据类型 : 使用 == 。6.float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。7.double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。 toString()方法toString()也是Object类中使用频率很高的方法，使用情况如下所示： 123Person person = new Person();System.out.println(person.toString());System.out.println(person); 结果如下： 12com.java.study.Person@c791b9com.java.study.Person@c791b9 Object类中toString()方法的源码如下： 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; 如果子类没有重写toString()方法，当我们打印一个对象的引用时，实际调用的就是Object类中的toString()方法。输出此对象所在类及对应的堆空间对象的首地址。如果子类重写了toString()方法，那么打印一个对象引用时,实际上调用的就是当前对象的toString()方法例如Person类重写了toString()方法 1234@Overridepublic String toString() &#123; return \"Person [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\";&#125; 看下面两个例子： 1234String str1 = \"AA\";String str2 = new String(\"BB\");System.out.println(str1.toString());System.out.println(str2.toString()); 结果为： 12AABB 输出结果不是我们前面所说的地址值，这是因为String类重写了toString()方法，源码如下： 123public String toString() &#123; return this;&#125; 其实像String类，File类，Date类，包装类都重写了toString()方法。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Webstrom常用快捷键","slug":"JavaEE基础知识学习-----Webstrom常用快捷键","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:40:01.393Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习-----Webstrom常用快捷键/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习-----Webstrom常用快捷键/","excerpt":"WebStorm是什么WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。目前已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。","text":"WebStorm是什么WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。目前已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 WebStorm常用快捷键 ctrl + / : 单行注释 ctrl + shift + / : 块注释 ctrl+alt+L 格式化代码 ctrl + d: 行复制 ctrl + shift + up: 行移动 ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。 ctrl + j: 输出模板 ctrl + b: 跳到变量申明处 ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation) ctrl + []: 匹配 {}[] ctrl + F12: 可以显示当前文件的结构 ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容 alt + left/right:标签切换 ctrl + r: 替换 shift + alt + up: 块移动(if(){},while(){}语句块的移动) ctrl + shift + ]/[: 选中块代码 ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息 ctrl + ‘-/+’: 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。 ctrl + ‘.’: 折叠选中的代码的代码。 ctrl+shift+ +/-展开/折叠 ctrl+shift+ up/down 上下移动句子 Alt+回车 导入包,自动修正 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) Ctrl+E或者Alt+Shift+C 最近更改的代码 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+Shift+Space 自动补全代码 Ctrl+空格 代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Shift+F6 重构-重命名 Ctrl+Shift+先上键 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+J 自动代码 Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+ left/right 返回至上次浏览的位置 Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down 代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"Java","slug":"JavaEE基础知识学习----内部类","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:38:02.694Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----内部类/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----内部类/","excerpt":"","text":"内部类类的五个成分：属性，方法，构造器，代码块，内部类。什么是内部类？在java中，允许一个类定义在另一个类的内部，前者就叫内部类，后者就叫外部类。内部类一般用在定义它的类或语句块之内，在外部引用内部类必须给出完整的类名，当然外部类和内部类的类名不能相同。内部类可以使用外部类的私有数据，因为它本身就是外部类的成员，同一个类的成员之间是可以互相访问的。而外部类要访问内部类中的成员就需要使用对象或者如果访问内部类中静态结构就使用完整类名。一般很少在类中在定义类，但是也是存在的，例如线程中的Thread类，其中就有一个内部类。如下： 1public enum State &#123; 这个是一个枚举类，也是类的一种，枚举有关的知识后续学习中。 内部类分类成员内部类：声明在类内部且方法外的，根据是否有static修饰的又分为static成员内部类和非static成员内部类局部内部类：声明在类的方法里，不谈修饰符， 成员内部类1.它是外部类的一个成员，所以它有四个修饰符，普通的类只有两个public和默认的。2.普通的类不可以用static修饰，但是内部类可以，因为他是类的成员。3.因为内部类是一个类，所以他也具备类的特点，例如用abstract修饰，可以在其内定义属性，方法，构造器下面演示的就是一个成员内部类和局部内部类； 1234567891011121314151617181920212223242526272829public class TestInnerClass &#123;&#125;class SuperPerson&#123; String name; int age; private class Bird&#123; String name; String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public Bird(String name, String age) &#123; super(); this.name = name; this.age = age; &#125; &#125;&#125; 内部类有什么用？老实说，我也没有用过内部类，我还是菜鸟一个，在网上看到一个例子，说的很好，我们都知道在java中只能支持单继承多接口。看如下代码： 123456789101112131415161718public interface Father &#123; &#125; public interface Mother &#123; &#125; public class Son implements Father, Mother &#123; &#125; public class Daughter implements Father&#123; class Mother_ implements Mother&#123; &#125; &#125; 如果Father和Mother不是接口，而是抽象类或者具体类，我们就可以使用内部类实现多重继承。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----Final关键字","slug":"JavaEE基础知识学习----Final关键字","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:39:35.901Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----Final关键字/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----Final关键字/","excerpt":"Final关键字final:最终的，可以用来修饰类，修饰属性，修饰方法，修饰参数，被final修饰的表示不可以被修改，不能被修改的原因是为了效率和安全性。 final修饰类final修饰的类不能被继承，提高了安全性，例如String类，System类，StringBuffer类，源码如下所示：","text":"Final关键字final:最终的，可以用来修饰类，修饰属性，修饰方法，修饰参数，被final修饰的表示不可以被修改，不能被修改的原因是为了效率和安全性。 final修饰类final修饰的类不能被继承，提高了安全性，例如String类，System类，StringBuffer类，源码如下所示：1234567public final class Stringimplements java.io.Serializable, Comparable&lt;String&gt;, CharSequencepublic final class System &#123;public final class StringBuffer extends AbstractStringBuilderimplements java.io.Serializable, CharSequence final修饰的类表示这个是最终类，不允许被继承，它的成员可以是final，也可以是非final。 final修饰方法final修饰的方法不能被子类重写，例如Object类中的getClass()方法；源码如下 1public final native Class&lt;?&gt; getClass(); final修饰变量final修饰的变量称之为常量，恒定不变的数据能减轻系统运行的负担，final修饰的成员变量必须再声明的时候就进行赋值，或者在构造方法，代码块中为其赋值，不然就会报错，然后才能使用。例如 1final double PI = 3.14; 在阿里巴巴出版的Java开发手册中说道：常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长，例如MAX_STOCK_COUNT看如下代码，final修饰变量： 123456789101112131415161718192021222324252627282930313233343536373839class Person&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Person(String name) &#123; super(); this.name = name; &#125;&#125;public class TestFinal &#123; private final String CHINA_SUPER_MAN_01 = \"孙悟空\";//编译器常量，必须初始化赋值，且不能被更改 private final String CHINA_SUPER_MAN_02;//构造器常量，在实例化一个对象是初始化这个常量 private final Person CHINA_SUPER_MAN_03 = new Person(\"奥特曼\");//final指向应用类型 public TestFinal(String cHINA_SUPER_MAN_02) &#123; this.CHINA_SUPER_MAN_02 = cHINA_SUPER_MAN_02; &#125; @Override public String toString() &#123; return \"final修饰变量时初始化=\" + CHINA_SUPER_MAN_01 + \", final修饰变量使用构造器初始化=\" + CHINA_SUPER_MAN_02 + \", final指向引用类型初始化=\" + CHINA_SUPER_MAN_03.getName() ; &#125; public static void main(String[] args) &#123; TestFinal final1 = new TestFinal(\"唐僧\"); System.out.println(final1); TestFinal final2 = new TestFinal(\"嫦娥\"); System.out.println(final2); final2.CHINA_SUPER_MAN_03.setName(\"貂蝉\"); System.out.println(final2); &#125; 结果为： final修饰变量时初始化=孙悟空, final修饰变量使用构造器初始化=唐僧, final指向引用类型初始化=奥特曼 final修饰变量时初始化=孙悟空, final修饰变量使用构造器初始化=嫦娥, final指向引用类型初始化=奥特曼 final修饰变量时初始化=孙悟空, final修饰变量使用构造器初始化=嫦娥, final指向引用类型初始化=貂蝉从上面的代码和结果可以看出：1.final修饰的变量，如果在定义变量的时候直接初始化赋值，那么他是不可变的，2.final修饰的变量，采用构造器初始化，也就是说每一个对象中某一个属性都有其特定的属性值。3.final指向引用类型，实例化每一个对象时，不修改其属性值就会使用默认初始化的，可以修改对象的属性值，且不影响其他实例化对象的调用 final修饰参数final修饰的参数表示不可变，如果你做了什么能改变该参数的值，就会报错，例如 12345678 public void test(final int i)&#123; //i++;final修饰的参数不能被改变 System.out.println(i); &#125;public void test1(final Man man)&#123; //man = new Man();//不能被改变 man.setName(\"貂蝉\"); &#125; 在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类使用时，该形参就是final的。匿名内部类将在接下来的学习中。 final和static这两个关键字都可以修饰变量，也可以修饰成员方法，一起修饰成员变量，也叫全局全局常量，使用类名直接访问。一起修饰成员方法，则不可被继承也不能被改变，可以通过类名直接访问。 final面试题###是否可以继承String类答：不能，因为String类是final类不能被继承。 final关键字有哪些用法答：1.修饰类，表示类不能被继承。2.修饰方法，表示方法不能被重写。3.修饰变量，表示变量只能被赋值一次且不能被修改。4.修饰参数，表示参数不可变。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----单例模式","slug":"JavaEE基础知识学习----单例模式","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:40:11.654Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----单例模式/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----单例模式/","excerpt":"为什么存在单例模式有些对象我们只需要一个，比如线程池，缓存，对话框，处理偏好设置和注册表的对象，或者日志对象 ，实质上，这些对象只能有一个实例，如果存在多个实例，就会导致许多问题，例如，程序的行为异常，资源使用过度等，因为这样，所以就出现了单例模式。 单例模式实现","text":"为什么存在单例模式有些对象我们只需要一个，比如线程池，缓存，对话框，处理偏好设置和注册表的对象，或者日志对象 ，实质上，这些对象只能有一个实例，如果存在多个实例，就会导致许多问题，例如，程序的行为异常，资源使用过度等，因为这样，所以就出现了单例模式。 单例模式实现 12345678910111213public class Singleton &#123; private static Singleton uniqueInstance;//利用一个静态变量来记录Singleton类的唯一实例 private Singleton ()&#123;&#125;// 将构造器声明为私有的，只有singleton内部可以调用构造器 // 使用getInstance来创建实例，其中uniqueInstance是一个静态变量，为空表示没有创建实例，不为空则直接返回该实例 public static Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 在《Head First》书中有这样一个场景，就是两个线程都要执行单例模式中的代码，就会创建两个实例对象，如下图 处理多线程使用synchronized关键字，将getInstance方法改为同步方法。12345678910111213public class Singleton &#123; private static Singleton uniqueInstance;//利用一个静态变量来记录Singleton类的唯一实例 private Singleton ()&#123;&#125;// 将构造器声明为私有的，只有singleton内部可以调用构造器 // 使用getInstance来创建实例，其中uniqueInstance是一个静态变量，为空表示没有创建实例，不为空则直接返回该实例 public static synchronized Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 直接初始化静态变量，这样也可以保证线程安全123456public class Singleton &#123; //利用静态变量来记录Singleton的唯一实例 //直接初始化静态变量，这样就可以确保线程的安全 private static Singleton uniqueInstance = new Singleton(); private Singleton ()&#123;&#125;// 将构造器声明为私有的，只有singleton内部可以调用构造器 12345 public static Singleton getInstance()&#123; return uniqueInstance; &#125;&#125; 使用“双重检查加锁”的方式，在getInstance()中减少使用同步1234567891011121314151617181920212223242526public class Singleton &#123; /** * 利用静态变量来记录Singleton的唯一实例 * volatile关键词确保：当uniqueInstance变量被初始化成Singleton实例时， * 多个线程正确的处理uniqueInstance变量 */ private volatile static Singleton uniqueInstance; /** * 构造器私有化，只有Singleton内部才可以调用构造器 */ private Singleton()&#123;&#125; /** * 检查实例，不存在就进入同步区域，这样一来，就只会在第一次同步 * */ public static Singleton getInstance()&#123; if(uniqueInstance == null)&#123; synchronized (Singleton.class) &#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 单例模式的优缺点 节约了系统资源，由于系统中只存在一个实例对象，对于一些需要频繁创建和销毁对象的系统而言，单例模式就节约了系统资源和提高了系统的性能。 因为单例封装了它的唯一实例，所以它可以严格控制客户 怎样以及何时访问它。 由于单例模式没有抽象层，因此单例类的扩展就有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。 单例模式使用场景 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 小结 单例模式确认程序一个类只有一个实例。 单例模式中的构造器是私有的，而且它必须要提供实例的全局访问点。 单例模式可能会因为多线程的问题存在安全隐患。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习----命令模式","slug":"JavaEE基础知识学习----命令模式","date":"2019-03-22T11:42:54.000Z","updated":"2019-03-22T12:37:55.443Z","comments":true,"path":"2019/03/22/JavaEE基础知识学习----命令模式/","link":"","permalink":"https://caochenhins.github.io/2019/03/22/JavaEE基础知识学习----命令模式/","excerpt":"","text":"命令模式定义命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，命令模式支持可撤销的操作。命令模式可以对发送者和接受者完全解耦，发送者和接收者之间没有直接的联系，发送者只需要知道如何发送请求，不需要关心请求如何完成，这就是命令模式，命令模式将方法的调用给封装起来了。 命令模式结构说明：上图中的Command:抽象命令类，ConcreteCommand：具体命令类，Invoker:调用者，Receiver:接受者，Client:客户类。命令的模式本质就在于将命令进行封装，将发出的命令测责任和执行命令的责任分开，发送者只需要知道如何发送指令即可，不需要知道命令如何实现的，甚至执行是否成功都不需要知道，命令模式将请求也变为一个对象，它和其他对象一样可以被存储和传递。 命令模式的实现在这里，我们以电视机为例，电视剧是请求的接受者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应不同的操作，在这里遥控器需要执行三个命令，打开电视，关闭电视，换台。 类图结构如下 抽象命令接口12345678/** * 命令接口，为所有的命令声明一个接口 *@author lky *@date 2018年1月19日 */public interface Command &#123; public void excute();&#125; 电视机类123456789101112131415161718/** * 电视机类 *@author lky *@date 2018年1月19日 */public class Telvision &#123; public void open()&#123; System.out.println(\"打开电视机....\"); &#125; public void close()&#123; System.out.println(\"关闭电视机....\"); &#125; public void changeChannel()&#123; System.out.println(\"切换电视机频道....\"); &#125;&#125; 遥控器类1234567891011121314151617181920212223242526272829/** * 遥控器类 *@author lky *@date 2018年1月19日 */public class Controller &#123; private Command openTvCommand; private Command closeTvCommand; private Command changeTvCommand; public Controller(Command openTvCommand, Command closeTvCommand, Command changeTvCommand) &#123; super(); this.openTvCommand = openTvCommand; this.closeTvCommand = closeTvCommand; this.changeTvCommand = changeTvCommand; &#125; public void open()&#123; openTvCommand.excute(); &#125; public void close()&#123; closeTvCommand.excute(); &#125; public void change()&#123; changeTvCommand.excute(); &#125;&#125; 遥控器的打开按钮类123456789101112131415161718/** * 遥控器的打开电视按钮 *@author lky *@date 2018年1月19日 */public class OpenTvCommand implements Command&#123; private Telvision tv; public OpenTvCommand() &#123; tv = new Telvision(); &#125; @Override public void excute() &#123; tv.open(); &#125;&#125; 遥控器的换台按钮1234567891011121314151617/** * 遥控机换台按钮 *@author lky *@date 2018年1月19日 */public class ChangeTvCommand implements Command&#123; private Telvision tv; public ChangeTvCommand() &#123; tv = new Telvision(); &#125; @Override public void excute() &#123; tv.changeChannel(); &#125;&#125; 遥控器的关闭按钮123456789101112public class CloseTvCommand implements Command&#123; private Telvision tv; public CloseTvCommand() &#123; tv = new Telvision(); &#125; @Override public void excute() &#123; tv.close(); &#125;&#125; 客户端123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Command openCommand,closeCommand,changeCommand; openCommand = new OpenTvCommand(); closeCommand = new CloseTvCommand(); changeCommand = new ChangeTvCommand(); Controller controller = new Controller(openCommand, closeCommand, changeCommand); controller.open(); controller.change(); controller.close(); &#125;&#125; 输出结果123打开电视机....切换电视机频道....关闭电视机.... 为方便理解，将代码放在一起 命令模式的优缺点 降低了系统的耦合度 新的命令可以很容易的添加进去 使用命令模式可能会导致某些系统有过多的具体命令类 命令模式的使用场景 系统需要请求调用者和请求接受者解耦，使得调用者和接收者不会直接交互 系统需要在不同的时间指定请求，将请求排队和执行请求 系统需要支持命令的插销和恢复操作 系统需要将一组操作组合在一起 总结 命令模式的本质是将命令对象进行封装打包，将发出的命令的责任和执行命令的责任进行分割开。 命令模式中发送者只需要知道如何发送命令，无需关心命令执行的具体过程。 在发送者和接受者两者之间是通过命令对象进行沟通的，请求命令本身就当做一个对象在两者之间进行传递，他封装了接受者和一组动作。 命令模式支持撤销操作。 命令模式队列请求和日志请求。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2019-03-21T15:40:50.000Z","updated":"2019-03-21T15:28:01.289Z","comments":true,"path":"2019/03/21/SpringBoot/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/SpringBoot/","excerpt":"一、SpringBoot入门1.1.什么是SpringBoot采用官方的话说，SpringBoot是简化Spring应用开发的一个框架，将整个Spring技术全家桶进行整合，被称为JavaEE开发的一站式解决方案； 1.2.SpringBoot和SpringCloud的关系 SpringBoot是专注于快速方便的开发单个体微服务； SpringCloud是关注全局的微服务协调治理框架，他将多个SpringBoot开发的单个微服务进行整合管理，为微服务之间提供配置管理，服务发现等一系列服务； SpringBoot可以离开SpringCloud单独开发项目，但是SpringCloud离不来SpringBoot；","text":"一、SpringBoot入门1.1.什么是SpringBoot采用官方的话说，SpringBoot是简化Spring应用开发的一个框架，将整个Spring技术全家桶进行整合，被称为JavaEE开发的一站式解决方案； 1.2.SpringBoot和SpringCloud的关系 SpringBoot是专注于快速方便的开发单个体微服务； SpringCloud是关注全局的微服务协调治理框架，他将多个SpringBoot开发的单个微服务进行整合管理，为微服务之间提供配置管理，服务发现等一系列服务； SpringBoot可以离开SpringCloud单独开发项目，但是SpringCloud离不来SpringBoot； 1.3.SpringBoot的入门demo 使用IDEA开发工具，新建一个Spring Boot项目，只选中web模块，服务端响应请求，如下： 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello()&#123; return \"hello this is my first demo\"; &#125;&#125; 二、SpringBoot配置文件2.1.基本使用在项目的resource目录下，有一个SpringBoot的全局配置文件application.properties，当我们需要修改配置文件的时候就可以修改，如下，修改项目的端口号： 1server.port=8081 当然，properties配置文件也会存在很多重复的配置代码，这个时候就出现了一种新的配置文件application.yaml 12server: port: 8082 2.2.yaml语法说明在前面的使用中，大家也可以看到yaml语法是采用一对键值对（中间存在空格）,同时使用空格来控制层级关系，只要是左对齐的一列数据，就说明是一个层级的；需要注意的是；属性和值对大小写是敏感的； 1234567891011121314151617181920server: port: 8082# 在yaml语法中，值为数字，字符串或者布尔就直接写，字符串默认不用添加单引号或者双引号name: 你好# 字符串添加了双引号，代表特殊字符不会转义，会直接输出特殊字符所代表的含义，这里会换行lastName: \"你好 \\n 世界\"# 字符串添加了单引号，特殊字符会被转义，这个的换行就会被转义为一个普通的字符串firstname: '你好 \\ 世界'# 当值为对象，Map时，也是采用属性和值的写法，使用空格缩进来区分，如下所示person: name: luokangyuan age: 23# 另外一个写法user: &#123;name: luokangyuan, age: 34&#125;# 当值为数组，list或者set时候，使用-加空格的方式，如下：age: - man - woman# 数组的另外一种写法sport: [football,pingpang] 2.3.配置文件注入所谓的配置文件注入就是在java类中获取配置文件中配置的属性值，在SpringBoot中可以使用@Value注解和@ConfigurationProperties注解完成，两者的区别是：@value需要一个一个的绑定需要获取的属性值，不支持松散语法，不支持JSR303校验，也不支持复杂类型封装，仅支持SpEL，相对而言，@ConfigurationProperties就支持批量注入配置文件属性，支持JSR303数据校验，也支持复杂类型封装,当你只需要从配置文件中获取一个属性值的时候就可以使用@Value注解，当你需要将配置文件封装成一个JavaBean的时候，就可以使用@ConfigurationProperties注解，使用方法如下： 配置文件yaml中配置需要注入的属性值： 1234567891011121314# 配置文件注入systemuser: userName: luokangyuan age: 24 boss: false birthday: 1995/03/16 habbit: - football - basketball - pingpangball friend: &#123;cd: hanger,sc: biner&#125; dog: name: mengmeng age: 3 映射的实体类如下（省略了getter和setter）： 12345678910111213141516171819@Component@ConfigurationProperties(prefix = \"systemuser\")@Validatedpublic class SystemUser &#123; private String userName; private Integer age; private Boolean boss; private Date birthday; private List&lt;String&gt; habbit; private Map&lt;String,String&gt; friend; private Dog dog;&#125; 在SpringBoot的测试类中，使用@Autowired注解注入SystemUser类，然后在执行方法中打印，就可以看见我们已经从配置文件中获取到了属性值； 注意：如果，配置文件中的别名和实体类名第一个字母小写一样，就会报错，例如：systemUser 2.4.配置文件占位符在配置文件中我们可以使用占位符来给一些属性住设置默认值或者随机数等，例如${random.int(10)}，${random.uuid}或者使用冒号指定默认值 123cat: name: zhangsan$&#123;random.uuid&#125; fullName: $&#123;cat.name:xiaohong&#125;_cat 2.5.多个配置文件切换在SpringBoot的应用中可以书写多个配置文件，使用applocation-dev.properties来标识这是一个开发配置文件，在application.properties文件中使用配置spring.profiles.active = dev来激活我们需要的配置文件；如果使用yaml为配置文件格式，那么可以使用yaml特有的多文档模式来切换配置文件，如下： 123456789101112131415spring: profiles: active: prod---server: port: 8082spring: profiles: dev---server: port: 8084spring: profiles: prod 2.6.配置文件加载顺序SpringBoot启动后会顺序扫描:类路径下的config文件夹、项目根下的配置文件、classpath:config、classpath:/，优先级从高到低，高优先级的配置会覆盖低优先级的配置； 三、SLF4J日志框架日志框架就是记录系统运行时候产生了一些痕迹，方便问题的追踪和排查，这里我们说的是SLF4J+Logback 3.1.使用方法12345678910Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; logger.trace(\"这是trace日志信息\"); logger.debug(\"这是debug日志信息\"); logger.info(\"这是info日志信息\"); logger.warn(\"这是warn日志信息\"); logger.error(\"这是error日志信息\"); &#125; 当然你也可以在项目的配置文件中配置日志的输出格式，输出路径等信息，例如：logging.path配置在当前项目下生成log文件，使用logging.file指定完整的文件保存路径等等一些列都可以设置； 四、web开发相关在SpringBoot开发中，我们需要使用什么技术，只需要在创建项目的时候选中我们需要的模块，然后在配置文件中指定少数的配置就可以运行了； 4.1.静态资源文件映射规则在动态web项目中，我们可以将静态资源文件放在app目录下，然后访问，在SpringBoot下，我们可以使用webjars的方式来引入我们需要的静态文件，首先我们可以在WebMvcAutoConfiguration类中找到我们的静态资源映射规则的配置方法，如下； .png) 从上面的代码我们看出，任何以/webjars/**的访问请求都会去classpath:/META-INF/resources/webjars/下面找资源文件，所谓的webjars就是以一种maven的方式导入前端需要的框架资源，下载地址，使用方式很简单，示例如下： 12345 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt; 上面说的是我们的存在webjars的静态资源文件，如果是我们自己的资源文件，存放路径为： 12345&quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&quot;/&quot;:当前项目的根路径 系统欢迎页面的映射配置，是在静态资源文件下的所有的index.html文件，被/**映射； 1234@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125; 4.2.模版引擎Thymeleaf引入thymeleaf 1234&lt;dependency&gt; &lt;groupId&gt;com.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 升级thymeleaf版本 1234567&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"Java常用代码片段","slug":"Java常用代码片段","date":"2019-03-21T15:38:42.000Z","updated":"2019-03-21T15:24:13.106Z","comments":true,"path":"2019/03/21/Java常用代码片段/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/Java常用代码片段/","excerpt":"一、Java中常用判空1.1.字符串判空1StringUtils.isNotBlank(str)","text":"一、Java中常用判空1.1.字符串判空1StringUtils.isNotBlank(str) 1.2.数组判空1ArrayUtils.isNotEmpty(names); 1.3.集合去重12 二、日期类型常用代码2.1.Date转String1FastDateFormat.getInstance(\"yyyy-MM-dd HH:mm:ss\").format(new Date()); 说明：也可以使用DateFormatUtils类：DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;); 2.2.String转Date1DateUtils.parseDate(\"2018-12-23 12:23:59\", \"yyyy-MM-dd HH:mm:ss\"); 2.3.DateUtils类简要说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 判断两个Date是否是同一天DateUtils.isSameDay(new Date(), new Date());// 年份加减DateUtils.addYears(new Date(), -3);// 月份加减DateUtils.addMonths(new Date(), 2);// 日加减DateUtils.addDays(new Date(),1);// 周加减DateUtils.addWeeks(new Date(),1);// 小时加减DateUtils.addHours(new Date(),5);// 分钟加减DateUtils.addMinutes(new Date(),5);// 秒加减DateUtils.addSeconds(new Date(),5);// 毫秒加减DateUtils.addMilliseconds(new Date(),5);// 给年份设值DateUtils.setYears(new Date(), 2019);// 给月份设值：说明：给月份设置的时候参数为0表示设置为1月；DateUtils.setMonths(new Date(),0);// 给日设置DateUtils.setDays(new Date(),1);// 给小时设置DateUtils.setHours(new Date(),13);// 给分钟设置DateUtils.setMinutes(new Date(),32);// 给秒和毫秒设置DateUtils.setSeconds(new Date(),56);DateUtils.setMilliseconds(new Date(),998);// 对指定的的日期进行四舍五入：2019-01-01 00:00:00.000DateUtils.round(new Date(),Calendar.YEAR);// 2018-09-01 00:00:00.000DateUtils.round(new Date(),Calendar.MARCH);// 2018-09-15 01:00:00.000DateUtils.round(new Date(),Calendar.HOUR_OF_DAY);// 2018-09-15 00:00:00.000 DateUtils.round(new Date(),Calendar.DAY_OF_MONTH);// 2018-09-15 00:00:00.000DateUtils.round(new Date(),Calendar.DATE);// 2018-09-15 01:00:00.000DateUtils.round(new Date(),Calendar.HOUR);// 2018-09-15 00:36:00.000DateUtils.round(new Date(),Calendar.MINUTE);// 2018-09-15 00:36:30.000DateUtils.round(new Date(),Calendar.SECOND);// 从指定的日期开始截取格式化日期:2018-01-01 00:00:00.000DateUtils.truncate(new Date(),Calendar.YEAR);// 2018-09-01 00:00:00.000DateUtils.truncate(new Date(),Calendar.MONTH);// 2018-09-15 00:00:00.000DateUtils.truncate(new Date(),Calendar.DATE);// 2018-09-15 00:00:00.000 DateUtils.truncate(new Date(),Calendar.HOUR);// 2018-09-15 00:52:00.000DateUtils.truncate(new Date(),Calendar.MINUTE);//2018-09-15 00:52:11.000DateUtils.truncate(new Date(),Calendar.SECOND);// 将日期向上取整，当前时间：2018-09-16 21:26:29.917// 2019-01-01 00:00:00.000DateUtils.ceiling(new Date(),Calendar.YEAR);// 2018-10-01 00:00:00.000DateUtils.ceiling(new Date(),Calendar.MONTH);// 2018-09-16 22:00:00.000DateUtils.ceiling(new Date(),Calendar.HOUR_OF_DAY);// 2018-09-17 00:00:00.000DateUtils.ceiling(new Date(),Calendar.DAY_OF_MONTH);// 2018-09-16 22:00:00.000DateUtils.ceiling(new Date(),Calendar.HOUR);// 2018-09-16 21:27:00.000DateUtils.ceiling(new Date(),Calendar.MINUTE); 2.4.ArraysUtil类sha","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"},{"name":"常用代码","slug":"常用代码","permalink":"https://caochenhins.github.io/tags/常用代码/"}]},{"title":"SpringCloud学习总结","slug":"SpringCloud学习总结","date":"2019-03-21T15:34:08.000Z","updated":"2019-03-21T15:23:35.063Z","comments":true,"path":"2019/03/21/SpringCloud学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/SpringCloud学习总结/","excerpt":"SpringCloud概述SpringCloud是什么SpringCloud，基于SpringBoot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，等组件。换句话说是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。","text":"SpringCloud概述SpringCloud是什么SpringCloud，基于SpringBoot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，等组件。换句话说是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。 SpringBoot和SpringCloud SpringBoot专注于快速方便的开发单个个体微服务 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的单体微服务整合并管理，为各个微服务之间提供配置管理，服务发现，路由，分布式会话等集成服务 SpringBoot可以离开SpringCloud独立的开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系 SpringBoot专注于快速，方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架 Double和SpringCloud首先可以在GitHub上看到二者的活跃度，其次是比较各功能组件的支持情况，最大的区别在于SpringCloud抛弃了Dubbo的RPC通信，采用的是HTTP的REST方式，如下： Dobbo SpringCloud 服务注册中心 Zookeeper SpringCloud Netflix Eureka 服务调用方式 RPC Rest API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netflix Hystrix 服务网关 无 Spring Cloud Netflix Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task SpringCloud资料SpringCloud各个组件的文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud中文API：https://springcloud.cc/spring-cloud-dalston.html SpringCloud实践准备项目技术版本SpringCloud版本：Dalston.SR1，SpringBoot版本：1.5.9 项目说明项目是使用SpringCloud将四个工程进行整合，microservicecloud整体父工程Project，microservicecloud-api公共子模块Module，microservicecloud-provider-dept-8001部门微服务提供者Module，microservicecloud-consumer-dept-80部门微服务消费者Module。 1.父类项目创建在逻辑视图中选择new-Maven Project-勾上创建简单项目-选择pom方式 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 2.公共组件项目创建在父项目上创建microservicecloud-api项目，注意是在microservicecloud上new一个maven module，packaging选择jar POM.xml文件12345678910111213141516171819&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Dept实体类123456789101112131415161718192021222324252627282930313233343536public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称、 private String db_source; // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 public Dept() &#123; super(); &#125; public Dept(Long deptno, String dname, String db_source) &#123; super(); this.deptno = deptno; this.dname = dname; this.db_source = db_source; &#125; public Long getDeptno() &#123; return deptno; &#125; public void setDeptno(Long deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getDb_source() &#123; return db_source; &#125; public void setDb_source(String db_source) &#123; this.db_source = db_source; &#125; @Override public String toString() &#123; return \"Dept [deptno=\" + deptno + \", dname=\" + dname + \", db_source=\" + db_source + \"]\"; &#125; 当我们每次都需要创建一个实体类的getter，setter，toString和构造器等方法时，如果增加一个字段就要重新生成方法，为了简化这种重复的操作，我们在前面的pom中引入了lombok，同样的实体类，使用方法如下 1234567891011@SuppressWarnings(\"serial\")@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain=true)public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称 // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 private String db_source; &#125; lombok安装方法拷贝lombok-1.16.18.jar到Eclipse目录下，执行java -jar D:\\javasoft\\eclipse-jee-neon-3-win32-x86_64\\eclipse\\ombok-1.16.18.jar，然后，弹框中选择Eclipse安装目录，选择install即可。 lombok注解使用1234567@Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual@Setter：注解在属性上；为属性提供 setting 方法@Getter：注解在属性上；为属性提供 getting 方法@Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象@NoArgsConstructor：注解在类上；为类提供一个无参的构造方法@AllArgsConstructor：注解在类上；为类提供一个全参的构造方法@Accessors(chain=true)：可以使用链式写法 lombok测试123456789101112131415@SuppressWarnings(\"serial\")@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain=true)public class Dept implements Serializable&#123; private Long deptno; // 主键 private String dname; // 部门名称、 private String db_source; // 来自那个数据库，因为微服务可以一个服务对应一个数据库，同一个信息被存储到不同的数据库 public static void main(String[] args) &#123; Dept dept = new Dept(); dept.setDeptno(12L).setDname(\"开发部\").setDb_source(\"DB01\"); &#125;&#125; 注意内容实体类必须实现Serializable接口 打包使用公共组件模块写好后可以点击run as 选择maven clean ，然后在选择maven install。其他模块引用的方法如下 123&lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;&lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 3.部门微服务提供者首先现在父类项目上new一个maven module,microservicecloud-provider-dept-8001修改pom.xml文件 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-provider-dept-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678910111213141516171819202122232425262728server: port: 8001 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间 eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka mybatis下mybatis.cfg.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt;&lt;!-- 二级缓存开启 --&gt; &lt;/settings&gt;&lt;/configuration&gt; SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB01 ;CREATE DATABASE cloudDB01 CHARACTER SET UTF8 ;USE cloudDB01 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); dao接口12345678@Mapperpublic interface DeptDao &#123; public boolean addDept(Dept dept); public Dept findById(Long id); public List&lt;Dept&gt; findAll();&#125; DeptMapper.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.luo.springcloud.dao.DeptDao\"&gt; &lt;select id=\"findById\" resultType=\"Dept\" parameterType=\"Long\"&gt; select deptno,dname,db_source from dept where deptno=#&#123;deptno&#125;; &lt;/select&gt; &lt;select id=\"findAll\" resultType=\"Dept\"&gt; select deptno,dname,db_source from dept; &lt;/select&gt; &lt;insert id=\"addDept\" parameterType=\"Dept\"&gt; INSERT INTO dept(dname,db_source) VALUES(#&#123;dname&#125;,DATABASE()); &lt;/insert&gt;&lt;/mapper&gt; DeptService12345public interface DeptService &#123; public boolean add(Dept dept); public Dept get(Long id); public List&lt;Dept&gt; list();&#125; DeptServiceImpl1234567891011121314151617181920@Servicepublic class DeptServiceImpl implements DeptService&#123; @Autowired private DeptDao dao; @Override public boolean add(Dept dept) &#123; return dao.addDept(dept); &#125; @Override public Dept get(Long id) &#123; return dao.findById(id); &#125; @Override public List&lt;Dept&gt; list() &#123; return dao.findAll(); &#125;&#125; DeptController1234567891011121314151617181920@RestControllerpublic class DeptController &#123; @Autowired private DeptService service; @RequestMapping(value=\"/dept/add\",method=RequestMethod.POST) public boolean add(@RequestBody Dept dept)&#123; return service.add(dept); &#125; @RequestMapping(value=\"dept/get/&#123;id&#125;\",method=RequestMethod.GET) public Dept get(@PathVariable(\"id\") Long id)&#123; return service.get(id); &#125; @RequestMapping(value=\"dept/list\",method=RequestMethod.GET) public List&lt;Dept&gt; list()&#123; return service.list(); &#125;&#125; 创建主启动类DeptProvider8001_App123456@SpringBootApplicationpublic class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 测试结果输入http://localhost:8001/dept/list以JSON的方式返回数据 4.部门微服务消费者首先现在父类项目上new一个maven module,microservicecloud-consumer-dept-80修改pom.xml文件 POM.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-80&lt;/artifactId&gt; &lt;description&gt;部门微服务消费者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12server: port: 80 ConfigBean注解类1234567@Configurationpublic class ConfigBean &#123; @Bean public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125;&#125; RestTemplateRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单高效便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具类集，使用方法如下 （url,requestMap,ResponseBean.class）三个参数分别代表Rest请求地址，请求参数，HTTP响应转换被转换的对象类型 DeptController_Consumer123456789101112131415161718192021@RestControllerpublic class DeptController_Consumer &#123; private static final String REST_URL_PREFIX = \"http://localhost:8001\"; @Autowired private RestTemplate restTemplate; @RequestMapping(value=\"/consumer/dept/add\") public boolean add(Dept dept)&#123; return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\", dept, Boolean.class); &#125; @RequestMapping(value=\"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id)&#123; return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/get/\"+id, Dept.class); &#125; @RequestMapping(value=\"/consumer/dept/list\") public Dept list()&#123; return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/list/\", Dept.class); &#125;&#125; DeptConsumer80_App主类123456@SpringBootApplicationpublic class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 测试结果http://localhost/consumer/dept/list http://localhost/consumer/dept/get/2 http://localhost/consumer/dept/add?dname=AI Eureka服务注册与发现Eureka三大角色 Eureka Server提供服务注册和发现 Service Provider服务提供方将自身服务注册到Eureka， 从而使服务消费者能够找到 Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费 1.Eureka Server注册在上述项目的父工程中新建microservicecloud-eureka-7001，这个module是Eureka的服务中心 POM.xml文件123456789101112131415161718192021222324252627&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-eureka-7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-server服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件1234567891011server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ EurekaServer主启动类1234567@SpringBootApplication@EnableEurekaServer// EurekaServer服务器端启动类，接收其它微服务注册进来public class EurekaServer7001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7001_App.class, args); &#125;&#125; 测试EurekaServer浏览器输入http://localhost:7001/，看到Spring Eureka界面表示成功，这个访问链接和程序中的application.yml配置吻合。 2.微服务注册将microservicecloud-provider-dept-8001微服务注册到microservicecloud-eureka-7001中 修改microservicecloud-provider-dept-8001的POM.xml文件123456789&lt;!-- 将微服务provider侧注册进eureka --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 修改microservicecloud-provider-dept-8001的application.yml文件1234eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka 说明：defaultZone的地址对应Eureka Server服务注册中心的application.yml中的defaultZone路径 microservicecloud-provider-dept-8001主程序类使用注解1234567@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心public class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 测试是否注册成功先启动Eureka服务注册中心microservicecloud-eureka-7001，启动微服务microservicecloud-provider-dept-8001，打开浏览器输入http://localhost:7001/，Application下出现**MICROSERVICECLOUD-DEPT**微服务名称，这个名称来源于microservicecloud-provider-dept-8001中application.ym文件中的配置属性，如下 123spring: application: name: microservicecloud-dept 3.微服务常用设置主机名称和服务名称修改在Eureka中注册的微服务的Status的名称显示localhost或者显示电脑主机名，所以要修改服务的主机名称，修改方法如下，修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 12instance: instance-id: microservicecloud-dept8001 访问信息有IP信息提示修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 123instance: instance-id: microservicecloud-dept8001 prefer-ip-address: true #访问路径可以显示IP地址 微服务info内容详细信息增加microservicecloud-provider-dept-8001中POM.xml文件 12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 总的父工程microservicecloud修改pom.xml添加构建build信息 12345678910111213141516171819202122&lt;build&gt; &lt;finalName&gt;microservicecloud&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 说明在src/main/resources目录下的配置文件 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;!-- 表示以$开始和以$结束的表示方法 --&gt; &lt;delimit&gt;$&lt;/delimit&gt; &lt;/delimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 修改microservicecloud-provider-dept-8001中application.yml文件，修改后如下 12345info: app.name: luokangyuan-microservicecloud company.name: www.luokangyuan.com build.artifactId: $project.artifactId$ build.version: $project.version$ 4.Eureka的自我保护机制导致的原因默认情况下，如果EurekaServer在一定的时间内没有接收到某一个微服务实例的心跳，EurekaServer将会注销该实例，页面就会看见一串红色提示，但是当网络分区发生故障时，微服务与EurekaServer无法进行正常的通信，此时本不应该注销这个微服务实例，这个时候，Eureka的自我保护机制就可以解决这个问题，当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式，一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务），当网络故障恢复后，该EurekaServer节点就会自动退出自我保护模式。 总结在自我保护模式下，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例，当它收到的心跳数重新到阈值以上，该EurekaServer就会自动退出自我保护模式，也就是宁可保留错误的服务注册信息，也不盲目的删除任何可能健康的服务实例。 5.服务发现对于注册近Eureka里面的微服务，可以通过服务发现来获取该服务的信息 修改microservicecloud-provider-dept-8001的DeptController12345678910111213141516@Autowiredprivate DiscoveryClient client;@RequestMapping(value = \"/dept/discovery\", method = RequestMethod.GET)public Object discovery()&#123; List&lt;String&gt; list = client.getServices();//得到Eureka中所有的微服务 System.out.println(\"**********\" + list); List&lt;ServiceInstance&gt; srvList = client.getInstances(\"MICROSERVICECLOUD-DEPT\"); for (ServiceInstance element : srvList) &#123; System.out.println(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); &#125; return this.client;&#125; microservicecloud-provider-dept-8001主启动类添加注解12345678@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心@EnableDiscoveryClient // 服务发现public class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class, args); &#125;&#125; 自测试启动服务注册中心microservicecloud-eureka-7001，再启动microservicecloud-provider-dept-8001，访问http://localhost:8001/dept/discovery可以得到这个服务的info信息，/dept/discovery接口就是microservicecloud-provider-dept-8001这个服务暴露给外部访问的接口。使用http://localhost:8001/dept/discovery测试，就是自己测试能不能使用 外部访服务暴露的接口microservicecloud-consumer-dept-80调用microservicecloud-provider-dept-8001服务暴露在外的接口，修改microservicecloud-consumer-dept-80中的DeptController_Consumer，如下 12345// 测试@EnableDiscoveryClient,消费端可以调用服务发现@RequestMapping(value = \"/consumer/dept/discovery\")public Object discovery()&#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/discovery\", Object.class);&#125; 消费者访问接口测试启动microservicecloud-consumer-dept-80访问http://localhost/consumer/dept/discovery得到8001微服务信息 总结 microservicecloud-provider-dept-8001注册到EurekaServer服务中心 microservicecloud-provider-dept-8001将Controller中的某一个方法暴露出去（提供服务发现） microservicecloud-consumer-dept-80中的Controller就可以调用微服务暴露出来的接口 Eureka集群配置microservicecloud-eureka-7001使EurekaServer服务注册中心，一旦这个出现问题，那么微服务就不能正常的工作，为防止这种情况，所以出现了集群，就是建立多个microservicecloud-eureka-7002，microservicecloud-eureka-7003等服务注册中心。 新建microservicecloud-eureka-7002，microservicecloud-eureka-7003服务注册中心 根据microservicecloud-eureka-7001的pom.xml修改7002和7003的pom.xml文件 复制7001的主程序启动类，并修改为7002,7003即可 修改映射配置在7001注册中的application.yml文件中hostname，不能与7002,7003相同，所以要做映射配置 123eureka: instance: hostname: localhost #eureka服务端的实例名称 修改C:\\Windows\\System32\\drivers\\etc\\host文件,让127.0.0.1有三个别名 123127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com127.0.0.1 eureka7003.com microservicecloud-eureka-7001中的yml修改123456789101112server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ microservicecloud-eureka-7002中的yml修改123456789101112server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ microservicecloud-eureka-7003中的yml修改123456789101112server: port: 7003eureka: instance: hostname: eureka7003.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 修改dept微服务的yml文件dept微服务会同时注册到7001,7002,7003服务注册中心 12345eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 测试 访问eureka7001.com:7001 访问eureka7002.com:7002 访问eureka7003.com:7003 Eureka和Zookeeper区别遵循原则不同Eureka遵循AP原则，Zookeeper遵循CP原则，C：强一致性，A：可用性，P：分区容错性 著名的CAP理论中提出，一个分布式系统不可能同时满足C(一致性)A(可用性)P(分区容错性)，由于分区容错性p是分布式系统中必须保证，因此只能在A和C之间权衡 Zookeeper保证CP在Zookeeper中存在一种情况下，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是，选举leader的时间太长，且选举过程中这个Zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪，在云部署的环境中，因为网络问题使得Zookeeper集群失去master节点的可能性较大，虽然服务最终能够恢复，但是在漫长的选举时间导致的注册时间不可用是不能容忍的，当我们向注册中心查询注册列表时，可以忍受注册中心返回的是几分钟以前的注册信息，但是不能接收服务直接down不可用，也就是说，服务注册对可用性的要求高于一致性。 Eureka保证APEureka知道Zookeeper的不足，所以设计最初就保证可用性，Eureka各个节点都是平等的，几个节点的挂点不会影响其他正常节点的工作，剩余的节点仍然可以提供注册和查询服务，只不过不能保证查询的信息是最新的，除此之外，Eureka还有一种自我保护机制，当过多的节点没有正常的心跳时，那么Eureka就会认为客户端出现了网络故障，此时Eureka会 Eureka不会从注册表中移除因为长时间没有收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点上（保证当前节点可用） 当网络稳定时，当前实例新的注册信息会被同步到其他节点上 Ribbon负载均衡Ribbon概述Spring Cloude Ribbon是基于Netfilx Ribbon实现的一套客户端 负载均衡的工具，简单说，Ribbon是Netfilix发布的开源项目，主要功能就是提供 客户端的软件负载均衡算法，将Netfilix的中间层服务连接在一起，Ribbon客户端组件提供了一系列完善的配置项如连接超时，重试等，简单说，就是在配置文件中列出Load Balance后面的所有机器，Ribbon会自动的帮助你基于某种算法规则（简单轮询，随机连接等）去连接这些机器，也可以使用Ribbon自定义负载均衡算法。LB，即负载均衡，在微服务或者分布式集群中常用的一种应用。负载均衡就是将用户的请求平摊的分配到多个服务上，从而达到HA，常见的负载均衡软件有Nginx，LVS，硬件F5等 Ribbon配置初步由于Ribbon是客户端的负载均衡工具，所以我们需要修改的是客户端项目microservicecloud-consumer-dept-80 POM.xml文件1234567891011121314151617&lt;!-- Ribbon相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml文件，添加Eureka的服务注册地址1234567server: port: 80eureka: client: register-with-eureka: false #自己不能注册 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 修改客户端配置类由于客户端使用restTemplate访问服务端中的数据接口，restTemplate配置在服务端的配置类中，所以修改如下 12345678@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改客户端主程序启动类1234567@SpringBootApplication@EnableEurekaClientpublic class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 修改客户端访问类DeptController_Consumer.java1private static final String REST_URL_PREFIX = \"http://MICROSERVICECLOUD-DEPT\"; 测试启动7001,7002,7003三个服务注册中心，启动8001服务提供者，启动80客户端，使用http://localhost/consumer/dept/list可以渠道对应的数据，在DeptController_Consumer使用的是http://MICROSERVICECLOUD-DEPT服务名称来调用服务的接口，相比之前的http://localhost:8001，Ribbon和Eureka整合后，Consumer可以直接通过服务名称来调用服务，而不再关心地址和端口号。 Ribbon负载均衡 目前只有一个microservicecloud-provider-dept-8001服务提供者，为了实现Ribbon的负载均衡，所以我们需要多个服务提供者实例，新建microservicecloud-provider-dept-8002，microservicecloud-provider-dept-8003两个Module。参考8001的pom.xml文件修改8002,8003的pom.xml文件。拷贝8001中的所以类和配置文件mybatis和application.yml文件，将主启动类修改为对应的名字 microservicecloud-provider-dept-8002服务提供者使用的数据库SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB02 ;CREATE DATABASE cloudDB02 CHARACTER SET UTF8 ;USE cloudDB02 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); Application.yml文件1234567891011121314151617181920212223server: port: 8002 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB02 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 microservicecloud-provider-dept-8003服务提供者使用的数据库SQL语句1234567891011121314151617DROP DATABASE IF EXISTS cloudDB03 ;CREATE DATABASE cloudDB03 CHARACTER SET UTF8 ;USE cloudDB03 ;CREATE TABLE dept ( deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT, dname VARCHAR (60), db_source VARCHAR (60)) ;INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE()); Application.yml文件1234567891011121314151617181920212223server: port: 8003 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB03 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 微服务提供者说明三个微服务提供者连接不同的数据库，因此在application.yml文件中，我们需要修改端口号和连接的数据库，注意的是三个微服务提供者的微服务名字保持一样，也就是如下的配置信息 123spring: application: name: microservicecloud-dept 负载均衡自测访问连接http://localhost:8001/dept/list，http://localhost:8002/dept/list，http://localhost:8003/dept/list得到不同数据库数据，当我们启动服务注册中心7001,7002,7003,再启动80客户端，这个时候访问localhost/consumer/dept/list，每次刷新就会得到不同数据库的数据。这就是Ribbon默认的轮询算法的负载均衡。 Ribbon核心组件IRuleRibbon负载均衡算法Ribbon默认提供的是轮询的负载均衡算法，完整了还有如下 RoundRobinRule 轮询 RandomRule 随机 AvaliabilityFilteringRule 会先过滤由于多次访问故障而处于断路器跳闸的状态的服务和并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略 WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大 RetryRule 先按照RoundRobinRule策略获取服务，如果获取服务失败会在指定时间内重试 BestAvailableRule 会先过滤掉由于多次访问故障二处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 ZoneAvoidanceRule 默认规则，复合判断server所在的区域的性能和server的可用性选择服务器 Ribbon负载均衡算法使用方法在客户端的配置类ConfigBean.java中添加IRule的实现 123456789101112@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate geRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public IRule myRule()&#123; return new RandomRule(); &#125;&#125; Ribbon自定义如果不使用Ribbon默认的七种负载均衡算法，这个时候就需要使用自定义负载均衡算法 客户端主启动类使用注解@RibbonClient12345678@SpringBootApplication@EnableEurekaClient@RibbonClient(name=\"MICROSERVICECLOUD-DEPT\",configuration=MySelfRule.class)public class DeptConsumer80_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_App.class, args); &#125;&#125; 特此说明 RibbonClient注解中的MySelfRule类使我们自定义负载均衡算法的类，但是，这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们这个自定义的配置类会被所有的Ribbon客户端所共享，也就说，达不到我们特殊化定制的目的。举例说明，自定义配置类不能放在项目主启动类所有的包以及子包下，因为主启动类使用注解@SpringBootApplication，这个注解点进去使用@ComponentScan注解 自定义负载均衡算法轮询算法中每一个服务轮询一次，现在需求是每一个服务调用五次后在轮询下一个服务 自定义配置类12345678910111213package com.luo.myrule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.netflix.loadbalancer.IRule;@Configurationpublic class MySelfRule &#123; @Bean public IRule myRule()&#123; return new RandomRule_lky(); &#125;&#125; 自定义算法类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.luo.myrule;import java.util.List;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;public class RandomRule_lky extends AbstractLoadBalancerRule&#123; // total = 0 // 当total==5以后，我们指针才能往下走， // index = 0 // 当前对外提供服务的服务器地址， // total需要重新置为零，但是已经达到过一个5次，我们的index = 1 // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？ private int total = 0; // 总共被调用的次数，目前要求每台被调用5次 private int currentIndex = 0; // 当前提供服务的机器号 public Server choose(ILoadBalancer lb, Object key)&#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; return null; &#125;// private int total = 0; // 总共被调用的次数，目前要求每台被调用5次// private int currentIndex = 0; // 当前提供服务的机器号 if(total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125;else &#123; total = 0; currentIndex++; if(currentIndex &gt;= upList.size()) &#123; currentIndex = 0; &#125; &#125; if (server == null) &#123; Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key)&#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig)&#123;&#125;&#125; Feign负载均衡Feign是一个声明式WebService客户端，使用Feign能够让编写Web Service客户端变得更简单，它的使用方法就是定义一个接口，然后在上面添加注解。SpringCloud对Feign进行了封装，支持SpringMVC注解和HTTPMessageConverters，Feign可以与Eureka和Ribbon组合使用以支持负载均衡。简单讲，只需要创建一个接口，然后在上面使用注解即可。 Feign使用步骤参考项目microservicecloud-consumer-dept-80新建microservicecloud-consumer-dept-feign,拷贝相应的包和配置文件，去掉IRule等信息，修改pom.xml文件，添加对Feign的支持 pom.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-dept-feign&lt;/artifactId&gt;&lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 自己定义的api --&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 由于Feign是面向接口编程，为方便接口的互相调用，将接口和公共的方向在项目microservicecloud-api中，因此修改为： 修改microservicecloud-api工程的pom.xml文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 新建DeptClientService接口1234567891011@FeignClient(value = \"MICROSERVICECLOUD-DEPT\")public interface DeptClientService &#123; @RequestMapping(value = \"/dept/get/&#123;id&#125;\",method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\",method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 修改microservicecloud-consumer-dept-feign中Controller添加新建的DeptClientService1234567891011121314151617181920@RestControllerpublic class DeptController_Consumer &#123; @Autowired private DeptClientService service; @RequestMapping(value = \"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id)&#123; return this.service.get(id); &#125; @RequestMapping(value = \"/consumer/dept/list\") public List&lt;Dept&gt; list()&#123; return this.service.list(); &#125; @RequestMapping(value = \"/consumer/dept/add\") public Object add(Dept dept)&#123; return this.add(dept); &#125;&#125; 修改microservicecloud-consumer-dept-feign主启动类,添加注解123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients(basePackages = &#123;\"com.luo.springcloud\"&#125;)@ComponentScan(\"com.luo.springcloud\")public class DeptConsumer80_Feign_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer80_Feign_App.class, args); &#125;&#125; 测试启动3个Eureka集群，启动三个部门微服务提供者，启动Feign，访问http://localhost/consumer/dept/list即可 总结说明Feign集成了Ribbon，利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并通过轮询的方式实现了客户端的复杂均衡，与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式法人方法，优雅而简单的实现服务调用。 Hystrix断路器概述Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多的依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下， 不会导致整体服务的失败，避免级联故障，以提高分布式系统的弹性。断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方法返回一个预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法异常无法处理的异常，这样就保证服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延。 服务熔断熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某一个微服务不可用或者响应时间太长，会进行服务的降级， 进而熔断该节点微服务的调用，快速返回“错误”的响应信息，当检测到该节点微服务调用响应正常后恢复调用链路，在SpringCloud框架中熔断机制使用Hystrix实现，Hystrix会监控微服务调用情况，当失败达到一定阈值。就会启动熔断机制，熔断机制的注解是 @HystrixCommand Hystrix实操参照microservicecloud-provider-dept-8001建立microservicecloud-provider-dept-hystrix-8001项目pom.xml文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-provider-dept-hystrix-8001&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址 1234567891011121314151617181920212223242526272829303132333435363738server: port: 8001 mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路径 type-aliases-package: com.luo.springcloud.entities # 所有Entity别名类所在包 mapper-locations: - classpath:mybatis/mapper/**/*.xml # mapper映射文件 spring: application: name: microservicecloud-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/cloudDB01 # 数据库名称 username: root password: 1234 dbcp2: min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化连接数 max-total: 5 # 最大连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间 eureka: client: #客户端注册进eureka服务列表内 service-url: #defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept8001-hystrix #自定义服务名称信息 prefer-ip-address: true #访问路径可以显示IP地址 info: app.name: luokangyuan-microservicecloud company.name: www.luokangyuan.com build.artifactId: $project.artifactId$ build.version: $project.version$ 修改DeptControllerHystrix的作用就是当调用服务出现异常时如何解决，模拟根据id查部门信息，查到null，人为抛出运行时异常，让Hystrix处理这种情况。 123456789101112131415@RequestMapping(value=\"dept/get/&#123;id&#125;\",method=RequestMethod.GET)@HystrixCommand(fallbackMethod = \"processHystrix_GET\")public Dept get(@PathVariable(\"id\") Long id)&#123; Dept dept = service.get(id); if(null == dept)&#123; throw new RuntimeException(\"该ID:\"+id+\"没有对应的部门信息\"); &#125; return dept;&#125;public Dept processHystrix_GET(@PathVariable(\"id\") Long id)&#123; return new Dept().setDeptno(id) .setDname(\"该ID：\"+id+\"没有对应的信息，null--@HystrixCommand\") .setDb_source(\"no this database in Mysql\");&#125; 修改主启动类添加Hystrix支持123456789@SpringBootApplication@EnableEurekaClient // 本服务启动后会注册到Eureka服务注册中心@EnableDiscoveryClient // 服务发现@EnableCircuitBreaker //对Hystrix熔断机制的支持public class DeptProvider8001_Hystrix_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_Hystrix_App.class, args); &#125;&#125; 测试熔断机制启动三个Eureka集群，启动服务主启动类DeptProvider8001_Hystrix_App，客户端启动microservicecloud-consumer-dept-80，页面访问http://localhost/consumer/dept/get/112 服务降级服务降级处理是在客户端完成的，与服务端没有关系，在前面的服务熔断中，我们发现每一个业务方法都要写一个processHystrix_方法，这样就造成了很大耦合，根据Spring的学习，我们可将processHystrix_改写一个异常通知。 修改microservicecloud-api工程根据已有的DeptClientService接口，新建一个实现了FallbackFactory接口的类DeptClientServiceFallbackFactory 123456789101112131415161718192021222324252627282930313233343536package com.luo.springcloud.service;import java.util.List;import org.springframework.stereotype.Component;import com.luo.springcloud.entities.Dept;import feign.hystrix.FallbackFactory;@Componentpublic class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt;&#123; @Override public DeptClientService create(Throwable arg0) &#123; return new DeptClientService() &#123; @Override public List&lt;Dept&gt; list() &#123; return null; &#125; @Override public Dept get(long id) &#123; return new Dept().setDeptno(id) .setDname(\"该ID：\"+id+\"没有对应的信息，Consumer客户端提供的降级信息，此服务暂停使用\") .setDb_source(\"no this database in Mysql\"); &#125; @Override public boolean add(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; 注意：不要忘记新类上添加@Component注解 修改microservicecloud-api在DeptClientService接口在注解@FeignClient(value = “MICROSERVICECLOUD-DEPT”)添加fallbackFactory属性值 1@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class) 1234567891011@FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory = DeptClientServiceFallbackFactory.class)public interface DeptClientService &#123; @RequestMapping(value = \"/dept/get/&#123;id&#125;\",method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\",method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 修改microservicecloud-consumer-dept-feign的Application.yml文件1234567891011server: port: 80 feign: hystrix: enabled: trueeureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 测试服务降级启动三个Eureka集群，microservicecloud-provider-dept-8001启动，microservicecloud-consumer-dept-feign启动，正常访问http://localhost/consumer/dept/get/1测试，故意关停microservicecloud-provider-dept-8001，客户端自己调用提示 服务监控Hystrix DashboardHystrix还提供了准实时的调用监控Hystrix Dashboard，Hystx会持续的记录所有通过Hystrix发起的请求的执行信息，并以统计报表的图形的形式展示给用户，包括每秒执行多少次请求多少成功多少失败等，对监控内容转换为可视化界面。 新建microservicecloud-consumer-hystrix-dashboard监控的一个微服务工程 POM.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-consumer-hystrix-dashboard&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- 自己定义的api --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix和 hystrix-dashboard相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12server: port: 9001 主启动类DeptConsumer_DashBoard_App1234567@SpringBootApplication@EnableHystrixDashboardpublic class DeptConsumer_DashBoard_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer_DashBoard_App.class, args); &#125;&#125; 微服务提供者添加监控依赖配置所有的Provider微服务提供类（8001,8002,8003）都需要监控依赖配置，也就是pom文件添加如下依赖 12345&lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 监控页面测试启动microservicecloud-consumer-hystrix-dashboard，访问http://localhost:9001/hystrix,出现豪猪页面 全部测试启动3个Eureka集群，启动microservicecloud-provider-dept-hystrix-8001，启动了microservicecloud-consumer-hystrix-dashboard用来监控8001服务提供者，访问http://localhost:8001/hystrix.stream 观察监控窗口访问http://localhost:9001/hystrix，填写监控地址http://localhost:8001/hystrix.stream,时间2000，title:demo01,点击按钮 实心圆：两种含义，它通过颜色的变化代表了实例的健康程度，健康色是从绿色&lt;黄色&lt;橙色&lt;红色递减，该实心圆除了颜色的变化之外，他的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大，所以通过实心圆的展示就可以在大量实例中快速的发现 故障实例和高压力测试。 Zuul路由网关概述Zuul包含了对请求的路由和过滤两个主要的功能，其中路由的功能是负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤功能是负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础，Zuul和Eureka进行整合，将Zuul自身注册近Eureka服务治理的应用，同时从Eureka中获取其他微服务的消息，也及时以后的访问服务都是通过Zuul跳转后获得， 注意的是Zuul服务最终还是会注册近Eureka中 路由基本配置新建项目microservicecloud-zuul-gateway-9527，添加依赖如下 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-zuul-gateway-9527&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- zuul路由网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix容错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日常标配 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件12345678910111213141516171819202122232425server: port: 9527 spring: application: name: microservicecloud-zuul-gateway eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka,http://eureka7003.com:7003/eureka instance: instance-id: gateway-9527.com prefer-ip-address: true zuul: #ignored-services: microservicecloud-dept prefix: /luo ignored-services: \"*\"info: app.name: luo-microcloud company.name: www.luo.com build.artifactId: $project.artifactId$ build.version: $project.version$ 修改host文件1127.0.0.1 myzuul.com 主启动类Zuul_9527_StartSpringCloudApp1234567@SpringBootApplication@EnableZuulProxypublic class Zuul_9527_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(Zuul_9527_StartSpringCloudApp.class, args); &#125;&#125; 启动三个集群，一个服务提供类microservicecloud-provider-dept-8001，一个路由 测试不使用路由：http://localhosat:8001/dept/get/2 使用路由：http://myzuul.com:9527/microservicecloud-dept/dept/get/2 Zuul路由访问映射在前面的测试中我们可以使用http://myzuul.com:9527/microservicecloud-dept/dept/get/2访问我们的接口，这样就暴露我们的微服务名称，需要做安全加固，就用到了路由访问映射，修改路由项目的yml文件,添加 mydept.path: /mydept/** 1234567zuul: #ignored-services: microservicecloud-dept #忽略真实地址，只让虚拟地址访问 prefix: /luo #访问地址前缀 ignored-services: \"*\"#忽略真实地址，只让虚拟地址访问 routes: mydept.serviceId: microservicecloud-dept ##真实地址 mydept.path: /mydept/** # 虚拟地址 访问连接：http://lyzuul.com:9527/luo/mydept/dept/get/1 SpringCloudConfig配置中心概述就前面项目而言，分布面临的问题是配置问题，每一个项目都有一个yml文件，不好运维管理，所有需要一套集中式，动态的配置管理设施，SpringCloud提供了ConfigServer来解决这个问题。 SpringCloud Config是为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为 各个不同的微服务应用的环境提供了一个 中心化的外部配置。SpringCloud Config分为客户端和服务端，服务端也称 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密和解密信息等访问接口，客户端是通过指定的配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具管理和访问配置内容。 作用 集中管理配置文件 不同环境下不同配置，动态化的配置更新，分环境部署等 运行期间动态调整配置，不需要在每一个服务部署的机器编码上编写文件，服务会向配置中心拉取自己的配置信息 当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置 将配置信息以REST接口的形式暴露 config服务端与GitHub通信GitHUb上新建一个microservicecloud-config的Repository 本地硬盘目录新建git仓库并clone 在D:\\workspace2018\\micorservicecloude-config\\microservicecloud-config新建application.yml文件 1234567891011121314Spring: profiles: active: - dev---Spring: profiles: dev application: name: micorservicecloud-config-luo-dev---Spring: profiles: test application: name: micorservicecloud-config-luo-test 注意保存为utf-8的文件格式 将yml文件推送到GitHub上 123git add .git commit -m&quot;&quot;git push origin master 新建项目microservicecloud-config-3344 POM.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-config-3344&lt;/artifactId&gt;&lt;dependencies&gt; &lt;!-- springCloud Config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 避免Config的Git插件报错：org/eclipse/jgit/api/TransportConfigCallback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt; &lt;version&gt;4.10.0.201712302008-r&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 图形化监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 熔断 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件 1234567891011server: port: 3344 spring: application: name: microservicecloud-config cloud: config: server: git: uri: git@github.com:luokangyuan/microservicecloud-config.git #GitHub上面的git仓库名字 主启动类 1234567@SpringBootApplication@EnableConfigServerpublic class Config_3344_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(Config_3344_StartSpringCloudApp.class, args); &#125;&#125; 修改host文件 1127.0.0.1 config-3344.com 测试通过config微服务从GitHub上获取配置内容 启动服务3344，访问http://config-3344.com:3344/application-dev.yml，http://config-3344.com:3344/application-test.yml config客户端获取github配置本地新建microservicecloud-config-client.yml文件,并推送到github 123456789101112131415161718192021server: port: 8201spring: profiles: dev application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-dev.com:7001/eureka/---server: port: 8202spring: profiles: test application: name: microservicecloud-config-clienteureka: client: service-url: defaultZone: http://eureka-test.com:7001/eureka/ 新建项目microservicecloud-config-client-3355，pom.xml文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.luo.springcloud&lt;/groupId&gt; &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservicecloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringCloud Config客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建bootstrap.yml文件 1234567spring: cloud: config: name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名 profile: test #本次访问的配置项 label: master uri: http://config-3344.com:3344 #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址 application.yml是用户级的资源配置文件，bootstrap.yml是系统级，优先级更高，保证不会被本地配置文件所覆盖 修改host文件，增加映射 1127.0.0.1 client-config.com 新建测试controller，从github读取配置信息 123456789101112131415161718192021222324252627package com.luo.springcloud.rest;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ConfigClientRest&#123; @Value(\"$&#123;spring.application.name&#125;\") private String applicationName; @Value(\"$&#123;eureka.client.service-url.defaultZone&#125;\") private String eurekaServers; @Value(\"$&#123;server.port&#125;\") private String port; @RequestMapping(\"/config\") public String getConfig() &#123; String str = \"applicationName: \" + applicationName + \"\\t eurekaServers:\" + eurekaServers + \"\\t port: \" + port; System.out.println(\"******str: \" + str); return \"applicationName: \" + applicationName + \"\\t eurekaServers:\" + eurekaServers + \"\\t port: \" + port; &#125;&#125; 新建主启动类 123456@SpringBootApplicationpublic class ConfigClient_3355_StartSpringCloudApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClient_3355_StartSpringCloudApp.class, args); &#125;&#125; 测试 启动3344服务，启动3355服务，bootstrap.yml中的profile值是什么，决定从github上读取什么,ruguo 访问http://client-config.com:8201/config得到是github上的microservicecloud-config-client.yml文件中dev相关的配置信息 访问http://client-config.com:8202/config得到是github上的microservicecloud-config-client.yml文件中test相关的配置信息","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochenhins.github.io/tags/SpringCloud/"}]},{"title":"JavaEE进阶知识学习-----MybatisPus核心知识学习总结","slug":"JavaEE进阶知识学习-MybatisPus核心知识学习总结","date":"2019-03-21T15:31:53.000Z","updated":"2019-03-21T15:24:25.130Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-MybatisPus核心知识学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-MybatisPus核心知识学习总结/","excerpt":"一、MybatisPlus简介1.1.简介Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2.文档地址官网文档地址","text":"一、MybatisPlus简介1.1.简介Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2.文档地址官网文档地址 1.3.MybatisPlus的特性 无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性 依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 预防Sql注入：内置 Sql 注入剥离器，有效预防Sql注入攻击 通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题 支持热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动 支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作 支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（P.S. 比 Mybatis 官方的 Generator 更加强大！） 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 支持关键词自动转义：支持数据库关键词（order、key……）自动转义，还可自定义关键词 内置分页插件：基于 Mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作 二、集成MybatisPlus2.1.Maven导入MybatisPlus依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.0-gamma&lt;/version&gt;&lt;/dependency&gt; 2.2.修改sqpsessionFactoryBean123456789101112&lt;!-- 配置SqlSessionFactoryBean Mybatis提供的: org.mybatis.spring.SqlSessionFactoryBean MP提供的:com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean --&gt;&lt;!-- 配置sqlsessionFactoryBean --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!-- 别名处理 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.luo.beans\"&gt;&lt;/property&gt;&lt;/bean&gt; 三、入门的Hello World3.1.准备数据表123456789101112131415DROP TABLE IF EXISTS `tbl_user`;CREATE TABLE `tbl_user` ( `email` varchar(50) DEFAULT NULL, `age` int(11) DEFAULT NULL, `gender` char(255) DEFAULT NULL, `user_name` varchar(255) DEFAULT NULL, `id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;INSERT INTO `tbl_user` VALUES ('243518985@qq.com', 24, '1', '罗康元 ', 1);INSERT INTO `tbl_user` VALUES ('1835856@qq.com', 34, '2', '张三', 2);INSERT INTO `tbl_user` VALUES ('323134435@163.com', 53, '1', '李四', 3);INSERT INTO `tbl_user` VALUES ('345464566@qq.com', 43, '1', '王五', 4);INSERT INTO `tbl_user` VALUES ('luokangyuansb@gmail.com', 45, '1', '赵六', 5); 3.2.准备Java实体类123456789101112public class User &#123; private Integer id; private String userName; private String email; private Integer gender; private Integer age;&#125; 3.3.加入依赖的jar包1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;!-- mp依赖:mybatisPlus 会自动的维护Mybatis 以及MyBatis-spring相关的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.5.mybatis-config.xml文件12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt; 3.6.log4j.xml文件12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt; &lt;log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\"&gt; &lt;appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;param name=\"Encoding\" value=\"UTF-8\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=\"java.sql\"&gt; &lt;level value=\"debug\" /&gt; &lt;/logger&gt; &lt;logger name=\"org.apache.ibatis\"&gt; &lt;level value=\"info\" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=\"debug\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 3.7.db.properties文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Hongkongjdbc.username=rootjdbc.password=jiamei@20141107. 3.8.applicationContext.xml文件123456789101112131415161718192021222324252627282930&lt;!-- 数据源 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\" /&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务管理器 --&gt;&lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--基于注解的事务管理 --&gt;&lt;tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" /&gt;&lt;!-- 配置SqlSessionFactoryBean Mybatis提供的: org.mybatis.spring.SqlSessionFactoryBean MP提供的:com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean --&gt;&lt;!-- 配置sqlsessionFactoryBean --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!-- 别名处理 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.luo.beans\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置mybatis扫描的mapper接口路径--&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.luo.mapper\"&gt;&lt;/property&gt;&lt;/bean&gt; 3.9.通用的CRUD操作假设我们有一张user表，我们需要对这个表进行增删改查操作，如果说没有代码生成的话，在mybatis我们需要编写UserMapper接口，手写CRUD方法，在UserMapper.xml文件中写对应的sql语句，但是，在MybatisPlus中，我们只需要创建UserMapper接口，继承BaseMapper接口，就可以完成CRUD操作，甚至不需要创建SQl映射文件。 123public interface UserMapper extends BaseMapper&lt;User&gt;&#123;&#125; 然后，我们就写一些基本的单元测试方法，测试我们的CRUD，来到我们的测试类中，如下： 123456public class TestMp &#123; private ApplicationContext ioc = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); private UserMapper userMapper = ioc.getBean(\"userMapper\",UserMapper.class);&#125; 说明：在测试类中我们将使用从SpringIOC容器中获取的userMapper进行CRUD一系列操作 保存一条数据userMapper.insert(user); 123456789101112@Testpublic void insert()&#123; User user = new User(); user.setUserName(\"luokangyuan\"); user.setAge(66); user.setEmail(\"2356775645@qq.com\"); user.setGender(2); Integer result = userMapper.insert(user); System.out.println(result); // 直接获取插入数据返回的自增主键值 System.out.println(user.getId()+\"======\");&#125; 插入数据的方法有两个：insert和insertAllColumn，二者的执行结果是一样的，区别在于，前者会根据实体类的每一个属性值进行一个非空校验，在插入的sql语句中不会出现实体类属性为空的字段； 注意：在没有使用全局配置之前，我们需要指定实体类对应的数据库表和主键生成策略 主键生成策略：@TableId(type = IdType.AUTO,value = &quot;id&quot;),value属性值当实体类字段名和数据库一致时可以不写，这里的value指的是数据库字段名称，type的类型有以下几种： IdType.AUTO：数据库ID自增 IdType.INPUT：用户输入ID IdType.ID_WORKER：全局唯一ID，内容为空自动填充（默认配置） IdType.UUID：全局唯一ID，内容为空自动填充 实体对应表名注解：@TableName(value = &quot;tbl_user&quot;);指定当前实体类对应的数据库表 数据库字段映射名称：@TableField(value = &quot;user_name&quot;),当禁止驼峰映射规则后可以使用 忽略插入到表的字段：@ableField(exist = false),如下，数据库没有money这个字段，如果不忽略，那么插入就会报错，找不到这个字段； 12@TableField(exist = false)private Double money; 更新一条数据 12345678910@Testpublic void update()&#123; User user = new User(); user.setId(7); user.setUserName(\"王八\"); user.setAge(56); //user.setEmail(\"2356775645@qq.com\"); user.setGender(2); Integer result = userMapper.updateById(user);&#125; 同理：更新方法也有两个updateById和updateAllColumnById,前者会对实体类属性名进行非空校验，为空的就不会出现在sql语句中，也就是不会更新原有数据，后者是会更新所有列，如果实体类属性值为空，则数据库对应字段名更新为null； 查询一条数据 12345678910111213141516171819202122232425@Testpublic void select()&#123; // 1.通过ID查询一条数据 User user = userMapper.selectById(7); // 2.通过多个列进行查询,如果查处的数据有多条就会报错 User u = new User(); u.setId(2); u.setUserName(\"张三\"); User user1 = userMapper.selectOne(u); // 3.查询符合多个ID的数据,使用的是in关键字查询 List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(3); ids.add(4); ids.add(5); List&lt;User&gt; users = userMapper.selectBatchIds(ids); // 4.通过封装map条件,注意的是封装的是列字段名，不是实体里属性名， // map中的key充当sql中的条件名称 Map&lt;String,Object&gt; maps = new HashMap&lt;String, Object&gt;(); maps.put(\"user_name\",\"张三\"); maps.put(\"age\",347); List&lt;User&gt; users1 = userMapper.selectByMap(maps); // 5.分页查询方法,查看第二页，每页2条数据,在sql语句并没有limit关键字 // 所以要实现物理分页，还需借助插件，例如mybatis的pageHepler或者MybatisPlus提供的分页插件 List&lt;User&gt; users2 = userMapper.selectPage(new Page&lt;User&gt;(2, 2), null);&#125; 删除一条数据 123456789101112131415@Testpublic void delete()&#123; // 1.根据ID删除 Integer integer = userMapper.deleteById(8); // 2.根据条件删除，map中的key为列名，千万注意 Map&lt;String ,Object&gt; maps = new HashMap&lt;String, Object&gt;(); maps.put(\"age\",66); maps.put(\"gender\",2); Integer integer1 = userMapper.deleteByMap(maps); // 3.根据ID批量删除,使用in关键字 List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(5); ids.add(7); Integer integer2 = userMapper.deleteBatchIds(ids);&#125; 3.10.MybatisPlus全局配置在前面的CRUD操作中，我们会使用直接注解指定主键生成策略和表名到实体类的映射，但是配置的仅仅会对当前实体类起作用，所以，引入了全局配置，如下： 123456789&lt;!-- 定义MybatisPlus的全局策略配置--&gt;&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt;&lt;/bean&gt; 然后，将MybatisPlus全局配置注入到sqlSessionFactoryBean中 12&lt;!-- 注入全局MP策略配置 --&gt;&lt;property name=\"globalConfig\" ref=\"globalConfiguration\"&gt;&lt;/property&gt; 3.11.mybatisPlusCRUD总结在前面，我们实现了基本的CRUD操作，操作简单，仅仅只需继承一个BaseMapper就可以完成，实现单一，批量，分页等等一系列操作，很大的减少了开发负担，但这仅仅是Mybatisplus的冰山一角，当我们需要多条件查询的时候，就会使用到MybatisPlus中强大的条件构造器EntityWrapper； 四、条件查询条件构造器就是EntityWrapper，就是一个封装查询条件对象，让开发者自由的定义查询条件，主要用于sql的拼接，排序或者实体参数等；条件构造器 注意：使用的参数是数据库字段名称，不是Java类属性名 4.1.selectPage中的条件查询1234567891011@Testpublic void entityWrapperTedst()&#123; // 分页查询第一页，每页2条记录，年龄在41-53之间，genger为1，user_name为王五的用户 List&lt;User&gt; users = userMapper.selectPage(new Page&lt;User&gt;(1, 2), new EntityWrapper&lt;User&gt;() .between(\"age\", 41, 53) .eq(\"gender\",1) .eq(\"user_name\",\"王五\") );&#125; 4.2.模糊查询和或查询123456789@Testpublic void selectListTest()&#123; List&lt;User&gt; users = userMapper.selectList(new EntityWrapper&lt;User&gt;() .eq(\"gender\", 1) .like(\"user_name\", \"三\") .orNew() .like(\"email\", \"5\") );&#125; 使用或条件查询可以使用or()也可以使用orNew(),二者的区别在于sql中的条件部分不一样，如下： 使用or()的sql语句 1SELECT id AS id,user_name AS userName,email,gender,age FROM tbl_user WHERE (gender = ? AND user_name LIKE ? OR email LIKE ?) 使用orNew()的sql语句 1SELECT id AS id,user_name AS userName,email,gender,age FROM tbl_user WHERE (gender = ? AND user_name LIKE ?) OR (email LIKE ?) 4.3.修改满足条件的数据1234567891011@Testpublic void updataByEntityWrapper()&#123; User user = new User(); user.setEmail(\"luokangyuan@sina,com\"); user.setAge(24); user.setUserName(\"四川麻酱\"); Integer update = userMapper.update(user, new EntityWrapper&lt;User&gt;() .eq(\"user_name\",\"李四\") .eq(\"age\",53) );&#125; 4.4.删除满足条件的数据1234567@Testpublic void deleteByEntityWrapper()&#123; userMapper.delete(new EntityWrapper&lt;User&gt;() .eq(\"user_name\",\"王八\") .eq(\"age\",56) );&#125; 4.5.条件查询之ConditionCondition继承了Wrapper类，另外，我们不需要再new一个Condition对象，直接调用condition类的静态方法create就可以得到一个condition对象，然后使用wrapper的所有方法，简单使用如下： 123456@Testpublic void testCondition()&#123; userMapper.selectPage(new Page&lt;User&gt;(1,2), Condition.create() .between(\"age\",45,56) );&#125; 五、活动记录ARActive Record(活动记录)，简称AR，是一种领域模型模式，特点就是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一条记录； 5.1.开启AR模式开启AR模式的方法很简单，就是让我们的实体类继承Model类，并实现其抽象方法，指定主键即可，如下 1234567public class User extends Model&lt;User&gt; &#123; @Override protected Serializable pkVal() &#123; return id; &#125;&#125; 5.2.插入一条数据123456789@Testpublic void insert()&#123; User user = new User(); user.setUserName(\"杉木\"); user.setAge(25); user.setEmail(\"shancnu@163.com\"); user.setGender(1); boolean rs = user.insert();&#125; 5.3.修改一条数据12345678@Testpublic void update()&#123; User user = new User(); user.setUserName(\"杉木博客\"); user.setAge(35); user.setId(10); boolean rs = user.updateById();&#125; 说明：和通用的CRUD中的更新方法一样，updateAllColumnById()会更新所有列 5.4.查询数据12345678910111213141516@Testpublic void select()&#123; User user = new User(); user.setId(2); // 根据ID查询一条数据 User user1 = user.selectById(); // 查询所有的数据 List&lt;User&gt; users = user.selectAll(); // 根据条件查询 List&lt;User&gt; usersList = user.selectList(new EntityWrapper&lt;User&gt;() .like(\"user_name\", \"三\")); // 统计满足条件的数据数量 int gender = user.selectCount(new EntityWrapper&lt;User&gt;().eq(\"gender\", 1)); // 统计全表数量 int count = user.selectCount(null);&#125; 5.5.删除一条数据1234567@Testpublic void delete()&#123; User user = new User(); user.setId(7); boolean rs = user.deleteById(); System.out.print(rs);&#125; 当然，也可以根据条件删除多条数据，这里需要注意的是：当删除不存在的数据时候，返回的结果也是true； 1234// 删除不存在逻辑属于成功public static boolean delBool(Integer result) &#123; return null != result &amp;&amp; result &gt;= 0;&#125; 5.6.分页查询数据在前面的CRUD中的分页查询返回的是list数据集合，但是在AR中返回的却是Page对象，如下 1234567@Testpublic void selectPage()&#123; User user = new User(); Page&lt;User&gt; userPage = user.selectPage(new Page&lt;User&gt;(1, 2), new EntityWrapper&lt;User&gt;().like(\"user_name\", \"三\")); List&lt;User&gt; records = userPage.getRecords();&#125; 5.7.AR总结AR提供的是一种更为快速的实现CRUD操作，本质很是调用Mybatis对应的方法，说的简单一点就是语法糖； 糖虽然好吃，但是，不要管不住嘴； 六、代码生成器我们知道mybatis有一个代码生成器MBG，可以生成Java实体类mapper接口和映射文件，但是MybatisPlus却更加强大，可以生成service和controller，可以配置实体类是否支持AR等，代码生成器 说明：建议数据库表名和字段名采用驼峰命名方式，和实体来一致，可以避免在对应实体类产生的性能损耗 6.1.导入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 说明：MybatisPlus默认使用的是velocity模版引 6.2.编写配置类12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void testMbg()&#123; // 1.全局配置 GlobalConfig globalConfig = new GlobalConfig(); globalConfig.setActiveRecord(true)// 是否开启AR模式 .setAuthor(\"luokangyuan\") // 指定作者 .setOutputDir(\"/Users/luokangyuan/Documents/project/mybatisdemo/src/main/java\") .setFileOverride(true) // 指定文件覆盖 .setIdType(IdType.AUTO) // 设置主键自增策略 .setServiceImplName(\"%sService\") // 设置生成的services接口的名字的首字母是否为I .setBaseResultMap(true) // 基本的字段映射 .setBaseColumnList(true); // 基本的sql片段 // 2.配置数据源 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setDbType(DbType.MYSQL) // 设置数据库类型 .setDriverName(\"com.mysql.jdbc.Driver\") .setUrl(\"jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Hongkong\") .setUsername(\"root\") .setPassword(\"jiamei@20141107.\"); // 3.策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true) //全局大写命名 .setDbColumnUnderline(true) // 指定表名和字段名是否使用了下划线 .setNaming(NamingStrategy.underline_to_camel) // 数据库字段下划线转驼峰命令策略 .setTablePrefix(\"tbl_\") // 设置表前缀 .setInclude(\"tbl_dept\",\"tbl_file\"); // 设置需要生成的表 // 4.包名策略配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(\"com.luo\") // 设置父包 .setMapper(\"mapper\") .setService(\"service\") .setController(\"controller\") .setEntity(\"beans\") .setXml(\"mapper\"); // 5. 开始生成代码 AutoGenerator autoGenerator = new AutoGenerator(); autoGenerator.setGlobalConfig(globalConfig) .setDataSource(dataSourceConfig) .setStrategy(strategyConfig) .setPackageInfo(packageConfig); autoGenerator.execute();&#125; 6.3.生成的service代码查看1234@Servicepublic class DeptService extends ServiceImpl&lt;DeptMapper, Dept&gt; implements IDeptService &#123;&#125; DeptService继承了ServiceImpl，在ServiceImpl中就已经注入了DeptMapper，所以，我们就不需要再次注入，在ServiceImpl中也帮我们提供了常用的CRUD方法，我们可以直接使用， 1234567891011@Controller@RequestMapping(\"/dept\")public class DeptController &#123; @Autowired private IDeptService service; public String select()&#123; service.selectList(null); return null; &#125;&#125; 七、插件扩展7.1.注册分页插件1234567891011121314&lt;bean id=\"sqlSessionFactoryBean\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!-- 别名处理 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.luo.beans\"&gt;&lt;/property&gt; &lt;!-- 注入全局MP策略配置 --&gt; &lt;property name=\"globalConfig\" ref=\"globalConfiguration\"&gt;&lt;/property&gt; &lt;property name=\"plugins\"&gt; &lt;list&gt; &lt;bean class=\"com.baomidou.mybatisplus.plugins.PaginationInterceptor\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 真正的分页查询 12345678910111213141516ApplicationContext ioc = new ClassPathXmlApplicationContext(\"applicationContext.xml\");private UserMapper userMapper = ioc.getBean(\"userMapper\",UserMapper.class);@Testpublic void testPage()&#123; Page&lt;User&gt; page = new Page&lt;User&gt;(1,4); List&lt;User&gt; users = userMapper.selectPage(page,null); page.setRecords(users); System.out.print(\"总记录数\"+page.getTotal()); System.out.print(\"当前页码\"+page.getCurrent()); System.out.print(\"总页码\"+page.getPages()); System.out.print(\"每页记录数\"+page.getSize()); System.out.print(\"是否有前一页\"+page.hasPrevious()); System.out.print(\"是否有后一页\"+page.hasNext());&#125; 说明：我们可以将分页查询的数据放在page对象中，返回前端一个page对象即可 7.2.执行分析插件123&lt;bean class=\"com.baomidou.mybatisplus.plugins.SqlExplainInterceptor\"&gt; &lt;property name=\"stopProceed\" value=\"true\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试如下： 1234@Testpublic void testDeltetAll()&#123; userMapper.delete(null);&#125; sql分析插件只支持mysql5.6.3以上的版本，本质就是通过sql分析命令Explain分析当前的sql语句，根据结果集中的Extra列来断定当前是否全表操作； 7.3.性能分析插件性能分析插件用于输出每秒sql语句和其执行时间,首先注册插件，如下： 123&lt;bean class=\"com.baomidou.mybatisplus.plugins.PerformanceInterceptor\"&gt; &lt;property name=\"format\" value=\"true\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试如下： 12345678@Testpublic void testPer()&#123; Dept dept = new Dept(); dept.setDeptName(\"开发部\"); dept.setDeptCount(\"34\"); dept.setDeptBegintime(new Date()); dept.insert();&#125; 结果如下： 12345678Time：142 ms - ID：com.luo.mapper.DeptMapper.insertExecute SQL： INSERT INTO tbl_dept ( dept_count, dept_name, dept_beginTime ) VALUES ( '34', '开发部', '2018-08-26 23:09:17.293' )] 7.4.乐观锁插件当我们在开发中，有时需要判断，当我们更新一条数据库记录时，希望这条记录没有被别人更新，这个时候就可以使用乐观锁插件，他的原理就是，取出记录时，获取当前的version，更新的时候带上这个version，执行更新的时候set version = yourVersion+1 where version = yourVersion,如果version不对，则更新失败，注意的是：@version用于注解实体字段，必须要有； 首先，注册插件 1&lt;bean class=\"com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor\"&gt;&lt;/bean&gt; 实体类添加对应属性,同时数据库表也要添加对应字段 12@Versionprivate Integer version; 测试如下： 12345678@Testpublic void testVersion()&#123; Dept dept = new Dept(); dept.setDeptName(\"测试部\"); dept.setVersion(1); dept.setId(1); dept.updateById();&#125; 如果：这个时候将数据库version改为2，在执行更新就会显示更新记录数为0； 八、自定义全局操作8.1.自定义全局实例自定义全局操作，就是将我们需要的sql在项目启动的时候就注入到全局中，操作步骤如下： 在Mapper接口中定义我们需要注入的方法； 扩展AutoSqlInjector中的inject方法，实现Mapper中我们自定义方法要注入的sql； 最后，在全局配置中，配置我们自定义的注入器即可； 第一步：mapper中定义方法 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123; int deleteAll();&#125; 第二步：重写inject方法 1234567891011121314public class MySqlInjector extends AutoSqlInjector &#123; @Override public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table) &#123; // 构造sql语句 String sql = \"delete from \" + table.getTableName(); // 构造方法名 String method = \"deleteAll\"; // 构造SqlSource对象 SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass); // 构造一个删除的MapperStatement this.addDeleteMappedStatement(mapperClass,method,sqlSource); &#125;&#125;ß 第三步：注入自定义配置 1234567891011&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt; &lt;!--注入自定义全局操作--&gt; &lt;property name=\"sqlInjector\" ref=\"mySqlInjector\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean class=\"com.luo.injector.MySqlInjector\" id=\"mySqlInjector\"&gt;&lt;/bean&gt; 测试 12345678ApplicationContext ioc = new ClassPathXmlApplicationContext(\"applicationContext.xml\");private UserMapper userMapper = ioc.getBean(\"userMapper\",UserMapper.class);@Testpublic void testInject()&#123; int rs = userMapper.deleteAll();&#125; 8.2.逻辑删除所谓逻辑删除，就是不真正的删除数据的记录，而是变为无效状态，在MybatisPlus中，给我们提供logicSqlInjector 第一步：数据库添加逻辑字段 第二步：实体类添加对应属性和注解 12@TableLogicprivate Integer logicFlag; 第三步：MybatisPlus全局配置中加入logicSqlInjector 123456789101112131415&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt; &lt;!--注入自定义全局操作--&gt; &lt;property ref=\"logicSqlInjector\" name=\"sqlInjector\"&gt;&lt;/property&gt; &lt;!--注入逻辑删除全局值--&gt; &lt;property name=\"logicDeleteValue\" value=\"-1\"&gt;&lt;/property&gt; &lt;property name=\"logicNotDeleteValue\" value=\"1\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--逻辑删除--&gt;&lt;bean class=\"com.baomidou.mybatisplus.mapper.LogicSqlInjector\" id=\"logicSqlInjector\"&gt;&lt;/bean&gt; 测试 1234@Testpublic void testLogin()&#123; Integer integer = userMapper.deleteById(1);&#125; 说明：我们做的是删除操作，但是，执行的却是update操作，同时，查询的时候自动添加了有效判断 九、公共字段填充这里涉及到一个元数据处理接口MetaObjectHandler,元对象是Mybatis提供的一个用于更加方便，更加优雅的访问对象的属性，给对象的属性赋值的一个对象，本质上metaObject获取对象的值或者是给对象的属性赋值，都是通过反射获取到属性对应方法的Invoker； 9.1.使用实例第一步：注解需要填充的字段 12@TableField(value = \"user_name\",fill = FieldFill.INSERT_UPDATE)private String userName; 第二步：自定义填充处理器 12345678910111213141516171819202122232425public class MetaHandler extends MetaObjectHandler &#123; /** * 插入操作：自动填充 * @param metaObject */ public void insertFill(MetaObject metaObject) &#123; // 获取到需要被填充的字段值 Object userName = getFieldValByName(\"userName\", metaObject); if(userName == null)&#123; setFieldValByName(\"userName\",\"四川码酱\",metaObject); &#125; &#125; /** * 更新操作：自动填充 * @param metaObject */ public void updateFill(MetaObject metaObject) &#123; // 获取到需要被填充的字段值 Object userName = getFieldValByName(\"userName\", metaObject); if(userName == null)&#123; setFieldValByName(\"userName\",\"康哥哥\",metaObject); &#125; &#125;&#125; 第三步：注入全局配置 123456789101112131415161718&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt; &lt;!--注入自定义全局操作--&gt; &lt;!--&lt;property name=\"sqlInjector\" ref=\"mySqlInjector\"&gt;&lt;/property&gt;--&gt; &lt;property ref=\"logicSqlInjector\" name=\"sqlInjector\"&gt;&lt;/property&gt; &lt;!--注入逻辑删除全局值--&gt; &lt;property name=\"logicDeleteValue\" value=\"-1\"&gt;&lt;/property&gt; &lt;property name=\"logicNotDeleteValue\" value=\"1\"&gt;&lt;/property&gt; &lt;!--注入公共字段填充处理器--&gt; &lt;property name=\"metaObjectHandler\" ref=\"metaHandler\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--自定义公共字段填充处理器--&gt;&lt;bean class=\"com.luo.bandler.MetaHandler\" id=\"metaHandler\"&gt;&lt;/bean&gt; 第四步：测试 1234567@Testpublic void testCom()&#123; User user = new User(); user.setId(11); user.setLogicFlag(1); user.updateById();&#125; 十、IEDA开发插件10.1.安装方法打开IDEA设置–Plugins–Browse repositories –搜索mybatisx,安装即可 10.2.支持的功能根据mapper接口方法自动生成xml文件，接口方法定位xml,xml自动定位mapper接口；","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochenhins.github.io/tags/Mybatis/"}]},{"title":"前端基础知识学习----前端规范ES6","slug":"前端基础知识学习-前端规范ES6","date":"2019-03-21T14:44:14.000Z","updated":"2019-03-21T15:17:15.267Z","comments":true,"path":"2019/03/21/前端基础知识学习-前端规范ES6/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-前端规范ES6/","excerpt":"ES6相关知识学习1. let和const关键字1.1 let关键字作用：与var类似，用于声明一个变量特点 在块作用域内有效，不能重复声明，不会预处理，不存在变量提升应用：循环遍历加监听 123456789101112131415&lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; let name = 'zhangsan'; let btns = document.getElementsByTagName('button'); for(let i = 0; i&lt;btns.length;i++)&#123; let btn = btns[i]; btn.onclick = function()&#123; console.log(i); &#125; &#125; &lt;/script&gt;&lt;/body&gt;","text":"ES6相关知识学习1. let和const关键字1.1 let关键字作用：与var类似，用于声明一个变量特点 在块作用域内有效，不能重复声明，不会预处理，不存在变量提升应用：循环遍历加监听 123456789101112131415&lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; let name = 'zhangsan'; let btns = document.getElementsByTagName('button'); for(let i = 0; i&lt;btns.length;i++)&#123; let btn = btns[i]; btn.onclick = function()&#123; console.log(i); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 1.2 const关键字作用：定义一个常量。特点：不能被修改，其他特点和let一样，用于保存不变的数据。 1const KEY = \"Hello\"; 2. 变量的解构赋值 从对象或数组中提取数据，并赋值给变量（多个）。 对象的解构赋值： let {n,a} = {n:’tom’,a: 12}; 数组的解构赋值： let{a,b} = {1,’zhangsan’}; 变量的解构赋值多用于给多个形参赋值。 123456789101112131415161718192021 &lt;script type=\"text/javascript\"&gt; let obj = &#123;name: 'zhangsan',age: 52&#125;; //let &#123;name&#125; = obj;//对象的结构赋值,只取一个属性值 //console.log(name); let &#123;name,age&#125; = obj;//对象的结构赋值 console.log(name,age); let arr = [1,3,8,'zhangsan',true]; //let [a,b] = arr;//a,b可以随便写，代表获取数组中下标为0和1的值。 let [,,a,b] = arr//代表获取下标为2和3的值 console.log(a,b) //不采用解构赋值 function test1(obj)&#123; console.log(obj.name+\"===&gt;\"+obj.age); &#125; //给多个形参赋值，采用解构赋值 function test2(&#123;name,age&#125;)&#123; console.log(obj.name+\"===&gt;\"+obj.age); &#125; test1(obj); test2(obj);&lt;/script&gt; 3. 模板字符串简化字符串的拼接，模板字符串必须使用包含，注意这个符号不是单引号，是tab键上面的那个键，变化的部分采用${xxx}来定义。 123456789 &lt;script type=\"text/javascript\"&gt; //普通的字符串拼接 let obj = &#123;name: 'zhangsan', age: 56,sex: '男'&#125;; let str = '我的名字是'+obj.name+',性别：'+obj.sex+',我今年'+obj.age+'岁。' console.log(str) //使用模板字符串 let str1 = `我的名字是$&#123;obj.name&#125;,性别：$&#123;obj.sex&#125;,我今年$&#123;obj.age&#125;岁。` console.log(str1);&lt;/script&gt; 4. 对象的简写方式省略同名的属性值，省略方法的function， 1234567891011121314151617181920212223242526 &lt;script type=\"text/javascript\"&gt; //普通的写法，对象中的属性值和属性名称一样 let name = 'zhangsan'; let age = 56; let obj = &#123; name:name, age: age, getName:function()&#123; return this.name; &#125; &#125; console.log(obj); console.log(obj.getName()); //ES6的对象简写方式写法 let username = '张三'; let userage = 56; let obj1 = &#123; username,//同名的属性可以省略不写 userage,//同名的属性可以省略不写 getName()&#123;//可以省略函数的function return this.username; &#125; &#125; console.log(obj1) console.log(obj1.getName());&lt;/script&gt; 5. 箭头函数 箭头函数没有自己的this,箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this。 箭头函数的this看外层是否有函数，如果有，外层函数的this就是内部箭头函数的 this，没有则this是window。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;button id=\"btn1\"&gt;测试按钮1&lt;/button&gt;&lt;button id=\"btn2\"&gt;测试按钮1&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; let test1 = function()&#123; console.log('我是普通函数'); &#125; let test2 = () =&gt; console.log('我是箭头函数') test2(); //形参情况 //1.没有形参的情况下 let test3 = () =&gt; console.log('我是没有形参的箭头函数'); test3(); //2.只有一个形参的情况下,可以省略() let test4 = (a) =&gt; console.log('我是有一个形参的箭头函数'+a); let test5 = a =&gt; console.log('我是有一个形参的箭头函数'+a); test4('zhangsan'); test5('zhangsan'); //3.两个或者两个以上的形参 let test6 = (x,y) =&gt; console.log('我是有两个参数的箭头函数'+x+\"===\"+y); test6(45,85); //函数体的情况 //1.函数体只有一条语句或者表达式的时候，可以省略大括号,会自动返回执行结果。 let test7 = (x,y) =&gt; x+y; console.log(test7(54,54));//打印结果为108 //2.函数体不止一条语句或者函数体的情况，不可以省略大括号 let test8 = (x,y) =&gt;&#123; console.log(x,y); return x+y; &#125; console.log(test8(54,54)); //箭头函数的this,结果为obj let btn1 = document.getElementById('btn1'); let obj = &#123; name:'箭头函数', getName()&#123; btn1.onclick =() =&gt;&#123; console.log(this) &#125; &#125; &#125; obj.getName(); //箭头函数的外面还是箭头函数，this就是window let btn2 = document.getElementById('btn2'); let obj1 = &#123; name:'箭头函数', getName:()=&gt;&#123; btn2.onclick =() =&gt;&#123; console.log(this) &#125; &#125; &#125; obj1.getName();&lt;/script&gt; 6. 三点运算符1234567891011121314151617 &lt;script type=\"text/javascript\"&gt; //...运算符只能放在最后，前面可以使用占位符。 function test (a,...value)&#123; console.log(a)//输出结果为2 console.log(value); value.forEach(function(item,index)&#123; console.log(item,index); &#125;) &#125; test(2,54,87,76) let arr = [1,6]; let arr2 = [2,3,4,5]; arr = [1,...arr2,6]; console.log(arr); console.log(...arr);//直接遍历arr数组，拿到值。&lt;/script&gt; 输出结果为： 7. 形参默认值1234567891011&lt;script type=\"text/javascript\"&gt; //定义一个点的坐标的构造函数 function Point(x = 0,y = 5)&#123;//使用形参默认值 this.x = x; this.y = y; &#125; let point = new Point(23,35); console.log(point); let point1 = new Point();//new一个构造函数的时候，如果没有传参数，就使用形参默认值 console.log(point1);&lt;/script&gt; 输出结果为; 8. promise对象原理Promise对象，代表了未来某个将要发生的事件（通常是一个异步操作）；有了Promise对象。我们可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数，在ES6中，Promise是一个构造函数，用来生成promise实例。 8.1 使用步骤：1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt; //创建promise对象let promise = new Promise((resolve,reject) =&gt;&#123; //初始化promise的状态为pending初始化状态 console.log('1111') //执行异步操作，通常是发送AJAX请求，或者开启定时器 setTimeout(()=&gt;&#123; console.log('3333'); //根据异步任务的返回结果去修改promise的状态 //异步任务执行成功, //通常异步操作得到的数据是在回调函数中操作，就涉及到如何把数据传到回调函数中，使用形参注入的方式 resolve('成功的数据');//自动修改promise的状态为fullfilled状态，就会调用成功的回调函数 //reject();//自动修改promise的状态为reject状态 &#125;,2000)&#125;)console.log('222');promise .then((data)=&gt;&#123;//成功的回调函数 console.log('成功的回调函数被调用！！',data) &#125;,(error)=&gt;&#123;//失败的成功回调函数 console.log('失败的回调函数被调用！！') &#125;)&lt;/script&gt; 8.2 promise的三种状态pending:初始化状态，fullfilled:成功状态，rejected:失败状态 9. Symbol属性 ES6中添加一种原始的数据类型symbol（已经存在的原始数据类型有：string，number，boolean,null,underfined,对象） symbol属性值对应的值是唯一的，解决了命名冲突的问题。 symbol值不能与其他数据进行计算，包括字符串拼接。 for in,for of遍历时不会遍历symbol属性。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 9.1 使用场景：12345678910111213141516 &lt;script type=\"text/javascript\"&gt; //调用Symbol函数得到symbol值 let symbol = Symbol(); let obj = &#123; name:'zhangsan', age: 56 &#125;; obj[symbol] = 'hello world';//在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 console.log(obj); let symbol1 = Symbol('one'); let symbol2 = Symbol('two'); console.log(symbol1 == symbol2);//false console.log(symbol1,symbol2)//肉眼看见是相同的 // 定义常量 const Person_Key = Symbol('person_key');&lt;/script&gt; 10. iterator接口机制首先在JavaScript中，存在数组和对象的数据结构，ES6又增加了map和Set,这四种数据集合，当然还可以彼此使用，例如数组的成员是Map，Map的成员是对象。iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。为各种数据结构提供一种统一的，简单的访问接口。使得数据结构的成员能够按某种次序排列，在ES6中创造一种新的遍历方式for…of循环。 10.1 原理： 创建一个指针对象（遍历器对象），指向数据结构的起始位置。 第一次调用指针对象的next()方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next()方法，指针就指向数据结构的第二个成员。 不断的调用next()方法，直到它指向数据结构的结束位置。 10.2 模拟指针对象123456789101112131415161718//模拟指针对象 function myIterator(arr)&#123; let nextIndex = 0;//记录指针的位置 return&#123;//遍历器对象 nxet: function()&#123; return nextIndex &lt; arr.length ? &#123;vlaue:arr[nextIndex++],done:false&#125;:&#123;value:undefined,done:true&#125; &#125; &#125; &#125; //准备一个数据 let arr = [4,5,58,'hello world']; let iterator = myIterator(arr); console.log(iterator.nxet()); console.log(iterator.nxet()); console.log(iterator.nxet()); console.log(iterator.nxet()); console.log(iterator.nxet()); console.log(iterator.nxet()); 每一次调用next()方法，都会返回数据结构的当前成员信息，具体来说，就是返回一个包含value和done两个属性的对象，其中，value表示当前成员的值，done属性是一个布尔值，遍历遍历是否结束。 一种数据结构只要部署了Iterator接口，我们就称这种数据结构是‘可遍历的（iterable）’。 ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说一个数据结构只要只要有symbol.iterator属性，就可以认为是‘可遍历的’。 symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数，执行这个函数，就会返回一个遍历器 1234567891011121314&lt;script type=\"text/javascript\"&gt; const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125; &#125; &#125; &#125; &#125;&lt;/script&gt; 上述代码中，对象obj是可以遍历的，因为它具有Symbol.iterator属性，执行这个属性，就会返回一个遍历对象，该对象的根本特征就具有next方法，每一次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 在ES6的有些数据结构原声就具备了Iterator接口（比如数组），即不用做任何的处理，就可以被for…of循环遍历，原因就在于这些数据结构原生就已经部署了Symbol.iterator属性，另外一些数据结构（比如对象）就没有部署Symbol.iterator属性，原生具备Iterator接口的数据结构如下： Array Map Set String TypedArray 函数的arguments对象 NodeLise对象 10.3 可以使用for…of的例子1234567891011121314151617 // for...of的使用-数组let arr1 = [5,8,98,'Hello word'];for(let i of arr1)&#123; console.log(i);&#125;// for...of的使用-字符串let str = 'Hello word';for(let i of str)&#123; console.log(i);&#125;// for...of的使用-argumentsfunction test()&#123; for(let i of arguments)&#123;//arguments是一个伪数组，不能使用foreach遍历。 console.log(i); &#125;&#125;test(1,3,5,7,8,'Hello word'); 注意：使用三点运算符，解构赋值，默认会调用Iterator接口。 11. Generator函数 Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不一样。 Generator函数可以理解为一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了一个状态机，还是一个遍历器生成函数。返回的遍历器对象可以一次遍历Generator函数内部的每一个状态。 形式上，Generator函数就是一个普通的函数，有两个特征，其一是：function关键字与函数名之间有一个星号，其二是：函数体内部使用yield表达式，定义不同的内部状态。 12345678function* myGenerator() &#123; yield 'a'; yield 'b'; yield 'c'; return 'ending'; &#125; let gen = myGenerator(); 上述代码就定义了一个Generator函数myGenerator，在他的内部就有三个yield表达式，即函数就存在三个状态，但是，当我门调用函数的时候，函数并不会执行，返回的也不是函数的运行结果，而是一个指向内部状态的指针对象，也叫遍历器对象（iterator object）。下一步就是调用遍历器的next方法，是的指针下移一个状态，也就是说，每一次的调用next方法，就遍历一个状态， 123456789101112131415&lt;script type=\"text/javascript\"&gt; function* myGenerator() &#123; yield 'a'; yield 'b'; yield 'c'; return 'ending'; &#125; let gen = myGenerator(); console.log(gen.next());// &#123;value: \"a\", done: false&#125; console.log(gen.next());// &#123;value: \"b\", done: false&#125; console.log(gen.next());// &#123;value: \"c\", done: false&#125; console.log(gen.next());// &#123;value: \"ending\", done: true&#125; console.log(gen.next());// &#123;value: undefined, done: true&#125;&lt;/script&gt; 11.1 总结：调用Generator函数返回遍历器对象，代表Generator函数的内部指针，以后每次调用遍历器对象的next方法，就会返回一个有着value和done属性的对象。value属性表示当前的内部状态值，是yield表达式后面的那个表达式的值。done属性是一个布尔值，表示是否遍历结束。 11.2 yield表达式由于Generator函数返回的是一个遍历器对象，只有调用next方法才会遍历下一个内部状态，所以它其实提供的就是一种可以暂停执行的函数，yield表达式就是暂停的标志。遍历器对象的next方法的运行逻辑如下： 遇到yield表达式，就暂停执行后面的操作，并将紧跟在后面yield后面的那个表达式的值，作为返回对象的value的属性值。 下一次调用next的方法时，再继续往下执行，直到遇到一个yield表达式。 如果没有遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回对象的value的属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是：yield表达式后面的表达式，只有当调用next方法，内部指针指向该语句才会执行。 12345678910function* myGenerator1()&#123; yield 5+5; yield 5*5; return 5*5+5*5;&#125;let gen1 = myGenerator1();console.log(gen1.next());console.log(gen1.next());console.log(gen1.next());console.log(gen1.next()); 如果Generator函数不使用yield表达式，就变成了一个单纯的暂缓执行函数。 12345function* test()&#123; console.log(\"我被执行了！！\");&#125;let gen3 = test()gen3.next(); 上述代码中test函数就是一个普通的函数，但它是一个Generator函数，就变成了只有调用next方法，才会执行text函数。 yield表达式只有在Generator函数中使用，其他地方使用就会报错。如果，yield表达式使用在另一个表达式中，就必须放在圆括号里面，如下所示 12345678function* demo()&#123; console.log('hello==&gt;'+(yield)); console.log('hello=&gt;='+(yield 123));&#125;let gendemo = demo();console.log(gendemo.next());console.log(gendemo.next());console.log(gendemo.next()); 11.3 next方法的参数yield表达式本身没有返回值，或者说总是返回undefined，next方法可以带一个参数，该参数就会被当成上一个yield表达式的返回值。 123456789function* foo(x)&#123; let y = 2* (yield (x+1)); let z = yield (y / 3); return (x + y + z);&#125;let g = foo(5);console.log('输入结果为1：',g.next());// 输入结果为： &#123;value: 6, done: false&#125;console.log('输入结果为2：',g.next(12));// 输入结果为： &#123;value: 8, done: false&#125;console.log('输入结果为3：',g.next(13));// 输入结果为： &#123;value: 42, done: true&#125; 上述代码中，第一次调用next方法，返回x+1的值6，第二次调用调用next方法，next方法中传入参数为12，就说上一次yield表达式的值为12，因此y等于24，返回的是y / 3的值8，第三次调用next方法，传入参数13，因此 z 等于13，这个时候x等于5，y等于24，z等于13，返回42。 11.4 for of遍历Generator函数下面是一个利用 Generator 函数和for…of循环，实现斐波那契数列的例子。 1234567891011function* fibonacci()&#123; let [prev,curr] = [0,1]; for(;;)&#123; [prev,curr] = [curr,prev+curr]; yield curr; &#125; &#125; for(let n of fibonacci())&#123; if(n &gt; 1000) break; console.log(n); &#125; 11.5 Generator函数的小练习12345678910111213// 需求就是先一部发送发送1号请求，根据1号请求返回的数据中的comurl值作为2号请求的urlfunction getDept(url)&#123; $.get(url,function(data)&#123; let url = \"http://localhost:3000\"+data.comurl; sx.next(url); &#125;)&#125;function* show()&#123; let url = yield getDept('http://localhost:3300/dept?id=3'); yield getDept(url)&#125;let sx = show();sx.next();//1 分析：执行到1语句的时候，就会调用show方法中的第一个yield，然后执行getDept方法，在将返回的url做为next的参数，在调用show方法中的第二个yield，再执行getDept方法，发送第二次请求。 1234567891011121314// 需求就是先一部发送发送1号请求，根据1号请求返回的数据中的comurl值作为2号请求的urlfunction getDept(url)&#123; $.get(url,function(data)&#123; console.log(data);// 请求后返回的数据 let url = \"http://localhost:3000\"+data.comurl; sx.next(url); &#125;)&#125;function* show()&#123; let url = yield getDept('http://localhost:3300/dept?id=3'); yield getDept(url)&#125;let sx = show();sx.next(); 11.6 遍历对象调用return方法，遍历对象调用return方法后，返回的值的value就是return方法的参数值，并且 Generator函数的遍历就终止了，返回的done的值为true。以后调用next方法，done的属性值就一直是true，例如 123456789101112function* hello()&#123; yield '1' yield '2' yield '3' yield '4' yield '5' &#125; let bubu = hello(); console.log(bubu.next()) ;//&#123;value: \"1\", done: false&#125; console.log(bubu.next()) ; // &#123;value: \"2\", done: false&#125; console.log(bubu.return(\"Hello word！！\"));// &#123;value: \"Hello word！！\", done: true&#125; console.log(bubu.next()) ;// &#123;value: undefined, done: true&#125; 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 11.7 yield*表达式123456789101112function* foo()&#123; yield 'a' yield 'b' &#125; function* bar()&#123; yield 'x' foo(); yield 'y' &#125; for(let v of bar())&#123; console.log(v);// x y &#125; 上述代码存在Generator函数中调用Generator函数，总输出结果我们可以看出是不会有效果的，这个时候就需要使用yield*表达式，如下 123456789101112131415161718192021222324252627function* foo()&#123; yield 'a' yield 'b'&#125;function* bar()&#123; yield 'x' yield* foo(); yield 'y'&#125;//等同于function* bar()&#123; yield 'x' yield 'a' yield 'b' yield 'y'&#125;//等同于function* bar()&#123; yield 'x' for(let v of foo())&#123; yield v; &#125; yield y&#125;for(let v of bar())&#123; console.log(v)&#125; 12. class的基本语法12345678910111213141516class Point &#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return '===&gt;('+this.x+','+this.y+')'; &#125; show()&#123; console.log(\"我是show方法，\") &#125; &#125; let point = new Point(5,8); console.log(point); point.show();//与下面的调用方法一样 Point.prototype.show();//调用原型上的方法，使用类名 上述代码中，定义了一个类，可以看到里面有一个构造方法，其中this关键字就表示实例对象，除了一个构造方法外，还有一个toString方法，注意，定义‘类’的方法的时候，不需要加上function关键字，直接将函数定义放进去就可以，另外，方法之间也不需要逗号隔开。使用的时候，采用new命令。和构造函数的用法一样。 由于类的方法都是定义在原型prototype对象上，所以类的新方法可以添加在prototype对象上面，Object.assign方法可以很方便的一次向类中添加多个方法。 12345678910111213141516171819202122class Point1&#123; constructor(x,y,z)&#123; this.x = x; this.y = y; this.z = z; &#125; &#125; Object.assign(Point1.prototype,&#123; toString()&#123; console.log('我是x坐标==&gt;',this.x); &#125;, toValue()&#123; console.log('我是y坐标==&gt;',this.y); &#125;, toShow()&#123; console.log('我是z坐标==&gt;',this.z); &#125; &#125;) let po = new Point1(5,8,7); po.toString(); po.toValue(); po.toShow(); 在ES6的严格模式下：constructor方法是类的默认方法，通过new命令生成对象实例，自动调用该方法，一个类就必须有constructor方法，如果没有显示定义，一个空的constructor方法就会被默认添加。类必须通过new调用。否则就会报错。 12.1 class表达式与函数一样，类可以使用表达式的形式定义 123456789const MyClass = class Me&#123; constructor()&#123; &#125; getClassName()&#123; console.log(Me.name) &#125; &#125; new MyClass().getClassName(); 上述代码就是使用表达式定义了一个类，需要注意的是，这个类的名字是MyClass,而不是Me,Me只在class内部代码可用，指向当前类。 12.2 this指向类的方法内部如果含有this，它默认指向类的实例，但是，一旦单独使用，就很可能会报错。 1234567891011class Logger &#123; printName(name = 'three')&#123; this.print(`hello $&#123;name&#125;`); &#125; print (text)&#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123;printName&#125; = logger;printName(); 上述代码中，printName方法中的this,默认指向的是Logger类的实例，但是，如果将这个方法提取出来再外部使用的话，this就会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 解决办法之一：构造方法中绑定this 1234567891011121314class Logger &#123; constructor()&#123; this.printName = this.printName.bind(this) &#125; printName(name = 'three')&#123; this.print(`hello $&#123;name&#125;`); &#125; print (text)&#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123;printName&#125; = logger;printName(); 解决办法之二:使用箭头函数 12345678910111213 class Logger &#123; constructor()&#123; this.printName = (name='three')=&gt;&#123; this.print(`Hello $&#123;name&#125;`); &#125; &#125; print (text)&#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123;printName&#125; = logger;printName(); 12.3 name属性每一个类都具有name属性，name属性总是返回紧跟在class关键字后面的类名 12class Beauty&#123;&#125;console.log(Beauty.name); 12.4 Class的静态方法在一个类中定义的方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来直接调用，这个方法就叫静态方法。 1234567 class Foo&#123; static getName()&#123; return 'Hello world' &#125;&#125;let dtr = Foo.getName();console.log(dtr) 注意：如果静态方法包含this关键字，这个this指向的是类，而不是类的实例。 1234567891011121314 class Foo&#123; static getName()&#123; let age = this.getAge(); return `Hello World,你的年龄是：$&#123;age&#125;`; &#125; static getAge()&#123; return 15; &#125; getAge()&#123; return 155; &#125;&#125;let dtr = Foo.getName();console.log(dtr)// Hello World,你的年龄是：15 从上述代码可以看出。静态方法getName中调用了this.getAge(),这里的this指的是Foo类，而不是Foo的实例。等同于调用了Foo.getAge(), 还可以看出静态方法和非静态方法可以重名。 父类的静态方法，可以被子类继承。 123class Sun extends Foo&#123;&#125;let sunstr = Sun.getName();console.log(sunstr);// Hello World,你的年龄是：15 静态方法也是可以从supper对象上调用的。 1234567891011 class Fa&#123; static printStr()&#123; return 'Hello' &#125;&#125;class Son extends Fa&#123; static print()&#123; return `$&#123;super.printStr()&#125;,world` &#125;&#125;console.log(Son.print());// Hello,world 13. class的继承13.1 简介class可以通过extends关键字实现继承。 1234567891011class Point&#123;&#125;class ColorPoint extends Point&#123; constructor(x,y,color)&#123; super(x,y); this.color = color; &#125; toString()&#123; return `$&#123;this.color&#125;:$&#123;super.toString()&#125;` &#125;&#125;let cp = new ColorPoint(4,5,85) 注意的是：子类必须再constructor方法中调用super方法，否则砸新建实例的时候就会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，如果不调用super方法，子类就得不到this对象。 13.2 Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上来获取父类，由此判定一个类是否继承了另一个类。 12let isExtends = Object.getPrototypeOf(ColorPoint);console.log(isExtends); 14. Set和Map数组14.1 Set基本用法ES6几桶了一种新的数据结构Set，他类似数组，但是成员的值都是唯一的，没有重复的值，Set本身是一个构造函数，用来生成Set数据结构。 12345const s = new Set();[2,3,4,5,5,2,1].forEach(x =&gt; s.add(x));for(let i of s)&#123; console.log(i);// 2 3 4 5 1&#125; 上述代码就可以看出通过add方法向Set结构中加入成员，结果表明Set结构不会添加重复的值。Set函数可以接受一个数组（或者具有iterable接口的其他数据 结构）作为参数 ，用来初始化 12345const set = new Set([1,2,3,4,4]);console.log([...set]);// (4) [1, 2, 3, 4]const items = new Set([1,2,1,1,5,5,5,5,]);console.log(items.size);// 3 上述代码也说明了一种去除数组重复成员的方法1[...new Set(array)] 向Set加入值的时候，不会发生类型转换，也就是说，a和’a’是两个不同的值。另外，对象总是不相等的， 123456789101112let obj = &#123;&#125;;let objSet = new Set();objSet.add(obj);console.log(objSet.size);// 1objSet.add(obj);console.log(objSet.size);// 1let objSet1 = new Set();objSet1.add(&#123;&#125;);console.log(objSet1.size)// 1objSet1.add(&#123;&#125;);console.log(objSet1.size)// 2 上述代码说明两个空对象是不相等的，如果传入同一个new出来的对象实例，那么就会被视为相同。 Set实例的属性和方法Set结构的实例有以下属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set的实例的成员总数。 Set实例的方法分为操作方法（用于操作数据）和遍历方法（用于遍历成员） add(value)：添加某一个值，返回Set结构本身。 delete(value)：删除某一个值，返回一个布尔值，表示是否删除成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 12345let setMethod = new Set();setMethod.add(1).add(2).add(2);// 2被添加了两次，console.log(setMethod.size);// 2console.log(setMethod.has(2));// trueconsole.log(setMethod.delete(2));// true Array.from方法可以将Set结构转为数组123const itemsSet = new Set([1,2,3,4,5]);const arry = Array.from(itemsSet);console.log(arry);// (5) [1, 2, 3, 4, 5] 数组去重的一种方法1234 function dedupe (array)&#123; return Array.from(new Set(array));&#125;dedupe([1,2,1,2,1,3,1,5,1]); 遍历操作Set结构的实例有四个遍历方法，用于遍历成员 key()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每一个成员 说明：Set的遍历顺序就是插入顺序。 1234567891011let setTest = new Set(['张三','李思思','刘亦菲']); for(let iten of setTest.keys())&#123; console.log(iten);// 张三 李思思 刘亦菲&#125;for(let iten of setTest.values())&#123; console.log(iten);// 张三 李思思 刘亦菲&#125;for(let iten of setTest.entries())&#123; console.log(iten)// [\"张三\", \"张三\"] [\"李思思\", \"李思思\"] [\"刘亦菲\", \"刘亦菲\"]&#125; 由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法一样。Set结构的实例默认可以遍历，他的默认遍历器函数就是他的values方法，意味着遍历时可以省略values()方法。 1234let setSim = new Set(['red','green','blue']);for(let x of setSim)&#123; console.log(x);&#125; forEach()Set结构和数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 1setSim.forEach((value,key)=&gt;console.log(key,value)) 遍历的应用扩展运算符（…）内部使用for of 循环，所以也可以用于Set结构 12let arr = [...setSim];console.log(arr); 扩展运算符和Set结合就可以去除数组中的重复成员 123let setArr = [3,54,1,5,4,1,5,4,8];let unique = [...new Set(setArr)];console.log(unique);// [3, 54, 1, 5, 4, 8] 而且数组的map和filter方法也可以间接用于Set。 1234567let setMap = new Set([1,2,3]);setMap = new Set([...setMap].map(x =&gt; x*2));console.log(setMap); // Set(3) &#123;2, 4, 6&#125;let setFilter = new Set([1,2,3,4,5,6]);setFilter = new Set([...setFilter].filter(x =&gt;(x % 2)==0));console.log(setFilter);// Set(3) &#123;2, 4, 6&#125; 因此，可以使用Set可以很容易的实现并集，交集和差集。 1234567891011let a = new Set([1,2,3]);let b = new Set([4,3,2]);//并集let union = new Set([...a,...b]);console.log(union);// Set(4) &#123;1, 2, 3, 4&#125;//交集let intersect = new Set([...a].filter(x =&gt;b.has(x)));console.log(intersect);// Set(2) &#123;2, 3&#125;//差集,a对b的差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));console.log(difference);// Set(1) &#123;1&#125; WeakSetWeakSet结构与Set类似，也是不重复的值的集合，但是，它与Set的不同之处在于WeakSet的成员只能是对象，而不能是其他类型的值。 14.2 Map含义和基本用法JavaScript的对象（Object），本质上市键值对的集合（Hash结构），但是传统上只能用于字符串当键，这给他的使用带来限制。因此在ES6中，提出了Map的数据结构，他类似对象。也是键值对的集合。但是，键的范围不限制与字符串，各种类型的值（包括对象）都可以当做键，也就是说，Object结构提供了‘字符串-值’的对应，Map提供了‘值-值’的对应。 123456const m = new Map();const obj = &#123;word:'Hello word'&#125;;m.set(obj,'content');console.log(m.get(obj));// contentconsole.log(m.has(obj));// trueconsole.log(m.delete(obj));// true 上述代码使用了Map结构的set方法，将对象obj作为m的一个键，然后使用get方法读取obj键的值，使用has方法判断是否灿在obj这个键，使用delete删除obj这个键。展示了如何向一个Map中添加成员，作为构造函数，Map也接受一个数组作为参数，该数组的成员是一个表示键值对的数组。 123456789const map = new Map([ ['name','zhangsan'], ['title','Author']]);console.log(map.size);// 2console.log(map.has('name'));// trueconsole.log(map.get('name'));// zhangsanconsole.log(map.has('title'));// trueconsole.log(map.get('title'));// Author 上面代码在新建Map实例时，就指定了两个键name和title。如果对同一个键进行多次赋值，后面的值将会覆盖前面的值。 1234const mapTest = new Map();mapTest.set(1,'A');mapTest.set(1,'B');console.log(mapTest.get(1));// B 注意：只有对同一个对象的引用，Map结构才将其视为同一个键。 123const unmap = new Map();unmap.set(['a'],111);console.log(unmap.get(['a']));// undefined 上述代码的set和get方法，表面是针对同一个键，但实际上是这两个值的内存地址不一样，因此get方法无法取到该键。同理，同样的值的两个实例，在Map结构中被视为两个键。 1234567const map1 = new Map();const k1 = ['a'];const k2 = ['a'];map1.set(k1,111);map1.set(k2,222);console.log(map1.get(k1));// 111console.log(map1.get(k2));// 222 上述代码中变量k1和k2的值是一样的，但是在Map中他们是两个不同的键。由此可知， Map的键实际和内存地址绑定的，只要内存地址不一样，就视为两个键。 如果Map的键是一个简单类型的值（数字，字符串，布尔值），则只要这两个值严格相等，Map将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true就是两个不同的键， 另外，undefined和null也是两个不同的键， 1234567891011let map2 = new Map();map2.set(-0,123);console.log(map2.get(+0));// 123map2.set(true,1);map2.set('true',2);console.log(map2.get(true));// 1console.log(map2.get('true'));// 2map2.set(undefined,3);map2.set(null,4);console.log(map2.get(undefined));// 3console.log(map2.get(null));// 4 实例的属性和操作方法 size属性：返回map结构的成员总数。 set(key,value)：设置键名和对应的键值，然后返回整个Map结构，如果key已经存在值，则键值将会更新，否则生成新的键。由于set方法返回的是当前map对象，所以可以采用链式写法。 get(key)：读取对应key的值，如果找不到key，就返回undefined。 has(key)：返回一个布尔值，表示某一个键是否存在当前的Map对象中。 delete(key)：删除一个键，返回删除结果，成功返回true，否则，返回false。 clear()：清除所有成员，没有返回值 遍历方法Map结构原生提供了三个遍历器生成函数和一个遍历方法 keys()：返回所有的键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员 需要注意的是：map的遍历顺序就是插入顺序。 12345678910111213141516 const map3 = new Map([ ['F','no'], ['T','yes']]);for(let x of map3.keys())&#123; console.log(x);// F T&#125;for(let x of map3.values())&#123; console.log(x);// no yes&#125;for(let x of map3.entries())&#123; console.log(x[0],x[1]);// F no T yes&#125;for(let[key,value] of map3.entries())&#123; console.log(key,value);// F no T yes&#125; map结构转为数组结构，比较快速的办法就是使用扩展运算符（…） 123456789const map4 = new Map([ [1,'one'], [2,'two'], [3,'three']]);console.log([...map4.keys()]);// [1, 2, 3]console.log([...map4.values()]);// [\"one\", \"two\", \"three\"]console.log([...map4.entries()]);// [Array(2), Array(2), Array(2)]console.log([...map4]);// [Array(2), Array(2), Array(2)] 结合数组的map方法，filter方法，可以实现Map的遍历和过滤，（Map本身并没有map和filter方法） 12345678910const map5 = new Map();map5.set(1,'a');map5.set(2,'b');map5.set(3,'c');const mapfilter = new Map([...map5].filter(([k,v]) =&gt; k &lt;3));console.log(mapfilter);// Map(2) &#123;1 =&gt; \"a\", 2 =&gt; \"b\"&#125;const mapMethod = new Map( [...map5].map(([k,v]) =&gt; [k*2,`Hello $&#123;v&#125;`]))console.log(mapMethod);// Map(3) &#123;2 =&gt; \"Hello a\", 4 =&gt; \"Hello b\", 6 =&gt; \"Hello c\"&#125; 此外，map还有一个forEach方法，与数组类似，实现遍历。 12map5.forEach((v,k,m)=&gt;console.log(`key:$&#123;k&#125;,value:$&#123;v&#125;`));// key:1,value:a key:2,value:b key:3,value:c 与其他数据结构互相转换 Map转数组：使用扩展运算符 数组转Map：将数组传入Map构造函数中，就可以转为Map Map转对象：如果所有的Map的键都是字符串，他就可以转为对象 1234567891011function maptoObject(map) &#123; let obj = Object.create(null); for(let [k,v] of map)&#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map();myMap.set('yes',true);myMap.set('no',false);console.log(maptoObject(myMap)); 对象转Map 123456789function objtoMap(obj)&#123; let map = new Map(); for(let k of Object.keys(obj))&#123; map.set(k,obj[k]); &#125; return map; &#125; let obj1 = &#123;yes:true,no:false&#125;; console.log(objtoMap(obj1));// Map(2) &#123;\"yes\" =&gt; true, \"no\" =&gt; false&#125; Map转为JSON Map转为JSON要区分两种情况，一种情况是：Map的键名都是字符串，这时可以选择转为对象JSON。先将Map转为对象，在将对象转为JSON 123456789101112function maptoObject(map) &#123; let obj = Object.create(null); for(let [k,v] of map)&#123; obj[k] = v; &#125; return obj;&#125;function maptoJson(map)&#123; return JSON.stringify(maptoObject(map))&#125;let mapJson = new Map().set('yes',true).set('no',false);console.log(maptoJson(mapJson));// &#123;\"yes\":true,\"no\":false&#125; 还有一种情况就是：Map的键有非字符串，这时候可以选择转为数组JSON 12345 function maptoArrJson(map)&#123; return JSON.stringify([...map]);&#125;let arrmap = new Map().set(true,7).set(&#123;foo:2&#125;,'abc');console.log(maptoArrJson(arrmap));// [[true,7],[&#123;\"foo\":2&#125;,\"abc\"]] 15 数组的扩展15.1 扩展运算符扩展运算符在前面也已经介绍过了，也叫三点运算符，将一个数组转为用逗号分隔的参数序列。 1console.log(...[1,2,3]); 替代函数的apply方法由于扩展运算符可以展开数组，所以就不需要apply方法， 1234567891011//ES5的写法function f(x,y,z)&#123; console.log(x,y,z);// 0 1 2&#125;;var args = [0,1,2];f.apply(null,args);// ES6的写法function fes6(x,y,z) &#123; console.log(x,y,z);&#125;fes6(...args);// 0 1 2 运用扩展运算符实现的一个小例子，求一个数组中最大的元素 1234// ES5的写法var max1 = Math.max.apply(null,[14,85,95]);console.log(max1);//ES6的写法 let max2 = Math.max(…[14,85,95]); console.log(max2);使用push方法，将一个数组添加到另一个数组的尾部 12345678910//ES5的写法var arr1 = [0,1,2];var arr2 = [3,4,5];Array.prototype.push.apply(arr1,arr2);console.log(arr1);// [0, 1, 2, 3, 4, 5]//ES6的写法let arr3 = [0,1,2];let arr4 = [3,4,5];arr3.push(...arr4);console.log(arr3);// [0, 1, 2, 3, 4, 5] 扩展运算符的应用复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆了一个全新的数组。1234const a1 = [1,2]; const a2 = a1; a2[0] = 3; console.log(a1[0]);// 3 上述代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针，修改a2，回直接导致a1的变化， 123const a3 = [1,2];const a4 = [...a3];const [...a5] = a3; 使用扩展运算符，就可以很方便的实现数组的克隆，这个时候你修改a4或者a5的值，不会影响a3的值。 合并数组使用扩展运算符可以很方便的实现数组的合并 12345678//ES5的写法var array1 = [1,2];var array2 = [3,4];var array3 = [5,6];console.log(array1.concat(array2));// [1, 2, 3, 4]console.log(array1.concat(array2,array3));// [1, 2, 3, 4, 5, 6]//ES6的写法console.log([...array1,...array2,...array3]);// [1, 2, 3, 4, 5, 6] 与解构赋值结合扩展运算符与解构赋值相结合，可以生成数组 123const [first,...end] = [1,2,3,4,5];console.log(first);// 1console.log(end);// [2, 3, 4, 5] 如果将扩展运算符用于数组赋值，只能放在参数的末尾，否则就会报错。 1const [...test,last] = [1,2,3,4,5];// 报错 扩展运算符将字符串转为真正的数组[...&apos;hello&apos;] 总结：扩展运算符内部调用的是数据结构的Iterator接口，因此只有具有Iterator接口的对象，才能使用扩展运算符，否则就不能使用。 Array.from()Array.from()方法可以将两类对象转为真正的数组 1234567let arrayLike = &#123; '0':'A', '1':'B', '2':'C', length:3&#125;console.log(Array.from(arrayLike));// [\"A\", \"B\", \"C\"] Array.of()Array.of方法用于将一组值，转换为数组，是为了弥补Array构造函数的不足 123console.log(Array());// []console.log(Array(3));// [empty × 3],length:3console.log(Array(4,8,5));// [4, 8, 5] 上述代码中Array的参数个数有差异，说明只有参数个数大于1才能生成新的数组，of方法就是解决这个问题的。 123console.log(Array.of(3));// [3]console.log(Array.of(3,5,8));// [3, 5, 8]console.log(Array.of(8).length);// 1 Array.of()方法基本可以代替Array()或者new Array(),该方法总是返回一个新的数组，如果没有参数就会返回一个空的数组。 数组实例copyWithin()数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组，也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target,start = 0,end = this.length) 该方法的参数说明 target(必须)：从该位置开始替换数据，如果为负值，表示倒数。 start(可选)：从该位置开始读取数据，默认为0，如果为负值，表示倒数。 end(可选)：到该位置前停止读取数据，默认是数组的长度，如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 12let carr = [4,8,6,7,9,2].copyWithin(0,3);console.log(carr);// [7, 9, 2, 7, 9, 2] 上述代码表示：从3号为位开始复制，替换0位以后的数据。 数组实例的find()方法和findIndex()方法数组实例的find方法用于找到第一个符合条件的数组的成员，它的参数是一个回调函数，所有的数组成员都将依次执行这个函数 12345[8,4,5,7,101].find((n) =&gt; n &gt;100);let arrnew = [4,8,6,85,101].find(function(v,i,a)&#123; return v &gt; 100; &#125;); 数组实例的fill()fill方法使用给定值，填充一个数组。12let farr = ['a','b','c'].fill(7);console.log(farr);// [7, 7, 7] fill方法用于空数组的初始化就很方便，该方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 数组实例的include()方法该方法返回一个布尔值，表示每一个数组是否包含给定的值，与字符串的include方法类似，该方法的第二个参数表示搜索的起始位置。如果为负数，表示倒数。 ES6的相关知识就学习结束了，感谢阮一峰出版的《ECMAScript 6 入门》书籍。值得购买，作为前端人们书籍还是不错的。","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://caochenhins.github.io/tags/es6/"}]},{"title":"前端基础知识学习---Vue核心知识学习总结","slug":"前端基础知识学习-Vue核心知识学习总结","date":"2019-03-21T14:43:50.000Z","updated":"2019-03-21T15:18:22.498Z","comments":true,"path":"2019/03/21/前端基础知识学习-Vue核心知识学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-Vue核心知识学习总结/","excerpt":"一、Vue核心知识1.1.Vue的基本简介学习一门技术首先登陆其官网，中文网址，英文网址，vue是一款渐进式JavaScript框架，作用是为了动态构建用户界面，该框架遵循MVVM模式，编码简洁，体积小，运行效率高；他借鉴了angular的模板和数据绑定技术，借鉴了react的组件化和虚拟DOM技术，当然，该技术也存在一个Vue全家桶，例如vue脚手架：vue-cli，ajax请求：vue-resource，路由：vue-router，状态管理：vuex，图片懒加载：vue-lazyload，移动端UI组件库：min-ui，PC端组件库：element-ui，页面滑动：vue-scroller等等插件；","text":"一、Vue核心知识1.1.Vue的基本简介学习一门技术首先登陆其官网，中文网址，英文网址，vue是一款渐进式JavaScript框架，作用是为了动态构建用户界面，该框架遵循MVVM模式，编码简洁，体积小，运行效率高；他借鉴了angular的模板和数据绑定技术，借鉴了react的组件化和虚拟DOM技术，当然，该技术也存在一个Vue全家桶，例如vue脚手架：vue-cli，ajax请求：vue-resource，路由：vue-router，状态管理：vuex，图片懒加载：vue-lazyload，移动端UI组件库：min-ui，PC端组件库：element-ui，页面滑动：vue-scroller等等插件； 1.2.Vue的基本使用1234567891011121314&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"username\"&gt; &lt;p&gt;Hello &#123;[username]&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 const vm = new Vue(&#123; // 配置对象 el:'#app', // element:选择器 data:&#123; //数据（Model） username:'世界' &#125; &#125;)&lt;/script&gt; vue的HelloWord编码说明 使用vue首先引入Vue.js，然后创建Vue对象，其中el表示指定的根element选择器，data是指初始化数据，双向数据绑定使用v-model，显示数据使用语法：{[xxx]}； vue的MVVM的体现就是：model代表模型，上述代码就是数据对象（data）,view代表视图，就是vue中的模板页面，viewModel代表是视图模型（vue实例）； 1.3.模板语法所谓的模板就是动态的Html页面，包含了一些JS语法代码，在Vue中使用双大括号表达式和指令（以v-开头的自定义标签属性）； 双大括号表达式 语法是：{[xxx]}，作用就是向页面输出数据，可以调用对象的方法，例如{[msg.toUpperCase()]}； 指令：强制数据绑定 1234567891011121314151617&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;[msg]&#125;&lt;/p&gt; &lt;p&gt;&#123;[msg.toUpperCase()]&#125;&lt;/p&gt; &lt;img src=\"imgSrc\" alt=\"\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; msg: 'Hello Word', imgSrc: 'http://image.luokangyuan.com/1.jpg' &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 上述代码中的img标签的src属性不会获取到data中定义的imgSrc属性的值，这个时候就需要使用指令强制数据绑定，功能就是指定变化的属性值，完整写法是：v-bind:src=&#39;imgSrc&#39;，一般采用简洁写法：:src=&#39;imgSrc&#39;；正确写法如下： 1&lt;img :src=\"imgSrc\" alt=\"\"&gt; 指令：绑定事件监听 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click = 'test1'&gt;test1&lt;/button&gt; &lt;button v-on:click = 'test2(msg)'&gt;test2&lt;/button&gt; &lt;button @click = 'test'&gt;test&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; msg: 'Hello Word', imgSrc: 'http://image.luokangyuan.com/1.jpg' &#125;, methods: &#123; test1() &#123; alert(123) &#125;, test2(content) &#123; alert(content) &#125;, test() &#123; alert(123) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 绑定事件监听指令的作用就是绑定指定事件名的回调函数，完整写法：v-on:click=&#39;xxx&#39;或者v-on:click=&#39;xxx(参数)&#39;再或者v-on:click.enter=&#39;xxx&#39;，简洁写法就是：@click=&#39;xxx&#39;，使用@符号； 1.4.计算属性和监视计算属性 在computed属性对象中定义计算属性的方法，在页面中使用{[方法名]}来显示计算的结果； 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=\"app\"&gt; 姓：&lt;input type=\"text\" placeholder=\"姓氏\" v-model=\"firstName\"&gt;&lt;br&gt; 名：&lt;input type=\"text\" placeholder=\"名字\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名1（单向）：&lt;input type=\"text\" placeholder=\"姓名1\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名2（单向）：&lt;input type=\"text\" placeholder=\"姓名2\"&gt;&lt;br&gt; 姓名3（双向）&lt;input type=\"text\" placeholder=\"姓名3双向\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; firstName: 'A', lastName: 'B' //如果将 fullName1写在这个地方，那么改变firstName和lastName的值并不会同时改变fullName1的值 // 所以需要使用到计算属性，将fullName1写入computed属性对象中，将方法的返回值作为输出值 // fullName1：'A B' &#125;, computed: &#123; // 这个f方法在初始化会执行，当相关属性发生改变时也会执行 fullName1() &#123; // 计算属性中的一个方法，方法的返回值作为属性值 return this.firstName + ' ' + this.lastName &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 计算属性的get和set 使用计算属性实现上述的双向绑定，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=\"app\"&gt; 姓：&lt;input type=\"text\" placeholder=\"姓氏\" v-model=\"firstName\"&gt;&lt;br&gt; 名：&lt;input type=\"text\" placeholder=\"名字\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名3（双向）&lt;input type=\"text\" placeholder=\"姓名3双向\" v-model=\"fullName3\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; firstName: 'A', lastName: 'B' // fullName1：'A B' &#125;, computed: &#123; fullName3: &#123; // 回调函数：你定义的，你没有调用，但最终他执行了 // 回调函数，当需要读取当前属性值时回调，根据相关的数据计算并返回当前属性的值 get()&#123; return this.firstName + ' ' + this.lastName &#125;, // 回调函数，监视当前属性的变化，当属性值发生改变时回调，更新相关的属性数据 set(value)&#123; const names = value.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 注意：计算属性存在缓存，多次读取只执行一次getter计算； 监视 通过vm对象的$watch()方法或者watch配置来监视某一个属性的值是否发生变化，当属性发生变化时，通过执行回调函数来执行相关的功能，下面的代码是使用计算属性完成的同一个功能， 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id=\"app\"&gt; 姓：&lt;input type=\"text\" placeholder=\"姓氏\" v-model=\"firstName\"&gt;&lt;br&gt; 名：&lt;input type=\"text\" placeholder=\"名字\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名2（单向）：&lt;input type=\"text\" placeholder=\"姓名2\" v-model=\"fullName2\"&gt;&lt;br&gt; 姓名3（双向）&lt;input type=\"text\" placeholder=\"姓名3双向\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'A', lastName: 'B', fullName2: 'A B' &#125;, watch: &#123; // 这个方法就是监视firstName，值发生改变是被调用执行函数 // 函数可以传入两个参数代表新值和改变之前的值，也可以传一个，也可以不传 firstName: function(value)&#123; this.fullName2 = value+ ' ' + this.lastName &#125; &#125; &#125;) vm.$watch('lastName',function(value)&#123; this.fullName2 = this.firstName + ' ' + value &#125;)&lt;/script&gt;&lt;/body&gt; 1.5.class和style绑定在某些页面中，某些元素的样式是动态发生变化的，class和style绑定就是用来实现动态改变样式效果的技术，其中class绑定中，表达式可以是字符串，可以是对象，也可以是数组，实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;class和style绑定&lt;/title&gt; &lt;style&gt; .aClass&#123;color: red&#125; .bClass&#123;color: blue&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;class绑定&lt;/h1&gt; &lt;p :class=\"a\"&gt;我是字符串&lt;/p&gt; &lt;p :class=\"&#123;aClass: isA,bClass: isB&#125;\"&gt;我是对象&lt;/p&gt; &lt;!--class绑定的是对象。当为true才会留下--&gt; &lt;h1&gt;style绑定&lt;/h1&gt; &lt;p :style=\"&#123;color: activeColor, fontSize: fontSize+'px'&#125;\"&gt;我是style强制绑定&lt;/p&gt; &lt;button @click='update'&gt;更新&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; a: 'aClass', isA: true, isB: false ,// 以上是绑定class activeColor: 'red', // 以下是绑定style fontSize : 20 &#125;, methods: &#123; update()&#123; this.a = 'bClass'; this.isA = false; this.isB = true;// 以上是绑定class this.activeColor = 'blue'; this.fontSize = 30; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.6.条件渲染在vue中条件渲染使用v-if、v-else和v-show指令，二者不同的地方在于v-if是不会生成不应该显示的元素，v-show是通过css控制隐藏不应该显示的节点元素，是在页面生成的，当需要频繁的切换时，使用v-show比较好，当条件不成立时，v-is的所有子节点也不会被解析； 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-if = 'ok'&gt;显示成功&lt;/p&gt; &lt;p v-else&gt;显示失败&lt;/p&gt; &lt;p v-show = 'ok'&gt;显示成功-v-show&lt;/p&gt; &lt;p v-show = '!ok'&gt;显示失败-v-show&lt;/p&gt; &lt;button @click='ok=!ok'&gt;切换&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; ok: false &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.7.列表渲染列表的渲染使用的是v-for指令，可以渲染数组和对象，注意的是遍历的时候指定唯一的index或者key，另外在做数组的删除和更新操作时使用数组的变异方法，有关vue的数组变异方法可以参考官方API； 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;v-for遍历数组&lt;/h2&gt; &lt;ui&gt; &lt;li v-for=\"(u,index) in users\" ::key=\"index\"&gt; &#123;[index]&#125;====&#123;[u.name]&#125;====&#123;[u.age]&#125;== &lt;button @click='deleteUser(index)'&gt;删除&lt;/button&gt;==&lt;button @click=\"updateUser(index,&#123;name: '王八',age: 45&#125;)\"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ui&gt; &lt;h2&gt;v-for遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(value,key) in users[1]\" :key=\"key\"&gt; &#123;[value]&#125;===&#123;[key]&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; users: [ // vue本身只是监视了users的改变，没有监视数组内部数据的改变 &#123;name: '张三',age: 23&#125;, &#123;name: '李四',age: 56&#125;, &#123;name: '王五',age: 76&#125;, &#123;name: '赵六',age: 87&#125;, &#123;name: '陈七',age: 34&#125; ] &#125;, methods: &#123; deleteUser(index)&#123; this.users.splice(index,1); &#125;, updateUser(index,value)&#123; // 如果只写 this.users[index] = value这一条语句，只改变了数组内部的数据，如果不调用vue的变异方法，就不会更新页面 // vue重写了数组中的一系列方法，重写后就是改变数组操作，然后重新渲染页面，也就是实现的数据绑定 this.users.splice(index,1,value) ; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 列表渲染-列表过滤和排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"searchName\"&gt; &lt;ui&gt; &lt;li v-for=\"(u,index) in filterUsers\" ::key=\"index\"&gt; &#123;[index]&#125;====&#123;[u.name]&#125;====&#123;[u.age]&#125; &lt;/li&gt; &lt;/ui&gt; &lt;button @click=\"setOrderType(1)\" &gt;年龄升序&lt;/button&gt; &lt;button @click=\"setOrderType(2)\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"setOrderType(0)\"&gt;原本排序&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; searchName: '', orderType: 0, // 0代表原本，1代表升序，2代表降序 users: [ // vue本身只是监视了users的改变，没有监视数组内部数据的改变 &#123;name: '张三',age: 23&#125;, &#123;name: '李四',age: 56&#125;, &#123;name: '张五',age: 76&#125;, &#123;name: '赵六',age: 87&#125;, &#123;name: '陈七',age: 34&#125; ] &#125;, computed: &#123; filterUsers() &#123; const &#123;searchName,users,orderType&#125; = this;// 取到相关数据（searchName和users） let fusers; // 定义最终返回的数组 fusers = users.filter(u =&gt; u.name.indexOf(searchName) !==-1);// 对users进行过滤 // 对fusers排序 if(orderType !== 0)&#123; fusers.sort(function(u1,u2)&#123; // 如果返回负数p1在前，返回正数p2在前 // 1.代表升序,2.代表降序 if(orderType == 2)&#123; return u2.age - u1.age &#125;else&#123; return u1.age -u2.age &#125; &#125;) &#125; return fusers; &#125; &#125;, methods: &#123; setOrderType(value)&#123; this.orderType = value; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.8.事件处理在vue中绑定监听使用@xxx=&#39;fun&#39;,其中点击函数和传参数和不传参数，默认事件的形参是event,当需要传参的同时需要默认event时候，使用隐含属性对象@xxx = fun(123,$event)；事件有两个修饰符：.prevent：阻止事件的默认事件的默认行为和.stop：停止事件冒泡；按键修饰符使用keyup.keyCode = fun()：keycode是键盘输入对应的ketcode值，可以使用名称，但是存在一部风没有； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;绑定监听&lt;/h2&gt; &lt;button @click=\"test1\" &gt;我是按钮一&lt;/button&gt; &lt;button @click=\"test2('Hello 码酱')\"&gt;我是按钮二，我想获取自己传入的值&lt;/button&gt; &lt;button @click=\"test3\"&gt;我是按钮三，我就想获取自己&lt;/button&gt; &lt;button @click=\"test4('Hello',$event)\"&gt;我是按钮四，我想获取获取自己的同时获取传入的值&lt;/button&gt; &lt;h2&gt;事件修饰符：事件冒泡和事件默认行为&lt;/h2&gt; &lt;div style=\"width: 200px; height: 200px; background: red\" @click=\"test5\"&gt; &lt;!-- 使用 @click.stop阻止事件的冒泡--&gt; &lt;div style=\"width: 100px; height: 100px; background: blue\" @click.stop=\"test6\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 使用@click.prevent阻止事件的默认行为 --&gt; &lt;a href=\"luokangyuan.com\" @click.prevent=\"test7\"&gt;去码酱博客&lt;/a&gt; &lt;h2&gt;按键修饰符：使用@keyup.13，其中的数字代表键盘每一个输入对应的keycode&lt;/h2&gt; &lt;input type=\"text\" @keyup.13=\"test8\"&gt; &lt;input type=\"text\" @keyup.enter=\"test8\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', methods: &#123; test1()&#123; alert(\"四川码酱\"); &#125;, test2(msg)&#123; alert(msg); &#125;, test3(event)&#123; alert(event.target.innerHTML); &#125;, test4(msg,event)&#123; alert(msg+\"===\"+event.target.innerHTML); &#125;, test5()&#123; alert(\"执行了外面的div的点击事件\"); &#125;, test6()&#123; alert(\"执行了里面的div的点击事件\"); &#125;, test7()&#123; alert(\"不去码酱博客\") &#125;, test8(event)&#123; alert(event.target.value); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.9.表单输入绑定表单的数据绑定使用v-model指令，具体相关编码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form action=\"/xxx\" @submit.prevent=\"handSubmit\"&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type=\"text\" v-model=\"userName\"&gt; &lt;br&gt; &lt;span&gt;密码：&lt;/span&gt; &lt;input type=\"password\" v-model=\"pwd\"&gt; &lt;br&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type=\"radio\" id=\"wman\" value=\"女\" v-model=\"sex\"&gt; &lt;label for=\"wman\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"man\" value=\"男\" v-model=\"sex\"&gt; &lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;br&gt; &lt;span&gt;爱好：&lt;/span&gt; &lt;input type=\"checkbox\" id=\"basket\" value=\"basket\" v-model=\"likes\"&gt; &lt;label for=\"basket\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"footbal\" value=\"foot\" v-model=\"likes\"&gt; &lt;label for=\"footbal\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"pingpang\" value=\"pingpang\" v-model=\"likes\"&gt; &lt;label for=\"pingpang\"&gt;乒乓球&lt;/label&gt; &lt;br&gt; &lt;span&gt;城市：&lt;/span&gt; &lt;select name=\"\" id=\"\" v-model=\"cityId\"&gt; &lt;option value=\"\"&gt;未选择&lt;/option&gt; &lt;option :value=\"city.id\" v-for=\"(city,index) in allCitys\" :key=\"index\"&gt;&#123;[city.name]&#125;&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;个人介绍：&lt;/span&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"desc\"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data: &#123; userName: '', pwd: '', sex: '男', // 默认选中性别男 likes: ['foot'], // 默认选中foot对应的多选框 allCitys: [&#123; id: 1, name: \"北京\" &#125;, &#123; id: 2, name: \"成都\" &#125;, &#123; id: 3, name: \"上海\" &#125;, &#123; id: 4, name: \"宁波\" &#125;], cityId: '',// 这里默认是空，则匹配未选择，如果默认选中成都，则写2即可 desc: '' &#125;, methods: &#123; handSubmit() &#123; console.log(this.userName, this.pwd, this.sex, this.likes, this.cityId, this.desc) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.10.Vue的生命周期 常用的生命周期方法：create()/mounted():常用于发送Ajax请求启动定时器等异步任务，beforeDestory()：常用于做一些收尾工作，例如关闭定时器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click= \"destoryVm\"&gt;点击我取消Vue实例&lt;/button&gt; &lt;p v-show = \"isShow\"&gt;我是四川码酱&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data: &#123; isShow: true &#125;, beforeCreate() &#123; console.log(\"我是beforeCreate方法，我被执行了\"); &#125;, created() &#123; console.log(\"我是created方法，我被执行了\"); &#125;, beforeMount() &#123; console.log(\"我是beforeMount方法，我被执行了\"); &#125;, mounted()&#123; // 初始化显示之后立即调用，也是执行一次 this.intervalId = setInterval(() =&gt;&#123; console.log(\"=====\"); this.isShow = !this.isShow; &#125;, 1000) &#125;, beforeUpdate() &#123; console.log(\"我是beforeUpdate方法，我被执行了\"); &#125;, updated() &#123; console.log(\"我是updated方法，我被执行了\"); &#125;, beforeDestroy() &#123; // 死亡之前回调一次 // 清除定时器 clearInterval(this.intervalId) &#125;, destroyed() &#123; console.log(\"我是destroyed方法，我被执行了\"); &#125;, methods: &#123; destoryVm()&#123; this.$destroy(); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 说明：beforeCreate、created、beforeMount、mounted初始化方法只执行一次，beforeUpdate、updated执行多次，beforeDestroy、destroyed死亡方法，也执行一次； 1.11.过渡和动画在vue中动画就是操作css的trasition或者animation属性，vue会给目标元素添加和移除指定的class，只不过要遵循一定的命名规则， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;title&gt;动画和过渡&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* 指定显示和隐藏的过渡效果 */ .fade-enter-active, .fade-leave-active &#123; transition: opacity 1s; &#125; /* 指定隐藏的样式 */ .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; /* 指定显示的过滤效果 */ .move-enter-active &#123; transition: all 1s &#125; /* 指定隐藏的过滤效果 */ .move-leave-active &#123; transition: all 3s &#125; /* 指定隐藏的样式 */ .move-enter, .move-leave-to &#123; opacity: 0; transform: translateX(20px) &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"isshow = !isshow\"&gt;动画按钮&lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-show=\"isshow\"&gt;四川码酱&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;div id=\"app1\"&gt; &lt;button @click=\"isshow = !isshow\"&gt;多属性动画按钮&lt;/button&gt; &lt;transition name=\"move\"&gt; &lt;p v-show=\"isshow\"&gt;四川码酱&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data() &#123; return &#123; isshow: true &#125; &#125; &#125;) new Vue(&#123; el: \"#app1\", data() &#123; return &#123; isshow: true &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.12.过滤器在vue中允许自定义过滤器，所谓过滤器就是：对要显示的数据进行特定格式化后在显示，例如时间格式化等，注意的是：并没有改变原本的数据，只是产生新的对应数据； 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;当前完整时间为：&#123;[data | dateString]&#125;&lt;/p&gt; &lt;p&gt;当前日期为：&#123;[data | dateString('YYYY-MM-DD')]&#125;&lt;/p&gt; &lt;p&gt;当前时间为：&#123;[data | dateString('HH:mm:ss')]&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/moment.js/2.22.1/moment.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 自定义过滤器 Vue.filter('dateString',function(value,format)&#123; return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss') &#125;) new Vue(&#123; el: \"#app\", data: &#123; data: new Date() &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.13.内置指令和自定义指令常用的内置指令 v:text : 更新元素的 textContent v-html : 更新元素的 innerHTML v-if : 如果为 true, 当前标签才会输出到页面 v-else: 如果为 false, 当前标签才会输出到页面 v-show : 通过控制 display 样式来控制显示/隐藏 v-for : 遍历数组/对象 v-on : 绑定事件监听, 一般简写为@ v-bind : 强制绑定解析表达式, 可以省略 v-bind v-model : 双向数据绑定 ref : 指定唯一标识, vue 对象通过$els 属性访问这个元素对象 v-cloak : 防止闪现出现{[xxx]}, 与 css 配合: [v-cloak] { display: none } 1234567891011121314151617181920212223242526272829&lt;title&gt;内置指令&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p ref=\"content\"&gt;四川码酱&lt;/p&gt; &lt;button @click = \"hint\"&gt;提示&lt;/button&gt; &lt;p v-cloak&gt;&#123;[msg]&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data: &#123; msg: \"Hello 四川码酱\" &#125;, methods: &#123; hint()&#123; alert(this.$refs.content.textContent); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 说明： v-cloak指令是为了页面加载数据缓慢时候显示{[xxx]}标签而出了一个指令，与CSS搭配使用 自定义指令 注册全局指令，方法如下： 123Vue.directive('my-directive', function(el, binding)&#123; el.innerHTML = binding.value.toupperCase()&#125;) 注册局部指令，方法如下： 1234567directives : &#123; 'my-directive' : &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toupperCase() &#125; &#125;&#125; 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 定义全局指令 // el：指令属性所在的标签属性 // binding：包含指令相关信息数据的对象 Vue.directive('upper-text', function(el,binding)&#123; el.textContent = binding.value.toUpperCase() console.log(el,binding) &#125;) new Vue(&#123; el: \"#app\", data: &#123; msg: \"This is my think life\" &#125;, directives: &#123; // 使用自定义局部指令 'lower-text' : function(el,binding)&#123; el.textContent = binding.value.toLowerCase() &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.14.核心知识总结 Vue是前端开发库，用于构建用户界面，遵循MVVM模式，编码简洁，体积小，效率高，包含了一些列插件库； 基本使用：引入vue.js，创建vue实例对象，其中el代表dom标签选择器，data代表初始化数据对象； el：指定dom标签容器的选择器，一般写一个根标签； data：对象或者函数类型，指定初始化状态属性数据的对象，页面中可以使用{[xxx]}直接访问 methods：包含多个方法的对象，供页面中的事件指令来回调，回调函数默认有$event参数，也可以指定自己的参数，在方法中，访问data中的属性直接使用this.xxx； computed：计算属性，包含多个方法的对象，对状态属性进行计算处理后返回给页面一个新的数据，使用get和set方法实现属性的计算读取，同时监视数据的变化； watch：监视，包含多个属性监视的对象，xxx.function(value){}，可以传入两个参数，代表新值和改变前的值，也可以使用vm.$watch(&#39;xxx&#39;, function(value){})的方式添加监听； vue中的过渡和动画，实质就是vue操作css的transition/animation属性； 生命周期：常用的钩子函数是created() / mounted(): 启动异步任务(启动定时器,发送ajax请求, 绑定监听)和beforeDestroy(): 做一些收尾的工作例如清除定时器等； 自定义过滤器：使用的是Vue.filter(filterName,function(value){})，在页面使用方法：{[myData | filterName(arg)]}，参数可传可不传； vue内置指令：v-for遍历、@绑定事件、v-model数据双向绑定、ref标识标签； 自定义指令：使用Vue.directive注册全局指令，使用directives注册局部指令； 注意：数据在哪个组件，更新数据的行为（方法）就应该定义在那个组件中 二、Vue组件化编码方式2.1.使用vue-cli创建模板项目vue-cli是vue官方提供的脚手架工具，首先确认安装了node和npm，最好安装一个cnpm，使用方法如下： npm install -g vue-cli vue init webpack vue_demo 其中 vue_demo是项目名 cd vue_demo npm install或者npm run dev 项目结构说明 build : webpack 相关的配置文件夹(基本不需要修改) dev-server.js : 通过 express 启动后台服务器 config: webpack 相关的配置文件夹(基本不需要修改) index.js: 指定的后台服务的端口号和静态资源文件夹 src : 源码文件夹 components: vue 组件及其相关资源文件夹 App.vue: 应用根主组件 main.js: 应用入口 js static: 静态资源文件夹 .babelrc: babel 的配置文件 .eslintignore: eslint 检查忽略的配置 .eslintrc.js: eslint 检查的配置 .gitignore: git 版本管制忽略的配置 index.html: 主页面文件 package.json: 应用包配置文件 README.md: 应用描述说明的 readme 文件 简单的使用Vue模板项目 首先，我们编写了一个HelloWord的组件， 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1 class=&quot;msg&quot;&gt;&#123;[ msg ]&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 配置对象和Vue一致 data() &#123; // data可以 写对象和函数，但是在组件中必须使用函数 return &#123; msg: &quot;Hello Welcome to My Vue&quot; &#125;; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt; .msg &#123; color: red &#125;&lt;/style&gt; 然后，我们在App.vue中使用我们自己定义的组件 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;!-- 使用组件标签 --&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1.引入需要使用的vue组件（HelloWoed组件）import HelloWorld from &apos;./components/HelloWorld&apos;export default &#123; components: &#123; // 2.映射组件标签 HelloWorld &#125;&#125;&lt;/script&gt;&lt;style&gt;.logo&#123; width: 100px; height: 100px;&#125;&lt;/style&gt; 我们知道使用Webpack打包后会生成一个js文件，也就是入口文件main.js 12345678910import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', // 挂载到入口Dom节点（index.html） components: &#123; App &#125;, // 映射组件标签 template: '&lt;App/&gt;' //使用标签&#125;) 2.2.项目打包发布方式打包命令：npm run build 使用静态服务器：安装命令：npm install -g serve，发布命令：serve dist，然后直接访问就可以了 使用动态web服务器（Tomcat）:修改webpack.prod.conf.js，加入output: {publicPath: &#39;/xxx/&#39; //打包文件夹的名称}，然后重新打包，将dis文件夹的名称改为项目名称，放在tomcat的webapp目录下，访问即可； 2.3.组件的定义三、Vue请求方式vue-ajax四、Vue组件库五、Vue路由vue-router六、Vue状态管理vuex","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://caochenhins.github.io/tags/vue/"}]},{"title":"前端基础知识学习---jQuery学习总结","slug":"前端基础知识学习-jQuery学习总结","date":"2019-03-21T14:43:32.000Z","updated":"2019-03-21T15:20:20.648Z","comments":true,"path":"2019/03/21/前端基础知识学习-jQuery学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-jQuery学习总结/","excerpt":"jQuery学习笔记jQuery简介jQuery是一个优秀的JS函数库,其官网可以看一下，jQuery包含了HTML元素选取，HTML元素操作，CSS操作，HTML事件等内容。 jQuery的两把利器jQuery核心函数jQuery核心函数就是$或者jQuery，它定义了这个全局的函数供我们使用，它既可以用于一般的函数调用，且传递的参数类型不同，格式不同功能就完全不同，也可以作为对象调用其定义好的方法，此时的$就是一个工具对象。","text":"jQuery学习笔记jQuery简介jQuery是一个优秀的JS函数库,其官网可以看一下，jQuery包含了HTML元素选取，HTML元素操作，CSS操作，HTML事件等内容。 jQuery的两把利器jQuery核心函数jQuery核心函数就是$或者jQuery，它定义了这个全局的函数供我们使用，它既可以用于一般的函数调用，且传递的参数类型不同，格式不同功能就完全不同，也可以作为对象调用其定义好的方法，此时的$就是一个工具对象。 作为函数调用 参数为函数即$(function) 参数为选择器字符串即$(&quot;#btn&quot;) 参数为DOM对象即$(div) 参数为html标签字符串即$(&quot;&lt;div&gt;&quot;) 123456789101112&lt;body&gt; &lt;input type=\"text\" name=\"userName\" id=\"userName\" /&gt; &lt;button id=\"search\" value=\"搜索\"&gt;搜索&lt;/button&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.1.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123;/*绑定文档加载完成的监听*/ $('#search').click(function()&#123;/*给按钮添加点击监听事件*/ var userName = $('#userName').val();/*获取DOM元素的值*/ &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 说明：上述代码使用了jQuery核心函数：$/jQuery，使用了jQuery核心对象：执行$()返回的对象，$(&#39;#search&#39;) 作为函数的时候，不同参数实例 123456789101112131415161718192021&lt;body&gt; &lt;div&gt; &lt;button id=\"btn\"&gt;确定&lt;/button&gt; &lt;input type=\"text\" name=\"msg1\" /&gt; &lt;input type=\"text\" name=\"msg2\" /&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.10.1.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123;/*参数为函数即$(function):执行此回调函数*/ /*参数为选择器字符串即$(\"#btn\"):查找所匹配的标签，并将他们封装为jQuery对象*/ $('#btn').click(function()&#123;/*绑定监听事件*/ alert(this.innerHTML)/*this:发生事件的DOM元素*/ /*参数为DOM对象即$(div):此时的this就是一个DOM元素， *此时将dom对象封装为jQuery对象，就可以使用jQuery对象的方法*/ alert($(this).html()) /*参数为html标签字符串即$(\"&lt;div&gt;\"):创建标签对象，并封装为jQuery对象*/ $('&lt;input type=\"text\" name=\"msg3\" /&gt;').appendTo('div'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 作为对象使用作为对象使用的时候，时长用于发送AJAX请求或者遍历数组等，例如$.ajax()，$.each()，$.get()，实例如下： 12345678var arr = [2,3,4];/*$.each():隐式遍历数组 */$.each(arr,function(index,item)&#123; console.log(index,item)&#125;)/*$.trim():去除两端空格*/var str = ' Hello Word 'console.log($.trim(str)); jQuery核心对象即执行jQuery核心函数返回的对象，jQuery对象内部包含的是dom元素对象的伪数组(可能只有一个元素)，jQuery对象拥有很多有用的属性和方法, 让程序员能方便的操作dom 属性和方法 基本行为：size()/length，[index]/get(index)，each()，index() 属性：操作内部标签的属性或值 CSS：操作标签的样式 文档：对标签进行增删改操作 筛选：根据指定的规则过滤内部的标签 事件：处理事件监听相关 效果：实现一些动画效果 使用jQuery核心函数","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://caochenhins.github.io/tags/jQuery/"}]},{"title":"前端基础知识学习---JavaScript学习总结","slug":"前端基础知识学习-JavaScript学习总结","date":"2019-03-21T14:43:15.000Z","updated":"2019-03-21T15:19:35.012Z","comments":true,"path":"2019/03/21/前端基础知识学习-JavaScript学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-JavaScript学习总结/","excerpt":"JavaScript基础部分JavaScript基础知识脑图总结 JavaScript简介大家都知道Html+CSS+JavaScript是前端入门的三门基本课程，其中Javascript应该是最难的，也是可以解决很多很多问题的，这篇笔记只是介绍JavaScript的基础知识，后面随着学习的深入，将会总结JavaScript的高级知识。接下来，我们需要介绍一下知识： JavaScript的基本语法、变量和标识符； JavaScript数据类型、类型转换和运算符； JavaScript的流程控制语句； 对象、函数、数组和文档对象模型；","text":"JavaScript基础部分JavaScript基础知识脑图总结 JavaScript简介大家都知道Html+CSS+JavaScript是前端入门的三门基本课程，其中Javascript应该是最难的，也是可以解决很多很多问题的，这篇笔记只是介绍JavaScript的基础知识，后面随着学习的深入，将会总结JavaScript的高级知识。接下来，我们需要介绍一下知识： JavaScript的基本语法、变量和标识符； JavaScript数据类型、类型转换和运算符； JavaScript的流程控制语句； 对象、函数、数组和文档对象模型； JavaScript的基本语法 JavaScript采用单行注释和多行注释； JavaScript严格区分大小写; JavaScript每条语句以分号结尾，如果不加，浏览器会帮我们添加，影响性能，压缩的时候还会出错； JavaScript会自动忽略多个空格和换行； JavaScript变量 ES的变量是松散类型的，就是定义的时候不区分类型，使用var关键字定义变量； 使用等号为变量赋值； 在最外面定义的是全局变量，在函数内部定义的就是局部变量，如果不加var关键字就变成全局变量； 变量名不能使用JavaScript中的关键字和保留字； 多个变量定义使用逗号隔开，使用分号结尾； JavaScript标志符 标识符中可以含有数字，字母，下划线和$； 标志符不能以数字开头； 标志符不能是JavaScript中的关键字和保留字； 标志符最好使用驼峰命名方式； JavaScript数据类型在javaScript中存在六种数据类型：五种基本数据类型和一种引用类型（Object）分别为：String字符串、Number数值、Boolean布尔值、NULL空值、Undefind未定义和Object对象 说明：在JavaScript中使用typeof返回变量的数据类型； JavaScript类型转换类型转换就是将其他的数据类型转为String、Boolean、Number，基本每一个类型的转换方式都有很多，详情可以参考脑图总结。 转为String： 强制类型转换，即调用被转换数据的toString()，不适合null和Undefined类型，他们没有toString()方法； 直接调用String函数，例如String(str);会讲null和Undefined转为对应的字符串； 隐式类型转换，即在数据后+””; 转为Number： 调用Number()函数,合法数字字符串正常转换，非法转为NaN,空串或纯空格转为0，true转为1，false转为0，null转为0，Undefind转为NaN； 调用parseFloat()和parseInt()函数； 转为Boolean： 使用Boolean()函数，字符串转布尔除了空串全为true，数值除了0和NaN全为true，null和Undefined全为false，对象转布尔值都是true。 隐士转换，使用两个!!，例如 1234let age = 12;if(!!age)&#123; console.log(\"数值转为布尔值\")&#125; JavaScript运算符在JavaScript中，运算符包括typeof运算符、算数运算符、一元运算符、逻辑运算符、赋值运算符、关系运算符以及三元运算符和相等运算符。运算符都是一些基本很简单的，可以参考脑图总结，下面列举一些需要注意的： 由于undefined衍生自null，所以 null == undefind会返回true，但是 null === undefind 会返回false ； NaN不与任何值相等，包括他本身 判断一个值是否是NaN使用isNaN()函数 JavaScript对象对象Object是JavaScript六种数据类型中的引用类型，用来保存不同数据类型的数据，使用vae obj = {}或者var obj = new Object()方式创建，使用对象名.属性名来获取对象中的属性值，使用属性名 in 对象来检测是否含有属性； JavaScript数组数组比较简单，在脑图中也有详细的介绍，下面主要列举数组的一些常用方法 push()：向数组的末尾添加一个或多个元素，并返回数组的新长度 pop()：用来删除数组的最后一个元素，并返回被删除的元素 unshift()：用来向数组的开头添加一个或多个元素，并返回数组的新长度 shift()：用来删除数组开头的一个元素，并返回被删除的元素 slice()：从数组中截取指定的元素 splice()：可以用来删除数组中指定的元素，并使用新元素代替 性能最高的数组遍历：for(j = 0,len=arr.length; j &lt; len; j++) {} 文档对象模型DOMDOM查询： document.getElementById(“id属性值”); document.getElementsByName(“name属性值”); 根据元素的class属性查找一组元素。存在多个返回一个：document.querySelector() document.getElementsByTagName(“标签名”); document.getElementsByClassName(className) DOM增加： 在指定节点的内部最后添加节点：element.appendChild(Node); 在指定节点内部，指定节点前面添加节点：elelment.insertBefore(newNode,existingNode); DOM删除： 删除当前节点下的子节点，成功返回删除的节点，否则返回null：element.removeChild(Node) DOM节点创建： 创建一个Html元素节点：ar oP = document.createElement(“p”); 创建一个文本节点：document.createTextNode(String); 创建一个属性节点：document.createAttribute(“class”); DOM常用操作： 获取父节点：element.parentNode ； 获取所有子节点，包括html节点，文本节点，属性节点：element.chilidNodes ； 获取第一个子节点：element.firstChild ； 获取当前元素的下一个同级节点，没有返回null：element.nextSibling ； 获取当前元素的所有文本，包括Html代码：element.innerHTML 浏览器对象模型BOMwindow对象：当前浏览器窗体 属性如下： opener：即谁打开我的，若在A用open打开B则B的opener就是A closed：判断子窗体是否关闭 方法如下： alert() 弹出框 confirm() 带确认,取消弹出框 setInterval() 每隔多少秒调用一次 clearInterval() 清除setInterval setTimeout() 隔多少秒调用一次 cleartimeout() 清除setTimeout open() 打开一个新的窗口window.open(&quot;other.html&quot;,&quot;_blank&quot;,&quot;width=200,height=300,top=300&quot;);console:console.log()浏览器控制台打印 子对象：doument loation history screen …… doument dom操作 loation 跳转位置window.location.href=&quot;popl.html&quot;; history 历史history.back()//返回到前一页 等于history.go(-1) 参数负几就是返回前几步 screen //屏幕screen.availHeight //屏幕实际高度screen.availWidth //屏幕实际宽度screen.height //屏幕高度screen.width //屏幕宽度 常见的页面交互事件表单元素事件,在表单元素中才有效 onchange 框内容改变时 onsubmit 点击提交按钮时 onreset 重新点击鼠标按键时 onselect 文本被选择时 onblur 元素失去焦点时 onfocus 当元素获取焦点时 键盘事件 onkeydown 按下键盘按键时 onkeypress 按下或按住键盘按键时 onkeyup 放开键盘按键时 其他事件 onclick 鼠标点击一个对象时 ondblclick 鼠标双击一个对象时 onmousedown 鼠标被按下时 onmousemove 鼠标被移动时 onmouseout 鼠标离开元素时 onmouseover 鼠标经过元素时 onmouseup 释放鼠标按键时","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://caochenhins.github.io/tags/JavaScript/"}]},{"title":"前端基础知识学习---JavaScript高级学习总结","slug":"前端基础知识学习-JavaScript高级学习总结","date":"2019-03-21T14:42:55.000Z","updated":"2019-03-21T15:19:51.597Z","comments":true,"path":"2019/03/21/前端基础知识学习-JavaScript高级学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-JavaScript高级学习总结/","excerpt":"[TOC] JavaScript高级学习笔记基础总结数据类型数据类型分为两类，基本(值)类型（Number: 任意数值，String: 任意文本，Boolean: true/false，undefined: undefined，null: null）和对象类型（Object: 一般对象类型，Array: 特别的对象类型(下标/内部数据有序)，Function: 特别的对象类型(可执行)）。 数据类型的判别方法有typeof，instanceof和===，其中typeof可以区别: 数值, 字符串, 布尔值, undefined, function不能区别: null与对象, 一般对象与数组；instanceof专门用来判断对象数据的类型: Object, Array与Function；===可以判断: undefined和null；","text":"[TOC] JavaScript高级学习笔记基础总结数据类型数据类型分为两类，基本(值)类型（Number: 任意数值，String: 任意文本，Boolean: true/false，undefined: undefined，null: null）和对象类型（Object: 一般对象类型，Array: 特别的对象类型(下标/内部数据有序)，Function: 特别的对象类型(可执行)）。 数据类型的判别方法有typeof，instanceof和===，其中typeof可以区别: 数值, 字符串, 布尔值, undefined, function不能区别: null与对象, 一般对象与数组；instanceof专门用来判断对象数据的类型: Object, Array与Function；===可以判断: undefined和null； undefined与null的区别?undefined代表变量没有赋值，null: 代表变量赋值了, 只是值为null 什么时候将变量赋值为null?初始化赋值: 将要作为引用变量使用, 但对象还没有确定，结束时: 将变量指向的对象成为垃圾对象 严格区别变量类型与数据类型?js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型，变量类型包括基本类型( 保存基本类型数据的变量)引用类型(保存对象地址值的变量)，数据对象包括基本类型和对象类型 数据和变量和内存什么是数据？存储于内存中代表特定信息的’东西’, 本质就是0101二进制，具有可读和可传递的基本特性，万物(一切)皆数据, 函数也是数据，程序中所有操作的目标: 数据，例如：算术运算，逻辑运算，赋值，调用函数传参等； 什么是内存? 内存条通电后产生的存储空间(临时的)，产生和死亡: 内存条(集成电路板)==&gt;通电==&gt;产生一定容量的存储空间==&gt;存储各种数据==&gt;断电==&gt;内存全部消失，内存的空间是临时的, 而硬盘的空间是持久的，内存分为栈（全局变量, 局部变量 (空间较小)）和堆（对象 (空间较大)）；一块内存包含2个数据，分别为内部存储的数据(一般数据/地址数据)和内存地址值数据； 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据 释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用) 自动释放: 栈空间的局部变量 垃圾回调器回调: 堆空间的垃圾对象 什么是变量？值可以变化的量, 由变量名与变量值组成,一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容; 三者的关系内存是一个容器, 用来存储程序运行需要操作的数据，变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据 赋值和内存的问题对于var a = xxx,a内存中到底保存的是什么，当xxx是基本数据，对象和变量时保存对应的类型。 引用变量赋值问题2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见；2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象 在js调用函数时传递变量参数时, 是值传递还是引用传递?只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据，如果后一种看成是引用传递, 那就值传递和引用传递都可以有； 对象什么是对象代表现实中的某个事物, 是该事物在编程中的抽象；多个数据的集合体(封装体)；用于保存多个数据的容器 为什么要使用对象便于对多个数据进行统一管理 对象的组成属性：代表现实事物的状态数据，由属性名和属性值组成，属性名都是字符串类型, 属性值是任意类型 方法：代表现实事物的行为数据；是特别的属性==&gt;属性值是函数 如何访问对象内部数据通过.属性名的方式，还可以通过[&#39;属性名&#39;]的方式 函数什么是函数？具有特定功能的n条语句的封装体，只有函数是可执行的, 其它类型的数据是不可执行。 为什么要用函数? 提高代码复用和便于阅读和交流； 如何定义函数？ 函数声明加表达式的方式； 如何调用(执行)函数？可以通过如下几种方式调用定义的函数：test()，new test()，obj.test()，test.call/apply(obj) 回调函数什么函数才是回调函数？回调函数满足以下三个条件，你定义的，你没有直接调用，但最终它执行了(在特定条件或时刻)； 常见的回调函数？DOM事件函数；定时器函数；Ajax回调函数等； 匿名函数自调用IIEF全称: Immediately-Invoked Function Expression 立即调用函数表达式，别名: 匿名函数自调用，他的作用有两点隐藏内部实现和不污染外部命名空间； test","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://caochenhins.github.io/tags/JavaScript/"}]},{"title":"前端基础知识学习---Html基础知识总结","slug":"前端基础知识学习-Html基础知识总结","date":"2019-03-21T14:42:27.000Z","updated":"2019-03-21T15:20:03.515Z","comments":true,"path":"2019/03/21/前端基础知识学习-Html基础知识总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-Html基础知识总结/","excerpt":"一、Html初级知识总结1.基础知识脑图总结 2.基本简介2.1.什么是Html","text":"一、Html初级知识总结1.基础知识脑图总结 2.基本简介2.1.什么是Html Html不是编程语言，而是用来描述网页结构的一种标记语言 ，简单的说就是给展示在网页上的文本加上表示文本含义的标签，让人们可以更好的理解 。 2.2.什么是Html5Html5是定义html标准的最新版本，是一个新的html语言，具有新的元素，属性和行为 ，新增了一些改变，例如标签语义化等。 3.基本语法 html标签是有尖括号（&lt;和&gt;）包围的关键词，不区分大小写，推荐使用小写 ； html标签是成对出现 html标签也存在空元素（不包含文本及其他属性的标签）例如&lt;img/&gt; html文档包含的内容 ：文本、链接、图片、表格、表单、列表、框架等 4.基本概念4.1.什么是标签用尖括号包围的关键字就是标签，存在开始标签和结束标签 。 4.2.什么是元素简单讲就是标签+标签包含的文本内容 ，元素又分为三种，分别是块级元素、内联元素和内联块级元素。 块级元素： 在浏览器显示默认是在新的一行开始（和结束）的元素 高度，宽度，行高以及距离顶部和底部的距离都可以设置 宽度默认是和父元素的宽度保持一直（父容器的100%） 常见的块级元素：div; p; h1; ol; li; dl; form; table; address等 使用display:block可以将元素转为块级元素 内联元素： 也叫行内元素，在浏览器中默认按照从左到右显示，不独占一行 高度，宽度以及距离顶部和底部的距离不可设置 宽度就是它包含的文字或者图片的宽度 常见的内联元素：a; span; br; i; em; lable; q;strong等 使用display:inline可将块级元素转为内联元素 内联块级元素： 同时具备内联元素和块级元素的特点 和其他元素在一行上 元素的宽度和高度以及距离顶部和底部的距离都是可以设置的 常见的内联块级元素：img; input 使用display:inline-block; float:left/right; position: absolute/fixed可以将元素转为内联块级元素 4.3.什么是属性属性就是在开始标签中以名称+值存在的内容就是属性。 1&lt;a href=\"index.html\"&gt;&lt;/a&gt; 常见的全局属性： id：控制元素的唯一 class：设置元素一个或者类名，用于样式表中的类 style：设置元素的行内样式 title：定义元素的提示信息 lang：设置元素内容的语言代码 accesskey：设置访问元素的键盘快捷键 tabindex：设置元素的tab键次序 常见的元素属性： href：指定链接到互联网或者其他资源 target：指定打开链接的目标窗口 title：指定所要链接的页面的文本描述 src：指定请求资源的服务器路径 alt：指定图片未加载时候显示的文字 5.常见元素5.1.根元素 &lt;doctype&gt;：定义文档类型 &lt;html&gt;：定义Html文档 1&lt;!DOCTYPE html&gt; 1&lt;html lang=\"en\"&gt; 5.2.元数据元素 &lt;head&gt;：定义文档信息 &lt;meta&gt;：定义文档的元数据 &lt;title&gt;：定义文档的标题 123456&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; 5.3.块级元素 &lt;body&gt;：定义文档主体内容 &lt;h1&gt;、&lt;h2&gt;...&lt;h6&gt;：定义文档标题 &lt;ul&gt;、&lt;ul&gt;、&lt;dl&gt;：定义列表 12345678910&lt;div&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt; &lt;blockquote&gt;段落长引用&lt;/blockquote&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;&lt;/th&gt; &lt;/thead&gt; &lt;/table&gt;&lt;/div&gt; 说明：由于Html标签太多，就不再一一列举了，推荐一个API文档WebDoc 6.总结Html初级知识主要设计基本语法、基本声明使用、基本的概念、常用的元素和常用的属性，重点在于知道块级元素和内联元素之间的区别，以及那些元素是什块级元素，那些元素是内联元素。最重点的是学会如何查找API。","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://caochenhins.github.io/tags/HTML/"}]},{"title":"前端基础知识学习---CSS基础知识总结","slug":"前端基础知识学习-CSS基础知识总结","date":"2019-03-21T14:42:08.000Z","updated":"2019-03-21T15:19:21.144Z","comments":true,"path":"2019/03/21/前端基础知识学习-CSS基础知识总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-CSS基础知识总结/","excerpt":"一、CSS基础知识总结1.CSS基础知识脑图总结","text":"一、CSS基础知识总结1.CSS基础知识脑图总结 2.简介CSS 指层叠样式表 (Cascading Style Sheets) ，简单讲就是定义如何显示 HTML 元素 ； 3.基本语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明 选择器通常是您需要改变样式的 HTML 元素 每条声明由一个属性和一个值组成 属性是您希望设置的样式属性，每个属性有一个值。属性和值被冒号分开 说明：选择器+大括号＋键值对+用分号隔开 4.常用选择器首先，我们需要引入外部的CSS样式文件，外部样式表可以极大提高工作效率 ，引入方法如下： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../css/index.css\" &gt; 4.1.基本选择器通用选择器：*：选中页面所有的元素 1* &#123;font-size: 20px;&#125; 12345678&lt;div id=\"card\"&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;2&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 说明：html页面的所有元素的文字大小都会被改变； 元素选择器：选中html页面元素 1span &#123;font-size: 22px;&#125; 123456789&lt;div id=\"card\"&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;2&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 说明：html页面中span元素的文字大小会被改变，h2的文字大小不会被改变； ID选择器：选中对应ID属性值的html元素 1#card &#123;border: 1px solid #FF2A68;&#125; 说明：html元素和上述一样，最外层的div将会被添加一个边框； 后代选择器：空格 123456789101112&lt;div id=\"card\"&gt; &lt;div class=\"photo\"&gt; &lt;span&gt;1&lt;/span&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"photo\"&gt; &lt;span&gt;2&lt;/span&gt; &lt;/div&gt; &lt;div class=\"default\"&gt; &lt;span class=\"photo\"&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1#card .photo &#123;background: #FF2A68;&#125; 说明：上述所有的class = “photo”的元素都会被选中； 直接后代元素选择器：&gt; 1#card &gt; .photo &#123;background: aqua;&#125; 说明：上述的3号photo的元素不会被选中，因为不属于直接后代元素； 相邻兄弟选择器：+ 12345&lt;div class=\"default\"&gt;1&lt;/div&gt;&lt;div class=\"photo\"&gt;3&lt;/div&gt;&lt;div class=\"photo\"&gt;5&lt;/div&gt;&lt;div class=\"nav\"&gt;6&lt;/div&gt;&lt;div class=\"photo\"&gt;7&lt;/div&gt; 1.default + .photo &#123;background: bisque;&#125; 说明：上述的只有3号元素会被选中，只有它才是default的相邻photo兄弟元素； 通用兄弟元素：～ 12345&lt;div class=\"default\"&gt;1&lt;/div&gt;&lt;div class=\"photo\"&gt;3&lt;/div&gt;&lt;div class=\"photo\"&gt;5&lt;/div&gt;&lt;div class=\"nav\"&gt;6&lt;/div&gt;&lt;div class=\"photo\"&gt;7&lt;/div&gt; 1.default ~ .photo &#123;background: bisque;&#125; 说明：其中的3，5，7号元素都会被选中，他们都是default的相邻兄弟元素 4.2.属性选择器存在属性选择器：[attr] 1234567891011&lt;form class=\"userInfo\"&gt; &lt;label&gt; 用户名： &lt;input type=\"text\" name=\"userName\" autocomplete=\"off\" placeholder=\"用户名\"&gt; &lt;/label&gt; &lt;label&gt; 密码：&lt;input type=\"password\" name=\"password\" autocomplete=\"off\" placeholder=\"密码\"&gt; &lt;/label&gt; &lt;label&gt; 性别：&lt;input type=\"text\" name=\"sex\"&gt; &lt;/label&gt;&lt;/form&gt; 1.userInfo [name] &#123;border: 1px solid #FF2A68;&#125; 说明：上述的html元素中的三个input框都包含了name属性，所以都将被选中； 存在和属性值选择器：[attr=val] 同样的是上述的html元素布局，我们使用存在和值属性选择器如下： 1.userInfo [name=\"userName\"] &#123;border: 1px solid #FF2A68;&#125; 说明：这样只会选中name=”userName”的input元素； 存在属性同事包含属性值选择器：[attr ~=val] 1234&lt;a href=\"#\" title=\"Hello Word\"&gt;HelloWord&lt;/a&gt;&lt;a href=\"#\" title=\"Hello People\"&gt;HelloPeople&lt;/a&gt;&lt;a href=\"#\" title=\"Hello Girl\"&gt;HelloGirl&lt;/a&gt;&lt;a href=\"#\" title=\"My name is solo\"&gt;My name is solo&lt;/a&gt; 1a[title ~= \"Hello\"] &#123;color: #FF2A68;&#125; 说明：前面三个a元素的title属性值都包含了Hello值，所以都会被选中； 子串值属性选择器选择属性值等于val或者以val-开头的元素：[attr|=val] 123&lt;a href=\"#\" title=\"HelloPeople\"&gt;HelloPeople&lt;/a&gt;&lt;a href=\"#\" title=\"Hello-Word\"&gt;HelloWord&lt;/a&gt;&lt;a href=\"#\" title=\"Hello\"&gt;HelloWord&lt;/a&gt; 1a[title |= \"Hello\"]&#123;color: aqua&#125; 说明：后两个a标签将会被选中； 选中存在属性，并且属性值以val 开始的元素：[attr ^= val] 1234&lt;a href=\"#\" title=\"Hello Word\"&gt;HelloWord&lt;/a&gt;&lt;a href=\"#\" title=\"Hello\"&gt;Hello&lt;/a&gt;&lt;a href=\"#\" title=\"HelloPeople\"&gt;HelloPeople&lt;/a&gt;&lt;a href=\"#\" title=\"Hello-Word\"&gt;HelloWord&lt;/a&gt; 1a[title ^= \"Hello\"]&#123;color: aqua&#125; 说明；上述列举的四种情况都满足，都将会被选中； 选中存在属性，并且属性值以val结束的元素：[attr $= val] 同样是上述的元素，修改为如下，将只会有第一个和最后一个被选中。 1a[title $= \"ord\"]&#123;color: aqua&#125; 选中存在属性，并且属性值中包含val的元素：[attr *= val] 同样的是上述的元素，修为如下，就只有第三个元素将会被选中。 1a[title *= \"p\"]&#123;color: aqua&#125; 4.3.伪类选择器和伪元素选择器伪类选择器包括 伪类选择器、 动态伪类 、表单伪类 和结构性伪类 ， 链接伪类 link：表示作为超链接，并指向一个未访问的地址的所有锚 visited：表示作为超链接，并指向一个已访问的地址的所有锚 动态伪类 hover：悬浮到目标元素上 active：点击下去 表单伪类 enabled：可用 disabled：不可用 checked：选中 结构性伪类 :nth-child(index)系列：找到某下的第一个适配元素 :nth-of-type(index)系列：找到某一下第一次出现的适配元素 说明：在 CSS 定义中，a:hover 必须被置于a:link 和 a:visited 之后，才是有效的； a:active必须被置于a:hover 之后，才是有效的； 伪类名称对大小写不敏感 1234567891011121314151617181920&lt;div class=\"card\"&gt; &lt;span class=\"a1\"&gt;我被.a1:nth-child(1)选中&lt;/span&gt; &lt;span class=\"a2\"&gt;我被.a2:nth-of-type(1)选中&lt;/span&gt; &lt;span class=\"a1\"&gt;我不被.a1:nth-child(1)选中&lt;/span&gt; &lt;a class=\"baidu\" href=\"#\"&gt;百度&lt;/a&gt; &lt;span class=\"baidu\"&gt;我是伪类选择器&lt;/span&gt; &lt;label class=\"a1\"&gt; &lt;input type=\"text\" disabled value=\"我会被disabled选中\"&gt; &lt;/label&gt; &lt;label class=\"a2\"&gt; &lt;input type=\"text\" value=\"我会被enabled选中\"&gt; &lt;/label&gt; &lt;label class=\"a1\"&gt; &lt;input type=\"checkbox\" checked&gt;&lt;span&gt;羽毛球&lt;/span&gt; &lt;/label&gt; &lt;label class=\"a3\"&gt; &lt;input type=\"checkbox\" &gt;&lt;span&gt;篮球&lt;/span&gt; &lt;/label&gt;&lt;/div&gt; 123456789a:visited&#123;color: blanchedalmond&#125;a:link&#123;color: aqua&#125;.baidu:hover&#123;color: coral&#125;.baidu a:active&#123;color: blueviolet&#125;input:disabled&#123;border: 1px solid #FF2A68&#125;input:enabled&#123;border: 1px solid #52EDC7&#125;input:checked + span&#123;color: #FF2A68&#125;.a1:nth-child(1)&#123;color: #5856D6&#125;.a2:nth-of-type(1)&#123;color: #5AD427&#125; 4.4.选择器优先级!important &gt; 行内样式（写到元素上）&gt; id选择器 &gt; class选择器 &gt; 标签（*） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 5.其他基础知识5.1.浮动简单讲：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素，脱离文档的意思就是说浮动不会影响普通元素的布局 5.2.高度坍塌浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度。这就是高度坍塌 5.3.清除浮动的方式清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动； clear清除浮动 clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。 说明：我们是通过在别的元素上清除浮动来实现撑开高度的， 而不是在浮动元素，不要在浮动元素上清除浮动 1234567891011121314151617181920212223242526272829// 方式一：不支持IE6/7.clearfix:after &#123; display: table; content: \" \"; clear: both;&#125;// 方式二：引入了zoom以支持IE6/7.clearfix:after &#123; display: table; content: \" \"; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125;// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: \" \";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; BFC清除浮动 还没完全理解 5.4.定位 元素按照其在 HTML 中的位置顺序决定排布的过程。 HTML的布局机制就是用文档流模型的，即块元素（block）独占一行，内联元素（inline），不独占一行 使用margin是用来隔开元素与元素的间距 padding是用来隔开元素与内容的间隔 只要不是float和绝对定位方式布局的，都在文档流里面 position属性说明 static，默认值。位置设置为static的元素，它始终会处于文档流给予的位置 inherit，规定应该从父元素继承 position 属性的值 absolute，生成绝对定位的元素，相对于距该元素最近的已定位的祖先元素进行定位 relative，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位 5.5.盒子模型在一个文档中，每一个元素都被抽象成一个盒子，每一个盒子又包括四部分(从内到外):内容(content)，内填充(padding)，边框(border)，外边距(margin)；","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://caochenhins.github.io/tags/CSS/"}]},{"title":"前端基础知识学习---CSS3学习总结","slug":"前端基础知识学习-CSS3学习总结","date":"2019-03-21T14:41:50.000Z","updated":"2019-03-21T15:17:46.097Z","comments":true,"path":"2019/03/21/前端基础知识学习-CSS3学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/前端基础知识学习-CSS3学习总结/","excerpt":"CSS3学习笔记CSS3思维导图总结 前言 css的全称是什么？——casccading style sheets 样式表的组成？——选择器+声明块 浏览器杜宇编译css的顺序？——div ul li #test从右往左","text":"CSS3学习笔记CSS3思维导图总结 前言 css的全称是什么？——casccading style sheets 样式表的组成？——选择器+声明块 浏览器杜宇编译css的顺序？——div ul li #test从右往左 选择器 基本选择器 通配符选择器——* {margin:0;} 元素选择器——body {background: #eee} 类选择器——.list {list-style: square} ID选择器——#list {width: 500ox} 后代选择器——.list li {margin-top: 10px} 子元素选择器也可以叫后代直接选择器，此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素 1#wrap &gt; .inner &#123;color: pink;&#125; Html实例 123456789&lt;div id=\"wrap\"&gt; &lt;div&gt;1 &lt;div&gt;1-1&lt;/div&gt; &lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/div&gt; CSS实例 1234#wrap &gt; div&#123; color: brown; border: 5px solid;&#125; 注意：选择的是#wrap下的所有直接后代div,但是color是可继承的，所以1-1颜色也会改变，border却不会。 相邻兄弟选择器它只会匹配紧跟着的兄弟元素 1#wrap &gt; #first + .inner&#123;color: #A52A2A;&#125; Html实例 1234567&lt;div id=\"wrap\"&gt; &lt;div class=\"inner\"&gt;1&lt;/div&gt; &lt;div id=\"first\"&gt;2&lt;/div&gt; &lt;div class=\"inner\"&gt;3&lt;/div&gt; &lt;div class=\"inner\"&gt;4&lt;/div&gt; &lt;div class=\"inner\"&gt;5&lt;/div&gt;&lt;/div&gt; 注意：改变的只是3号div，如果3号之前存在一个&lt;div&gt;&lt;/div&gt;,那么将不会改变 通用兄弟选择器它会匹配所有的兄弟元素（不需要紧跟） 1#wrap #first ~div&#123;border: 1px solid cornflowerblue;&#125; 注意：HTML结构和相邻兄弟选择器一样，改变的是3,4,5号div 属性选择器存在和值属性选择器html结构 12345&lt;div id=\"wrap\"&gt; &lt;div name=\"zhangsan\"&gt;1&lt;/div&gt; &lt;div name=\"li luo\"&gt;2&lt;/div&gt; &lt;div name=\"li\"&gt;3&lt;/div&gt;&lt;/div&gt; [attr]：该选择器选择包含attr属性的所有元素，无论attr的值是什么 1div[name]&#123;border: 1px solid blueviolet;&#125; /*选中的是所有div*/ [attr = val]：该选择器仅选择attr属性被赋值val的所有元素 1div[name = \"li\"]&#123;border: 1px solid coral;&#125; /*选中的是2,3号div*/ [attr ~= val]：表示带有以attr命名的属性的元素，并且该属性是以一个空格作为分割的值列表，其中至少一个为val 1div[name ~= \"luo\"]&#123;border: 1px solid coral;&#125; /*选中的是2号div*/ 子串值属性选择器html结构 123456&lt;div id=\"wrap\"&gt; &lt;div name=\"luo-zhangsan\"&gt;1&lt;/div&gt; &lt;div name=\"li luo\"&gt;2&lt;/div&gt; &lt;div name=\"luo-li\"&gt;3&lt;/div&gt; &lt;div name=\"luoliluo\"&gt;4&lt;/div&gt;&lt;/div&gt; [attr |= val]：选择的是attr属性的值是val（包括val）或者以val-开头的元素 1div[name |= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,3号元素*/ [attr ^= val]：选择的是attr属性的值以val开头（包括val）的元素 1div[name ^= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,4号元素*/ [attr $= val]：选择的是attr属性的值以val结尾（包括val）的元素 1div[name $= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有2,4号元素*/ [attr *= val]：选择的是attr属性的值中包含字符串val的元素 1div[name *= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,2,3,4号元素*/ 伪类与伪元素选择器链接伪类:link：表示作为超链接，并指向一个为访问的地址的所有锚 :visited：表示作为超链接，并指向一个已访问的地址的所有锚 123a&#123;text-decoration: none;&#125;a:link&#123;color: deeppink;&#125;#test :link&#123;background: pink;&#125; :target：代表一个特殊元素，它的id是URL的片段标识符 :target实例-选项卡,html结构如下 1234567891011121314&lt;body&gt; &lt;a href=\"#div1\"&gt;div1&lt;/a&gt; &lt;a href=\"#div2\"&gt;div2&lt;/a&gt; &lt;a href=\"#div3\"&gt;div3&lt;/a&gt; &lt;div id=\"div1\"&gt; div1 &lt;/div&gt; &lt;div id=\"div2\"&gt; div2 &lt;/div&gt; &lt;div id=\"div3\"&gt; div3 &lt;/div&gt;&lt;/body&gt; css结构如下 12345678910111213141516171819*&#123; margin: 0; padding: 0;&#125;a&#123; text-decoration: none; color: deeppink;&#125;div&#123; width: 200px; height: 200px; background: pink; display: none; text-align: center; font: 50px/200px \"微软雅黑\";&#125;:target&#123; display: block;&#125; 注意：:link，:visited，:target是作用与链接元素的 动态伪类:hover：表示悬浮到元素上 :active：表示匹配被用户激活的元素（点击按住） 由于a标签的：link和：visited可以覆盖了所有的a标签的状态，所以当：link,:visited,:hover,:active同时出现在a标签身上时，：link和：visited不能放在最后 注意：:hover和:active基本可以作用于所有的元素 表单相关伪类:enabled：匹配可编辑的表单:disable：匹配被禁用的表单:checked：匹配被选中的表单:focus ：匹配获焦的表单 实例如下 12345678910111213input:enabled&#123; background: deeppink;&#125;input:disabled&#123; background: blue;&#125;input:checked&#123; width: 200px; height: 200px;&#125;input:focus&#123; background: darkcyan;&#125; html结构如下 123&lt;input type=\"text\" /&gt;&lt;input type=\"text\" disabled=\"disabled\" /&gt;&lt;input type=\"checkbox\" /&gt; 小例子-自定义单选按钮 123456789101112&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt; css代码如下 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;label&#123; position: relative; float: left; width: 100px; height: 100px; border: 2px solid; overflow: hidden; border-radius: 50%;&#125;label &gt; span&#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0;&#125;input&#123; position: absolute; left: -50px; top: -50px;&#125;input:checked + span&#123; background: pink;&#125; 结构性伪类选择器:nth-child(index)系列 :first-child :last-child nth-last-child(index):表示从后面开始计数 only-child(相当于:first-child:last-child或者:noth-child(1):nth-last-child(1)) :nth-child(index)实例 1234/*找到#warp底下的所有li子元素,并且选中第一个子元素，并且这个子元素必须是li*/#wrap li:nth-child(1)&#123; color: deeppink;&#125; 注意：1.index的值从1开始计数；2.index可以为变量n(只能是n)；3.index可以为even或者odd :nth-of-type系列 :first-of-type last-of-type nth-last-type(index):表示从后面开始计数 only-of-type 123#wrap li:nth-of-type(1)&#123; color: deeppink;&#125; 注意：nth-child(index)和nth-of-type(index)的区别：前者找某某下的第一个适配元素，后者找某某下的出现第一次的适配元素。 nth-child和nth-of-type的区别（坑） html结构如下 1234567&lt;div id=\"warp\"&gt; &lt;div class=\"inner\"&gt;div&lt;/div&gt; &lt;span class=\"inner\"&gt;span&lt;/span&gt; &lt;p class=\"inner\"&gt;p&lt;/p&gt; &lt;h1 class=\"inner\"&gt;h1&lt;/h1&gt; &lt;h2 class=\"inner\"&gt;h2&lt;/h2&gt;&lt;/div&gt; 使用nth-child如下，这个没什么问题，选中的是#warp下的class为.inner的第一个元素div 123#warp .inner:nth-child(1)&#123; color: deeppink;&#125; 使用nth-of-type如下，选中的却是所有元素，这是因为nth-of-type是以元素为中心 123#warp .inner:nth-of-type(1)&#123; color: deeppink;&#125; not 123div &gt; a:not(:last-of-type)&#123; border-right: 1px solid red;&#125; enpty(内容必须是空的，有空格都不行) 伪元素选择器伪元素包含这几种，::after，::before，::firstLetter，::firstLine，::selection ::after实例如下 1234567#warp::after&#123; content: \"\"; display: block; width: 200px; height: 200px; background: deeppink;&#125; ::firstLetter实例如下:将第一个字改变 1&lt;div&gt;我是谁？&lt;/div&gt; 12345div::first-letter&#123; color: deeppink; font-size: 24px; font-weight: bold;&#125; ::firstLine实例如下：将第一行改变 1234&lt;div&gt; 我是谁？&lt;br&gt; 我来自哪里？&lt;br&gt;&lt;/div&gt; 12345div::first-line&#123; color: deeppink; font-size: 24px; font-weight: bold;&#125; ::selection实例如下：改变鼠标选中时的状态 1&lt;div&gt;我是谁？我来自哪里？&lt;/div&gt; 1234div::selection&#123; color: deeppink; background: white;&#125; 自定义字体实例如下 1234@font-face &#123; font-family:; src: url();&#125; 新增UI方案文本新增样式opacity：改变透明度123456789101112#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: pink; opacity: 0.1;&#125;#inner&#123; width: 100px; height: 100px; background: deeppink;&#125; 12345&lt;div id=\"warp\"&gt; &lt;div id=\"inner\"&gt; inner &lt;/div&gt;&lt;/div&gt; 新增颜色模式rgba123456#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: rgba(0,0,0,.8);&#125; 说明：rgba其实就是rgb颜色加一个透明度 实例，背景透明，文字不透明12345678910#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: rgba(0,0,0,0.8); color: #FFFFFF; font-size: 30px; line-height: 300px; text-align: center;&#125; 如果是文字透明，背景不透明，将color换成rgba,background使用#形式的颜色模式 文字阴影text-shadow用来为文字添加阴影，而且可以添加多层，阴影之间用逗号隔开（多个阴影时，第一个在最上面） 12345h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; text-shadow: gray 10px 10px 10px;&#125; 实例-浮雕文字123456h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; color: white; text-shadow: black 1px 1px 10px;&#125; 实例-文字模糊效果12345678910h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; color: black; transition: 1s;&#125;h1:hover&#123; color: rgba(0,0,0,0); text-shadow: black 0 0 100px;&#125; 实例-模糊背景12345678910111213141516171819#warp&#123; height: 100px; background: rgba(0,0,0,.5); position: relative;&#125;#warp #bg&#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0; background: url(img/2_1.jpg) no-repeat; background-size: 100% 100%; z-index: -1; filter: blur(10px);/*元素模糊*/&#125;img&#123; margin: 24px 0 0 24px;&#125; 1234&lt;div id=\"warp\"&gt; &lt;img src=\"img/2_1.jpg\" width=\"64\" height=\"64\" /&gt; &lt;div id=\"bg\"&gt;&lt;/div&gt;&lt;/div&gt; 文字描边123456h1&#123; font: 100px/200px \"微软雅黑\"; text-align: center; color: white; -webkit-text-stroke: pink 4px;&#125; 文字排版实例，省略过长内容显示为… 123456789div&#123; width: 200px; height: 100px; border: 1px solid; margin: 0 auto; white-space: nowrap;/*不换行*/ overflow: hidden;/*省略溢出内容*/ text-overflow: ellipsis;&#125; 注意：这个的使用的前提是：不能让元素的大小靠内容撑大，也就是不能使用display: inline;属性 盒模型新增样式盒模型阴影1box-shadow: inset 10px 10px 10px 0px black ; 说明：box-shadow较text-shadow多了两个参数，第一个是阴影方向，第五个是阴影大小 1234567891011121314151617#warp&#123; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; width: 100px; height: 100px; background: pink;/*以上所有样式就是让盒子水平和垂直居中*/ text-align: center; line-height: 100px; transition: 1s;&#125;#warp:hover&#123; box-shadow: 10px 10px 10px 0px black ;&#125; 倒影-webkit-box-reflect1234img&#123; vertical-align: middle; -webkit-box-reflect: right;&#125; resize:允许你控制一个元素的可调整性，需要overflow：auto配合使用 12345678#warp&#123; display: inline-block; width: 200px; height: 200px; background: pink; resize: both; overflow: auto;&#125; box-sizingbox-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素， 123456789#warp &gt; div&#123; margin: 10px; width:130px ; height: 130px; background: deeppink; float: left; border: 1px solid; box-sizing: border-box;&#125; 在上面的css代码中使用 float: left;如果要使用 border: 1px solid;就必须添加box-sizing: border-box;才不会改变布局 新增UI样式圆角12345678910111213#warp&#123; position: absolute; height: 70px; width: 200px; border: 1px solid; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ border-radius: 30px;&#125; border-radius: 30px;这种是简写方式，border-radius: 30px 20px 10px 40px; 是分别对应四角的写法 注意：圆角最好使用px值，不要使用百分比 圆角实例-旋转的风车1234567891011121314151617181920212223242526272829303132333435363738*&#123; margin: 0; padding: 0;&#125;html,body&#123; height: 100%; overflow: hidden;/*这两个是禁止滚动条*/&#125;#warp&#123; position: absolute; height: 300px; width: 300px; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ transition: 2s;&#125;#warp &gt; div&#123; margin: 10px; width:130px ; height: 130px; background: deeppink; float: left; border: 1px solid; box-sizing: border-box;&#125;#warp &gt; div:nth-child(1),#warp &gt; div:nth-child(4)&#123; border-radius: 0 60%;&#125;#warp &gt; div:nth-child(2),#warp &gt; div:nth-child(3)&#123; border-radius: 60% 0;&#125;#warp:hover&#123; transform: rotate(120deg);/*旋转函数*/&#125; 123456&lt;div id=\"warp\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 边框图片1234567891011121314151617#warp&#123; position: absolute; height: 200px; width: 200px; border: 1px solid; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ border: 50px solid; border-image-source: url(img/border-image.png); border-image-slice: 33.3333%; border-image-repeat: round; border-image-width: 20px;&#125; 1&lt;div id=\"warp\"&gt;&lt;/div&gt; 线性渐变双颜色值的线性渐变 1background-image:linear-gradient(red,blue); 多颜色值的线性渐变 1background-image:linear-gradient(red,blue,pink,black); 改变渐变方向 1background-image:linear-gradient(to top left,red,blue); 使用角度 1background-image:linear-gradient(0deg,red,blue); 控制颜色节点的分布 1background-image:linear-gradient(90deg,red 10%,orange 15%,yellow 20%,green 30%,blue 50%,indigo 70%,violet 80%); 透明度的渐变 1background-image:linear-gradient(90deg,rgba(255,0,0,0) 50%,rgba(255,0,0,0.5),rgba(255,0,0,1) 60%); 重复渐变 1background: repeating-linear-gradient(90deg,red 10%,blue 30%); 渐变实例-发廊灯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; overflow: hidden; &#125; #warp&#123; height: 300px; width: 40px; border: 1px solid; margin: 100px auto; overflow: hidden; &#125; #warp &gt; .inner&#123; height: 600px;/*这是是颜色所在的高度。远比能看见的要高*/ background: repeating-linear-gradient(135deg,black 0px,black 10px,white 10px,white 20px); &#125; #warp:hover .inner&#123; margin-top: -300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"warp\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var inner = document.querySelector(\"#warp &gt; .inner\");/*获取元素*/ var flag = 0;/*循环结束后归零*/ setInterval(function()&#123; flag++; if(flag == 300)&#123; flag = 0; &#125; inner.style.marginTop = -flag+\"px\"; &#125;,1000/60)/*设置定时器循环*/ &lt;/script&gt;&lt;/html&gt; 渐变实例-光斑动画1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; overflow: hidden; background: black; text-align: center;/*配合h1的display: inline-block;属性让h1这个元素居中*/ &#125; h1&#123; display: inline-block; color: rgba(255,255,255,.3); font: bold 80px \"微软雅黑\"; background: linear-gradient(120deg,rgba(255,255,255,0) 100px,rgba(255,255,255,1) 180px,rgba(255,255,255,0) 260px); background-repeat: no-repeat; -webkit-background-clip: text; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;码酱博客-专注与总结分享&lt;/h1&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var h1 = document.querySelector(\"h1\");/*获取元素*/ var flag = -160;/*循环结束后归零*/ setInterval(function()&#123; flag+=10; if(flag == 900)&#123; flag = -160; &#125; h1.style.backgroundPosition = flag+\"px\"; &#125;,30)/*设置定时器循环*/ &lt;/script&gt;&lt;/html&gt; 径向渐变双颜色值的径向渐变 1background-image:radial-gradient(red,blue); 多颜色值的径向渐变 1background-image: radial-gradient(red,blue,pink,black); 不均匀分布 1background-image:radial-gradient(red 50%,blue 70%); 改变渐变形状 1background-image:radial-gradient(ellipse,red,blue); 渐变形状的尺寸大小 1background-image:radial-gradient(farthest-corner ellipse,red,blue); 改变圆心 1background-image:radial-gradient(closest-corner circle at 10px 10px,red,blue); 重复渐变 1background-image:repeating-radial-gradient(closest-corner circle,red 30%,blue 50%); 过渡transition CSS transition 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义 transition是一个简写属性，用于 transition-property,transition-duration,transition-timing-function, 和transition-delay。 注意：在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay transition分为一下属性：transition-property，transition-duration，transition-timing-function，transition-delay transition-property指定应用过渡属性的名称，默认值为 all，表示所有可被动画的属性都表现出过渡动,可以指定多个 property 注意：不是所有的属性都可以添加动画过渡的，过渡时间必须带单位s秒 那些属性可以添加动画过渡，参看这个连接 默认值： none： 没有过渡动画。 all ：所有可被动画的属性都表现出过渡动画。 transition-duration属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s (一定要带单位)，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 默认值： 属性值： 以毫秒或秒为单位的数值&lt;time&gt; 类型。表示过渡属性从旧的值转变到新的值所需要的时间。 如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。一定要加单位(不能写0 一定要写0s 1s,0s,1s)！ transition-timing-functionCSS属性受到 transition的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变 属性值： ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier： 贝塞尔曲线 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(&lt;integer&gt;,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） transition-delay规定了在过渡效果开始作用之前需要等待的时间。默认值：0s; 你可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始 当属性值的列表长度不一致时1234transition-property: background,width,height;transition-duration: 3s,2s;transition-delay:3s,2s;transition-timing-function:linear; 实际效果如下 1234transition-property: background,width,height;transition-duration: 3s,2s,3s;transition-delay:3s,2s,3s;transition-timing-function:linear,ease,ease; 说明： 1.超出的情况下是会被全部截掉的2.不够的时候，关于时间的会重复列表，transition-timing-function的时候使用的是默认值ease 2D变换（变形）transformtransform 属性允许你修改CSS视觉格式模型的坐标空间，transform 属性 , 只对 block 级元素生效！ 旋转（rotate） 平移（translate） 倾斜（skew） 缩放（scale） 基点的变换 矩阵（matrix） 旋转 平移 倾斜 缩放 旋转（rotate）1transform:rotate(angle); 正值:顺时针旋转 rotate(360deg), 负值:逆时针旋转 rotate(-360deg) 只能设单值。正数表示顺时针旋转，负数表示逆时针旋转 平移（translate）X方向平移:transform: translateX(tx)，Y方向平移:transform: translateY(ty)二维平移：transform: translate(tx, ty)； 如果ty没有指定，它的值默认为0。 说明：可设单值，可设双值，正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变， 12transform: translate(100px,200px);// 斜着移动transform: translate(100px,0); 倾斜（skew）X方向倾斜:transform: skewX(angle) 1transform: skewX(45deg) // 参数值以deg为单位 代表与y轴之间的角度 Y方向倾斜:transform: skewY(angle) 1transform: skewY(45deg) // 参数值以deg为单位 代表与x轴之间的角度 二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜 1transform:skew(45deg,15deg);// 第一个参数代表与y轴之间的角度, 第二个参数代表与x轴之间的角度 缩放（scale）X方向缩放:transform: scaleX(sx); 1transform: scaleX(2); Y方向缩放:transform: scaleY(sy); 1transform: scaleY(.5); 二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 1transform: scale(2,.5); 要缩小请设0.01～0.99之间的值，要放大请设超过1的值。单值时表示只X轴,Y轴上缩放粒度一样，如transform: scale(2);等价于transform: scale(2,2); 注意：以上的变换都是基于中心原点变换，改变基点，使用transform-origin: 100% 100%;属性 基点变换transform-origintransform-origin CSS属性让你更改一个元素变形的基点。 矩阵（matrix）在 2D变换 中，矩阵变换函数 matrix() 接受 6个值，语法形式如下：transform: matrix(a, b, c, d, e, f); 对某一元素应用旋转变换 rotate(θ)，使用矩阵实现 matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0) 对某一元素应用旋转变换 translate(X, Y)，使用矩阵实现： matrix(1, 0, 0, 1, X, Y) 对某一元素应用倾斜变换 skew(α, β)，使用矩阵变换函数 matrix(1, tanβ, tanα,1, 0, 0)。 对某一元素应用缩放变换 scale(scaleX, scaleY)，使用矩阵变换函数 matrix(scaleX, 0, 0, scaleY, 0, 0) 3D变形在浏览器中，X轴是从左到右，Y轴是从上到下，Z轴是从里到外 3D缩放transform: scale3d(scaleX,scaleY,scaleZ);或者transform: scaleZ(number) 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 3D旋转CSS3中的3D旋转主要包括四个功能函数：rotateX(angle)、 rotateY(angle)、rotateZ(angle)、rotate3d(x,y,z,angle) x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值 3D平移transform: translateZ(length)是3D Transformaton特有的，其他两个2D中就有 translateZ 它不能是百分比值; 那样的移动是没有意义的。 transform: translate3d(translateX,translateY,translateZ); translateZ 它不能是百分比值; 那样的移动是没有意义的。 景深（perspective）动画（Animation）css3动画就是使元素从一种样式逐渐变化为另一种样式的效果，animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 关键帧（@keyframes）语法如下： 12345 @keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125; animiationName:必写项，定义动画的名称, keyframes-selector：必写项，动画持续时间的百分比， from：0%to：100%， css-style：css声明 示例如下： 1234567891011#wran&#123; animation-name :move&#125;@keyframes move&#123; from&#123; transform:rotate(0deg); &#125; to&#123; transform:rotate(360deg); &#125;&#125; animation-nameanimation-name属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 animation-durationanimation-duration属性指定一个动画周期的时长。默认值为0s，表示无动画。一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 注意：负值无效，浏览器会忽略该声明，但是一些早起的带前缀的声明会将负值当作0s animation-timing-functionanimation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始，到关键帧结束。动画的默认效果：由慢变快再变慢 linear:线性过渡，等同于贝塞尔曲线（0,0,1,1） ease:平滑过渡，等同于贝塞尔曲线（0.25,0.1,0.25,1.0） ease-in:由慢到快，等同于贝塞尔曲线（0.42,0,1,1） ease-out:由快到慢，等同于贝塞尔曲线（0,0,0.58,1） ease-in-out:由慢到快再到慢，等同于贝塞尔曲线（0.42,0,0.58,1） cubic-bezier(1,1,2,3) steps(n,[start|end]) 传入一到两个参数，第一个参数意思是把动画分成 n 等分，然后动画就会平均地运行。 第二个参数 start 表示从动画的开头开始运行，相反，end 就表示从动画的结尾开始运行， 默认值为 end。 animation-delay定义动画开始前等待的时间,以秒或毫秒计(属于动画外的范畴),值为time, 从动画样式应用到元素上到元素开始执行动画的时间差。该值可用单位为秒(s)和毫秒(ms)。如果未设置单位，定义无效 animation-iteration-count定义了动画执行的次数（属于动画内的范畴）,值为infinite表示 无限循环播放动画.&lt;number&gt;表示动画播放的次数 不可为负值. animation-direction定义了动画执行的方向 normal： 每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，默认属性。 alternate：动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向， 比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭 代 reverse：反向运行动画，每周期结束动画由尾到头运行。 alternate-reverse：反向交替， 反向开始交替 animation-fill-mode属于动画外的范畴，定义动画在动画外的状态 animation-play-state定义了动画执行的运行和暂停， running表示当前动画正在运行。paused表示当前动画以被停止。 布局扩展老版本布局CSS3 弹性盒子(Flexible Box 或 Flexbox)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行/列。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。 老版本的我们通常称之为box， 新版本的我们通常称之为flex 注意：项目永远在主轴的正方向排列 老版容器的布局方向 -webkit-box-orient: horizontal; x轴 -webkit-box-orient: vertical; y轴 123display: -webkit-box;/*-webkit-box-orient属性控制的主轴是那个*/-webkit-box-orient: vertical; 注意：项目永远在主轴的正方向排列 老版容器的排列方向 -webkit-box-direction: normal; -webkit-box-direction: reverse; -webkit-box-direction属性本质上改变了主轴的方向 1234display: -webkit-box;-webkit-box-orient: vertical;/*-webkit-box-direction控制主轴的方向*/-webkit-box-direction: reverse; 老版本富裕空间管理（主轴上）1-webkit-box-pack:start; 不会给项目区分配空间，只是确定富裕空间的位置 start：表示富裕空间在右边 end：表示富裕空间在左边 center：表示富裕空间在两边 justify：表示富裕空间在项目之间 老版本富裕空间管理（侧轴上）1-webkit-box-align:center; /*不会给项目区分配空间，只是确定富裕空间的位置*/ start：侧轴为x轴，富裕空间位于右边，侧轴为y轴，富裕空间位于下边 end：侧轴为x轴，富裕空间位于左边，侧轴为y轴，富裕空间位于上边 center ：富裕空间位于两边 新版本flex布局新版本的布局方向 flex-direction: row; flex-direction: column; 123display: flex;/*flex-direction决定主轴方向*/flex-direction: row; 新版本的排列方向 flex-direction:row-reverse; flex-direction:column-reverse; 123display: flex;/*flex-direction既控制主轴是那个，也控制主轴方向*/flex-direction: row-reverse 新版本富裕空间管理（主轴上）1justify-content: flex-start; /*更强大的富裕空间的管理（主轴）*/ flex-start：富裕空间在主轴的正方向 flex-end：富裕空间在主轴的反方向 center：富裕空间在主轴的两边 space-between：富裕空间在项目之间 space-around(box 没有的)：富裕空间在项目两边 新版本富裕空间管理（侧轴上）1align-items: stretch; flex-start：富裕空间在侧轴的正方向 flex-end：富裕空间在侧轴的反方向 center：富裕空间在侧轴的两边 baseline(box 没有的)：按照基线对齐 stretch(box 没有的)：等高布局 有关布局的HTML结构如下 1234567&lt;div id=\"warp\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;div class=\"item\"&gt;5&lt;/div&gt;&lt;/div&gt; 说明：id=”warp”为容器，&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;为项目 flex布局总结 明确什么是容器，什么是项目，什么是主轴，什么是侧轴 项目永远排列在主轴上 flex布局分为两个版本：-webkit-box-和flex 老版本容器 容器的布局方向：-webkit-box-orient:horizontal/vertical,控制主轴是哪一根， horizontal：x轴，vertical ：y轴 容器的排列方向：-webkit-box-direction：normal/reverse控制主轴的方向， normal：从左往右（正方向）reverse：从右往左（反方向） 富裕空间的管理：只决定富裕空间的位置，不会给项目区分配空间 主轴：-webkit-box-pack 主轴是x轴 start：在右边 end: 在左边 center：在两边 justify：在项目之间 主轴是y轴 start：在下边 end：在上边 center：在两边 justify：在项目之间 侧轴：-webkit-box-algin 侧轴是x轴 start：在右边 end： 在左边 center：在两边 侧轴是y轴 start：在下边 end： 在上边 center：在两边 项目 弹性空间管理：-webkit-box-flex：弹性因子（默认值为0） 新版本容器容器的布局方向和容器的排列方向使用一个属性flex-direction,控制主轴是哪一根，控制主轴的方向 row; 从左往右的x轴 row-reverse;从右往左的x轴 column; 从上往下的y轴 column-reverse;从下往上的y轴 富裕空间的管理：只决定富裕空间的位置，不会给项目区分配空间 主轴justify-content flex-start： 在主轴的正方向 flex-end: 在主轴的反方向 center： 在两边 space-between： 在项目之间 space-around： 在项目两边 侧轴align-items flex-start：在侧轴的正方向 flex-end： 在侧轴的反方向 center： 在两边 baseline 基线对齐 stretch 等高布局（项目没有高度） 新版flex布局详解容器 flex-wrap：控制的是侧轴的方向 123align-items: flex-start;/*对单行单列的富裕空间管理*/flex-wrap: wrap-reverse;/*当容器的宽度小于项目的宽度时控制是否换行显示，也就是控制侧轴的方向*/align-content: flex-start;/*对多行多列富裕空间的管理*/ align-content 属性定义弹性容器的侧轴方向上有额外空间时，如何排布每一行/列。当弹性容器只有一行/列时无作用 align-content值如下： flex-start：所有行/列从侧轴起点开始填充。第一行/列的侧轴起点边和容器的侧轴起点边对齐。 接下来的每一行/列紧跟前一行/列。 flex-end：所有弹性元素从侧轴末尾开始填充。最后一个弹性元素的侧轴终点和容器的侧轴终点对齐。同时所有后续元素与前一个对齐。 center：所有行/列朝向容器的中心填充。每行/列互相紧挨，相对于容器居中对齐。 容器的侧轴起点边和第一行/列的距离相等于容器的侧轴终点边和最后一行/列的距离。 space-between：所有行/列在容器中平均分布。相邻两行/列间距相等。 容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的边对齐。 space-around：所有行/列在容器中平均分布，相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的距离是相邻两行/列间距的一半。 stretch：拉伸所有行/列来填满剩余空间。剩余空间平均的分配给每一行/列 flex-flow 属性 flex-flow 属性是设置“flex-direction”和“flex-wrap”的简写,默认值：row nowrap 不可继承 控制主轴和侧轴的位置以及方向 项目order 属性 order 属性规定了弹性容器中的可伸缩项目在布局时的顺序。元素按照 order 属性的值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局,order越大越后 123456#warp &gt; .item:nth-child(1)&#123; order: 5;&#125;#warp &gt; .item:nth-child(2)&#123; order: 3;&#125; align-self 属性 align-self 会对齐当前 flex 行中的 flex 元素，并覆盖 align-items 的值. 如果任何 flex 元素的侧轴方向 margin 值设置为 auto，则会忽略 align-self。 auto：设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch。 flex-start：flex 元素会对齐到 cross-axis 的首端。 flex-end：flex 元素会对齐到 cross-axis 的尾端。 center： flex 元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出。 baseline：所有的 flex 元素会沿着基线对齐， stretch：flex 元素将会基于容器的宽和高，按照自身 margin box 的 cross-size 拉伸 12345678#warp &gt; .item:nth-child(2)&#123; order: 3; align-self: flex-end;&#125;#warp &gt; .item:nth-child(3)&#123; order: 2; align-self: center;&#125; flex-shrink属性 flex-grow 属性定义弹性盒子项（flex item）的拉伸因子。 可用空间 = (容器大小 - 所有相邻项目flex-basis的总和) 可扩展空间 = (可用空间/所有相邻项目flex-grow的总和) 每项伸缩大小 = (伸缩基准值 + (可扩展空间 x flex-grow值)) flex-shrink 属性指定了 flex 元素的收缩因子 默认值为1 计算收缩因子与基准值乘的总和 计算收缩因数： 收缩因数=（项目的收缩因子*项目基准值）/第一步计算总和 移除空间的计算：移除空间= 项目收缩因数 x 负溢出的空间 flex-basis属性 flex-basis 指定了 flex 元素在主轴方向上的初始大小，默认值 ：auto 不可继承 注意： 在flex简写属性中 flex-basis的默认值为0 flex实例等分布局 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; #warp&#123; width:500px; height: 300px; border: 1px solid; margin: 100px auto; display: flex; &#125; #warp &gt; .item&#123; height: 50px; background: pink; text-align: center; line-height: 50px; flex-shrink: 1; flex-grow: 1;/*将富裕空间等分，并没有将项目等分*/ flex-basis: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"warp\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;22&lt;/div&gt; &lt;div class=\"item\"&gt;333&lt;/div&gt; &lt;div class=\"item\"&gt;4444&lt;/div&gt; &lt;div class=\"item\"&gt;55555&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex简写属性语法糖 12345flex-shrink: 1;flex-grow: 1;/*将富裕空间等分，并没有将项目等分*/flex-basis: 0;/*上述三个属性和下列属性语法一样*/flex: 1; 等分布局实例，天猫导航栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; a&#123; text-decoration: none; color: gray; display: block;/*设置a标签不仅仅是可以点击文字，还可以点击div块*/ &#125; #nav .row&#123; display: flex; &#125; #nav &gt;.row &gt; .item&#123; flex: 1; text-align: center; &#125; #nav &gt; .row &gt; .item &gt; a:before&#123; content: \"\"; display: block; width: 86px; height: 86px; margin: 0 auto; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(1) &gt; a:before&#123; background: url(../img/01.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(2) &gt; a:before&#123; background: url(../img/02.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(3) &gt; a:before&#123; background: url(../img/03.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(4) &gt; a:before&#123; background: url(../img/04.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(5) &gt; a:before&#123; background: url(../img/05.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(1) &gt; a:before&#123; background: url(../img/06.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(2) &gt; a:before&#123; background: url(../img/07.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(3) &gt; a:before&#123; background: url(../img/08.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(4) &gt; a:before&#123; background: url(../img/09.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(5) &gt; a:before&#123; background: url(../img/10.png) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"nav\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;聚划算&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫国际&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;外卖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫超时&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;充值中心&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫旅行&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;领金币&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;拍卖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;分类&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://caochenhins.github.io/tags/CSS/"}]},{"title":"vue","slug":"vue","date":"2019-03-21T14:41:25.000Z","updated":"2019-03-21T15:17:59.799Z","comments":true,"path":"2019/03/21/vue/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/vue/","excerpt":"一、Vue核心知识1.1.Vue的基本简介学习一门技术首先登陆其官网，中文网址，英文网址，vue是一款渐进式JavaScript框架，作用是为了动态构建用户界面，该框架遵循MVVM模式，编码简洁，体积小，运行效率高；他借鉴了angular的模板和数据绑定技术，借鉴了react的组件化和虚拟DOM技术，当然，该技术也存在一个Vue全家桶，例如vue脚手架：vue-cli，ajax请求：vue-resource，路由：vue-router，状态管理：vuex，图片懒加载：vue-lazyload，移动端UI组件库：min-ui，PC端组件库：element-ui，页面滑动：vue-scroller等等插件；","text":"一、Vue核心知识1.1.Vue的基本简介学习一门技术首先登陆其官网，中文网址，英文网址，vue是一款渐进式JavaScript框架，作用是为了动态构建用户界面，该框架遵循MVVM模式，编码简洁，体积小，运行效率高；他借鉴了angular的模板和数据绑定技术，借鉴了react的组件化和虚拟DOM技术，当然，该技术也存在一个Vue全家桶，例如vue脚手架：vue-cli，ajax请求：vue-resource，路由：vue-router，状态管理：vuex，图片懒加载：vue-lazyload，移动端UI组件库：min-ui，PC端组件库：element-ui，页面滑动：vue-scroller等等插件； 1.2.Vue的基本使用1234567891011121314&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"username\"&gt; &lt;p&gt;Hello &#123;[username]&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //创建Vue实例 const vm = new Vue(&#123; // 配置对象 el:'#app', // element:选择器 data:&#123; //数据（Model） username:'世界' &#125; &#125;)&lt;/script&gt; vue的HelloWord编码说明 使用vue首先引入Vue.js，然后创建Vue对象，其中el表示指定的根element选择器，data是指初始化数据，双向数据绑定使用v-model，显示数据使用语法：{[xxx]}； vue的MVVM的体现就是：model代表模型，上述代码就是数据对象（data）,view代表视图，就是vue中的模板页面，viewModel代表是视图模型（vue实例）； 1.3.模板语法所谓的模板就是动态的Html页面，包含了一些JS语法代码，在Vue中使用双大括号表达式和指令（以v-开头的自定义标签属性）； 双大括号表达式 语法是：{xxx}，作用就是向页面输出数据，可以调用对象的方法，例如{msg.toUpperCase()}； 指令：强制数据绑定 1234567891011121314151617&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;[msg]&#125;&lt;/p&gt; &lt;p&gt;&#123;&#125;&#123;msg.toUpperCase()]&#125;&lt;/p&gt; &lt;img src=\"imgSrc\" alt=\"\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; msg: 'Hello Word', imgSrc: 'http://image.luokangyuan.com/1.jpg' &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 上述代码中的img标签的src属性不会获取到data中定义的imgSrc属性的值，这个时候就需要使用指令强制数据绑定，功能就是指定变化的属性值，完整写法是：v-bind:src=&#39;imgSrc&#39;，一般采用简洁写法：:src=&#39;imgSrc&#39;；正确写法如下： 1&lt;img :src=\"imgSrc\" alt=\"\"&gt; 指令：绑定事件监听 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click = 'test1'&gt;test1&lt;/button&gt; &lt;button v-on:click = 'test2(msg)'&gt;test2&lt;/button&gt; &lt;button @click = 'test'&gt;test&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; msg: 'Hello Word', imgSrc: 'http://image.luokangyuan.com/1.jpg' &#125;, methods: &#123; test1() &#123; alert(123) &#125;, test2(content) &#123; alert(content) &#125;, test() &#123; alert(123) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 绑定事件监听指令的作用就是绑定指定事件名的回调函数，完整写法：v-on:click=&#39;xxx&#39;或者v-on:click=&#39;xxx(参数)&#39;再或者v-on:click.enter=&#39;xxx&#39;，简洁写法就是：@click=&#39;xxx&#39;，使用@符号； 1.4.计算属性和监视计算属性 在computed属性对象中定义计算属性的方法，在页面中使用{方法名}来显示计算的结果； 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=\"app\"&gt; 姓：&lt;input type=\"text\" placeholder=\"姓氏\" v-model=\"firstName\"&gt;&lt;br&gt; 名：&lt;input type=\"text\" placeholder=\"名字\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名1（单向）：&lt;input type=\"text\" placeholder=\"姓名1\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名2（单向）：&lt;input type=\"text\" placeholder=\"姓名2\"&gt;&lt;br&gt; 姓名3（双向）&lt;input type=\"text\" placeholder=\"姓名3双向\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; firstName: 'A', lastName: 'B' //如果将 fullName1写在这个地方，那么改变firstName和lastName的值并不会同时改变fullName1的值 // 所以需要使用到计算属性，将fullName1写入computed属性对象中，将方法的返回值作为输出值 // fullName1：'A B' &#125;, computed: &#123; // 这个f方法在初始化会执行，当相关属性发生改变时也会执行 fullName1() &#123; // 计算属性中的一个方法，方法的返回值作为属性值 return this.firstName + ' ' + this.lastName &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 计算属性的get和set 使用计算属性实现上述的双向绑定，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=\"app\"&gt; 姓：&lt;input type=\"text\" placeholder=\"姓氏\" v-model=\"firstName\"&gt;&lt;br&gt; 名：&lt;input type=\"text\" placeholder=\"名字\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名3（双向）&lt;input type=\"text\" placeholder=\"姓名3双向\" v-model=\"fullName3\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; firstName: 'A', lastName: 'B' // fullName1：'A B' &#125;, computed: &#123; fullName3: &#123; // 回调函数：你定义的，你没有调用，但最终他执行了 // 回调函数，当需要读取当前属性值时回调，根据相关的数据计算并返回当前属性的值 get()&#123; return this.firstName + ' ' + this.lastName &#125;, // 回调函数，监视当前属性的变化，当属性值发生改变时回调，更新相关的属性数据 set(value)&#123; const names = value.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 注意：计算属性存在缓存，多次读取只执行一次getter计算； 监视 通过vm对象的$watch()方法或者watch配置来监视某一个属性的值是否发生变化，当属性发生变化时，通过执行回调函数来执行相关的功能，下面的代码是使用计算属性完成的同一个功能， 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id=\"app\"&gt; 姓：&lt;input type=\"text\" placeholder=\"姓氏\" v-model=\"firstName\"&gt;&lt;br&gt; 名：&lt;input type=\"text\" placeholder=\"名字\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名2（单向）：&lt;input type=\"text\" placeholder=\"姓名2\" v-model=\"fullName2\"&gt;&lt;br&gt; 姓名3（双向）&lt;input type=\"text\" placeholder=\"姓名3双向\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'A', lastName: 'B', fullName2: 'A B' &#125;, watch: &#123; // 这个方法就是监视firstName，值发生改变是被调用执行函数 // 函数可以传入两个参数代表新值和改变之前的值，也可以传一个，也可以不传 firstName: function(value)&#123; this.fullName2 = value+ ' ' + this.lastName &#125; &#125; &#125;) vm.$watch('lastName',function(value)&#123; this.fullName2 = this.firstName + ' ' + value &#125;)&lt;/script&gt;&lt;/body&gt; 1.5.class和style绑定在某些页面中，某些元素的样式是动态发生变化的，class和style绑定就是用来实现动态改变样式效果的技术，其中class绑定中，表达式可以是字符串，可以是对象，也可以是数组，实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;class和style绑定&lt;/title&gt; &lt;style&gt; .aClass&#123;color: red&#125; .bClass&#123;color: blue&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;class绑定&lt;/h1&gt; &lt;p :class=\"a\"&gt;我是字符串&lt;/p&gt; &lt;p :class=\"&#123;aClass: isA,bClass: isB&#125;\"&gt;我是对象&lt;/p&gt; &lt;!--class绑定的是对象。当为true才会留下--&gt; &lt;h1&gt;style绑定&lt;/h1&gt; &lt;p :style=\"&#123;color: activeColor, fontSize: fontSize+'px'&#125;\"&gt;我是style强制绑定&lt;/p&gt; &lt;button @click='update'&gt;更新&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; a: 'aClass', isA: true, isB: false ,// 以上是绑定class activeColor: 'red', // 以下是绑定style fontSize : 20 &#125;, methods: &#123; update()&#123; this.a = 'bClass'; this.isA = false; this.isB = true;// 以上是绑定class this.activeColor = 'blue'; this.fontSize = 30; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.6.条件渲染在vue中条件渲染使用v-if、v-else和v-show指令，二者不同的地方在于v-if是不会生成不应该显示的元素，v-show是通过css控制隐藏不应该显示的节点元素，是在页面生成的，当需要频繁的切换时，使用v-show比较好，当条件不成立时，v-is的所有子节点也不会被解析； 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-if = 'ok'&gt;显示成功&lt;/p&gt; &lt;p v-else&gt;显示失败&lt;/p&gt; &lt;p v-show = 'ok'&gt;显示成功-v-show&lt;/p&gt; &lt;p v-show = '!ok'&gt;显示失败-v-show&lt;/p&gt; &lt;button @click='ok=!ok'&gt;切换&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; ok: false &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.7.列表渲染列表的渲染使用的是v-for指令，可以渲染数组和对象，注意的是遍历的时候指定唯一的index或者key，另外在做数组的删除和更新操作时使用数组的变异方法，有关vue的数组变异方法可以参考官方API； 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;v-for遍历数组&lt;/h2&gt; &lt;ui&gt; &lt;li v-for=\"(u,index) in users\" ::key=\"index\"&gt; &#123;[index]&#125;====&#123;[u.name]&#125;====&#123;[u.age]&#125;== &lt;button @click='deleteUser(index)'&gt;删除&lt;/button&gt;==&lt;button @click=\"updateUser(index,&#123;name: '王八',age: 45&#125;)\"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ui&gt; &lt;h2&gt;v-for遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(value,key) in users[1]\" :key=\"key\"&gt; &#123;[value]&#125;===&#123;[key]&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; users: [ // vue本身只是监视了users的改变，没有监视数组内部数据的改变 &#123;name: '张三',age: 23&#125;, &#123;name: '李四',age: 56&#125;, &#123;name: '王五',age: 76&#125;, &#123;name: '赵六',age: 87&#125;, &#123;name: '陈七',age: 34&#125; ] &#125;, methods: &#123; deleteUser(index)&#123; this.users.splice(index,1); &#125;, updateUser(index,value)&#123; // 如果只写 this.users[index] = value这一条语句，只改变了数组内部的数据，如果不调用vue的变异方法，就不会更新页面 // vue重写了数组中的一系列方法，重写后就是改变数组操作，然后重新渲染页面，也就是实现的数据绑定 this.users.splice(index,1,value) ; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 列表渲染-列表过滤和排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"searchName\"&gt; &lt;ui&gt; &lt;li v-for=\"(u,index) in filterUsers\" ::key=\"index\"&gt; &#123;[index]&#125;====&#123;[u.name]&#125;====&#123;[u.age]&#125; &lt;/li&gt; &lt;/ui&gt; &lt;button @click=\"setOrderType(1)\" &gt;年龄升序&lt;/button&gt; &lt;button @click=\"setOrderType(2)\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"setOrderType(0)\"&gt;原本排序&lt;/button&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; searchName: '', orderType: 0, // 0代表原本，1代表升序，2代表降序 users: [ // vue本身只是监视了users的改变，没有监视数组内部数据的改变 &#123;name: '张三',age: 23&#125;, &#123;name: '李四',age: 56&#125;, &#123;name: '张五',age: 76&#125;, &#123;name: '赵六',age: 87&#125;, &#123;name: '陈七',age: 34&#125; ] &#125;, computed: &#123; filterUsers() &#123; const &#123;searchName,users,orderType&#125; = this;// 取到相关数据（searchName和users） let fusers; // 定义最终返回的数组 fusers = users.filter(u =&gt; u.name.indexOf(searchName) !==-1);// 对users进行过滤 // 对fusers排序 if(orderType !== 0)&#123; fusers.sort(function(u1,u2)&#123; // 如果返回负数p1在前，返回正数p2在前 // 1.代表升序,2.代表降序 if(orderType == 2)&#123; return u2.age - u1.age &#125;else&#123; return u1.age -u2.age &#125; &#125;) &#125; return fusers; &#125; &#125;, methods: &#123; setOrderType(value)&#123; this.orderType = value; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.8.事件处理在vue中绑定监听使用@xxx=&#39;fun&#39;,其中点击函数和传参数和不传参数，默认事件的形参是event,当需要传参的同时需要默认event时候，使用隐含属性对象@xxx = fun(123,$event)；事件有两个修饰符：.prevent：阻止事件的默认事件的默认行为和.stop：停止事件冒泡；按键修饰符使用keyup.keyCode = fun()：keycode是键盘输入对应的ketcode值，可以使用名称，但是存在一部风没有； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;绑定监听&lt;/h2&gt; &lt;button @click=\"test1\" &gt;我是按钮一&lt;/button&gt; &lt;button @click=\"test2('Hello 码酱')\"&gt;我是按钮二，我想获取自己传入的值&lt;/button&gt; &lt;button @click=\"test3\"&gt;我是按钮三，我就想获取自己&lt;/button&gt; &lt;button @click=\"test4('Hello',$event)\"&gt;我是按钮四，我想获取获取自己的同时获取传入的值&lt;/button&gt; &lt;h2&gt;事件修饰符：事件冒泡和事件默认行为&lt;/h2&gt; &lt;div style=\"width: 200px; height: 200px; background: red\" @click=\"test5\"&gt; &lt;!-- 使用 @click.stop阻止事件的冒泡--&gt; &lt;div style=\"width: 100px; height: 100px; background: blue\" @click.stop=\"test6\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 使用@click.prevent阻止事件的默认行为 --&gt; &lt;a href=\"luokangyuan.com\" @click.prevent=\"test7\"&gt;去码酱博客&lt;/a&gt; &lt;h2&gt;按键修饰符：使用@keyup.13，其中的数字代表键盘每一个输入对应的keycode&lt;/h2&gt; &lt;input type=\"text\" @keyup.13=\"test8\"&gt; &lt;input type=\"text\" @keyup.enter=\"test8\"&gt; &lt;/div&gt;&lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', methods: &#123; test1()&#123; alert(\"四川码酱\"); &#125;, test2(msg)&#123; alert(msg); &#125;, test3(event)&#123; alert(event.target.innerHTML); &#125;, test4(msg,event)&#123; alert(msg+\"===\"+event.target.innerHTML); &#125;, test5()&#123; alert(\"执行了外面的div的点击事件\"); &#125;, test6()&#123; alert(\"执行了里面的div的点击事件\"); &#125;, test7()&#123; alert(\"不去码酱博客\") &#125;, test8(event)&#123; alert(event.target.value); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1.9.表单输入绑定表单的数据绑定使用v-model指令，具体相关编码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form action=\"/xxx\" @submit.prevent=\"handSubmit\"&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type=\"text\" v-model=\"userName\"&gt; &lt;br&gt; &lt;span&gt;密码：&lt;/span&gt; &lt;input type=\"password\" v-model=\"pwd\"&gt; &lt;br&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type=\"radio\" id=\"wman\" value=\"女\" v-model=\"sex\"&gt; &lt;label for=\"wman\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"man\" value=\"男\" v-model=\"sex\"&gt; &lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;br&gt; &lt;span&gt;爱好：&lt;/span&gt; &lt;input type=\"checkbox\" id=\"basket\" value=\"basket\" v-model=\"likes\"&gt; &lt;label for=\"basket\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"footbal\" value=\"foot\" v-model=\"likes\"&gt; &lt;label for=\"footbal\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"pingpang\" value=\"pingpang\" v-model=\"likes\"&gt; &lt;label for=\"pingpang\"&gt;乒乓球&lt;/label&gt; &lt;br&gt; &lt;span&gt;城市：&lt;/span&gt; &lt;select name=\"\" id=\"\" v-model=\"cityId\"&gt; &lt;option value=\"\"&gt;未选择&lt;/option&gt; &lt;option :value=\"city.id\" v-for=\"(city,index) in allCitys\" :key=\"index\"&gt;&#123;[city.name]&#125;&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;个人介绍：&lt;/span&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"desc\"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data: &#123; userName: '', pwd: '', sex: '男', // 默认选中性别男 likes: ['foot'], // 默认选中foot对应的多选框 allCitys: [&#123; id: 1, name: \"北京\" &#125;, &#123; id: 2, name: \"成都\" &#125;, &#123; id: 3, name: \"上海\" &#125;, &#123; id: 4, name: \"宁波\" &#125;], cityId: '',// 这里默认是空，则匹配未选择，如果默认选中成都，则写2即可 desc: '' &#125;, methods: &#123; handSubmit() &#123; console.log(this.userName, this.pwd, this.sex, this.likes, this.cityId, this.desc) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.10.Vue的生命周期 常用的生命周期方法：create()/mounted():常用于发送Ajax请求启动定时器等异步任务，beforeDestory()：常用于做一些收尾工作，例如关闭定时器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click= \"destoryVm\"&gt;点击我取消Vue实例&lt;/button&gt; &lt;p v-show = \"isShow\"&gt;我是四川码酱&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data: &#123; isShow: true &#125;, beforeCreate() &#123; console.log(\"我是beforeCreate方法，我被执行了\"); &#125;, created() &#123; console.log(\"我是created方法，我被执行了\"); &#125;, beforeMount() &#123; console.log(\"我是beforeMount方法，我被执行了\"); &#125;, mounted()&#123; // 初始化显示之后立即调用，也是执行一次 this.intervalId = setInterval(() =&gt;&#123; console.log(\"=====\"); this.isShow = !this.isShow; &#125;, 1000) &#125;, beforeUpdate() &#123; console.log(\"我是beforeUpdate方法，我被执行了\"); &#125;, updated() &#123; console.log(\"我是updated方法，我被执行了\"); &#125;, beforeDestroy() &#123; // 死亡之前回调一次 // 清除定时器 clearInterval(this.intervalId) &#125;, destroyed() &#123; console.log(\"我是destroyed方法，我被执行了\"); &#125;, methods: &#123; destoryVm()&#123; this.$destroy(); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 说明：beforeCreate、created、beforeMount、mounted初始化方法只执行一次，beforeUpdate、updated执行多次，beforeDestroy、destroyed死亡方法，也执行一次； 1.11.过渡和动画在vue中动画就是操作css的trasition或者animation属性，vue会给目标元素添加和移除指定的class，只不过要遵循一定的命名规则， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;title&gt;动画和过渡&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* 指定显示和隐藏的过渡效果 */ .fade-enter-active, .fade-leave-active &#123; transition: opacity 1s; &#125; /* 指定隐藏的样式 */ .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; /* 指定显示的过滤效果 */ .move-enter-active &#123; transition: all 1s &#125; /* 指定隐藏的过滤效果 */ .move-leave-active &#123; transition: all 3s &#125; /* 指定隐藏的样式 */ .move-enter, .move-leave-to &#123; opacity: 0; transform: translateX(20px) &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"isshow = !isshow\"&gt;动画按钮&lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-show=\"isshow\"&gt;四川码酱&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;div id=\"app1\"&gt; &lt;button @click=\"isshow = !isshow\"&gt;多属性动画按钮&lt;/button&gt; &lt;transition name=\"move\"&gt; &lt;p v-show=\"isshow\"&gt;四川码酱&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data() &#123; return &#123; isshow: true &#125; &#125; &#125;) new Vue(&#123; el: \"#app1\", data() &#123; return &#123; isshow: true &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.12.过滤器在vue中允许自定义过滤器，所谓过滤器就是：对要显示的数据进行特定格式化后在显示，例如时间格式化等，注意的是：并没有改变原本的数据，只是产生新的对应数据； 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;当前完整时间为：&#123;[data | dateString]&#125;&lt;/p&gt; &lt;p&gt;当前日期为：&#123;[data | dateString('YYYY-MM-DD')]&#125;&lt;/p&gt; &lt;p&gt;当前时间为：&#123;[data | dateString('HH:mm:ss')]&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/moment.js/2.22.1/moment.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 自定义过滤器 Vue.filter('dateString',function(value,format)&#123; return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss') &#125;) new Vue(&#123; el: \"#app\", data: &#123; data: new Date() &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.13.内置指令和自定义指令常用的内置指令 v:text : 更新元素的 textContent v-html : 更新元素的 innerHTML v-if : 如果为 true, 当前标签才会输出到页面 v-else: 如果为 false, 当前标签才会输出到页面 v-show : 通过控制 display 样式来控制显示/隐藏 v-for : 遍历数组/对象 v-on : 绑定事件监听, 一般简写为@ v-bind : 强制绑定解析表达式, 可以省略 v-bind v-model : 双向数据绑定 ref : 指定唯一标识, vue 对象通过$els 属性访问这个元素对象 v-cloak : 防止闪现出现{[xxx]}, 与 css 配合: [v-cloak] { display: none } 1234567891011121314151617181920212223242526272829&lt;title&gt;内置指令&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p ref=\"content\"&gt;四川码酱&lt;/p&gt; &lt;button @click = \"hint\"&gt;提示&lt;/button&gt; &lt;p v-cloak&gt;&#123;[msg]&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data: &#123; msg: \"Hello 四川码酱\" &#125;, methods: &#123; hint()&#123; alert(this.$refs.content.textContent); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 说明： v-cloak指令是为了页面加载数据缓慢时候显示{[xxx]}标签而出了一个指令，与CSS搭配使用 自定义指令 注册全局指令，方法如下： 123Vue.directive('my-directive', function(el, binding)&#123; el.innerHTML = binding.value.toupperCase()&#125;) 注册局部指令，方法如下： 1234567directives : &#123; 'my-directive' : &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toupperCase() &#125; &#125;&#125; 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 定义全局指令 // el：指令属性所在的标签属性 // binding：包含指令相关信息数据的对象 Vue.directive('upper-text', function(el,binding)&#123; el.textContent = binding.value.toUpperCase() console.log(el,binding) &#125;) new Vue(&#123; el: \"#app\", data: &#123; msg: \"This is my think life\" &#125;, directives: &#123; // 使用自定义局部指令 'lower-text' : function(el,binding)&#123; el.textContent = binding.value.toLowerCase() &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.14.核心知识总结 Vue是前端开发库，用于构建用户界面，遵循MVVM模式，编码简洁，体积小，效率高，包含了一些列插件库； 基本使用：引入vue.js，创建vue实例对象，其中el代表dom标签选择器，data代表初始化数据对象； el：指定dom标签容器的选择器，一般写一个根标签； data：对象或者函数类型，指定初始化状态属性数据的对象，页面中可以使用{[xxx]}直接访问 methods：包含多个方法的对象，供页面中的事件指令来回调，回调函数默认有$event参数，也可以指定自己的参数，在方法中，访问data中的属性直接使用this.xxx； computed：计算属性，包含多个方法的对象，对状态属性进行计算处理后返回给页面一个新的数据，使用get和set方法实现属性的计算读取，同时监视数据的变化； watch：监视，包含多个属性监视的对象，xxx.function(value){}，可以传入两个参数，代表新值和改变前的值，也可以使用vm.$watch(&#39;xxx&#39;, function(value){})的方式添加监听； vue中的过渡和动画，实质就是vue操作css的transition/animation属性； 生命周期：常用的钩子函数是created() / mounted(): 启动异步任务(启动定时器,发送ajax请求, 绑定监听)和beforeDestroy(): 做一些收尾的工作例如清除定时器等； 自定义过滤器：使用的是Vue.filter(filterName,function(value){})，在页面使用方法：{[myData | filterName(arg)]}，参数可传可不传； vue内置指令：v-for遍历、@绑定事件、v-model数据双向绑定、ref标识标签； 自定义指令：使用Vue.directive注册全局指令，使用directives注册局部指令； 注意：数据在哪个组件，更新数据的行为（方法）就应该定义在那个组件中 二、Vue组件化编码方式2.1.使用vue-cli创建模板项目vue-cli是vue官方提供的脚手架工具，首先确认安装了node和npm，最好安装一个cnpm，使用方法如下： npm install -g vue-cli vue init webpack vue_demo 其中 vue_demo是项目名 cd vue_demo npm install或者npm run dev 项目结构说明 build : webpack 相关的配置文件夹(基本不需要修改) dev-server.js : 通过 express 启动后台服务器 config: webpack 相关的配置文件夹(基本不需要修改) index.js: 指定的后台服务的端口号和静态资源文件夹 src : 源码文件夹 components: vue 组件及其相关资源文件夹 App.vue: 应用根主组件 main.js: 应用入口 js static: 静态资源文件夹 .babelrc: babel 的配置文件 .eslintignore: eslint 检查忽略的配置 .eslintrc.js: eslint 检查的配置 .gitignore: git 版本管制忽略的配置 index.html: 主页面文件 package.json: 应用包配置文件 README.md: 应用描述说明的 readme 文件 简单的使用Vue模板项目 首先，我们编写了一个HelloWord的组件， 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1 class=&quot;msg&quot;&gt;&#123;[ msg ]&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 配置对象和Vue一致 data() &#123; // data可以 写对象和函数，但是在组件中必须使用函数 return &#123; msg: &quot;Hello Welcome to My Vue&quot; &#125;; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt; .msg &#123; color: red &#125;&lt;/style&gt; 然后，我们在App.vue中使用我们自己定义的组件 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;!-- 3.使用组件标签 --&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1.引入需要使用的vue组件（HelloWoed组件）import HelloWorld from &apos;./components/HelloWorld&apos;export default &#123; components: &#123; // 2.映射组件标签 HelloWorld &#125;&#125;&lt;/script&gt;&lt;style&gt;.logo&#123; width: 100px; height: 100px;&#125;&lt;/style&gt; 我们知道使用Webpack打包后会生成一个js文件，也就是入口文件main.js 12345678910import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', // 挂载到入口Dom节点（index.html） components: &#123; App &#125;, // 映射组件标签 template: '&lt;App/&gt;' //使用标签&#125;) 2.2.项目打包发布方式打包命令：npm run build 使用静态服务器：安装命令：npm install -g serve，发布命令：serve dist，然后直接访问就可以了 使用动态web服务器（Tomcat）:修改webpack.prod.conf.js，加入output: {publicPath: &#39;/xxx/&#39; //打包文件夹的名称}，然后重新打包，将dis文件夹的名称改为项目名称，放在tomcat的webapp目录下，访问即可； 2.3.组件的定义在vue中，我们知道一个vue文件包含三部分，分别为模版页面、JS模块对象和CSS样式，组件的定义就是写一个vue文件，只是这一个文件单独的完成某一项功能，例如，下拉树，下拉多选等，这就是一个组件；当我们页面需要使用组件的时候就引入相关的组件，使用方法如下： 1.引入组件 1import HelloWorld from './components/HelloWord' 2.将引入的组件映射为标签 123456export default &#123; name: 'App', components: &#123; HelloWorld &#125;&#125; 3.使用组件标签 1&lt;HelloWorld/&gt; 说明：使用标签时：1.和组件映射一模一样写，2.大写变小写，并用-连接，例如：&lt;hello-world&gt; 2.4.组件的通信在组件的通信中，我们需要的明确的是数据是某一个组件的数据，还是某一些组件的数据,也就是明确组件通信的基本原则，不要在子组件中直接修改父组件的状态数据和数据在那个组件上，更新数据的行为（函数定义）就在那个组件上；例如：一个页面的评价，包含的添加组件和遍历显示组件，那么数据因该定义在这两个组件的父组件上，因为添加组件是向数据中插入一条数据，遍历组件是将数据遍历显示； 组件的通信方式 在vue中组件之间的通信方式有五种，分别为props、vue的自定义事件、消息的订阅与发布、slot和vuex， 组件通信：props 1.将父组件的数据传递到子组件中 1&lt;List :comments=\"comments\"/&gt; 2.在子组件中申明props，申明的方式有三种 1234567export default &#123; // 第一种：只指定名称 props: ['comments'], components:&#123; Item &#125; &#125; 123456export default &#123; // 第二种：指定名称和类型 props: &#123; comment: Object &#125; &#125; 123456export default&#123; // 第三种：指定名称，类型，必要性和默认值 props: &#123; name:&#123;type:String,required:true,default:'张三'&#125; &#125;&#125; 同理，组件之间方法的通信也是如下如下所示： 1.父组件定义方法 12345methods:&#123; addComment(comment)&#123; this.comments.unshift(comment) &#125;&#125; 2.将方法传递到子组件中,注意使用的是冒号 1&lt;Add :addComment=\"addComment\"/&gt; 3.子组件中使用props申明 123456props: &#123; addComment: &#123; type: Function, required: true &#125;&#125; 4.子组件直接通过this使用 1this.addComment(comment); 使用props的优点和缺点 使用props这种组件通信方式只适合父组件向子组件传递数据； 传递到子组件的标签属性都会称为子组件对象的属性，可以直接在组件中使用； 如果需要向非直接子后代的组件传递数据需要多层逐层传递； 兄弟组件之间也不能直接使用props通信，需要借助父组件才行； 题外话：不同事件的区别 前提：当一个大div包裹一个小的div时候， onmouseover：从外部进入大div时候，触发，从小div进入大div时候，触发 onmouseenter：从外部进入大div时候，触发 onmouseleave：从大div进入到外部时候，触发 onmouseout：从大div进入小div时候，触发 组件通信：自定义事件 官方文件中的自定义事件可以参考，自定义事件,简单的一下 1.父组件中绑定通信的函数,props使用的是冒号，这里不是了 1&lt;TodoHeader @addTodo=\"addTodo\"/&gt; 2.子组件中也不再使用props申明了 1this.$emit('addTodo',todo) 说明：$emit函数的参数一个是绑定的事件函数名，一个就是数据，执行这个函数需要传递的参数； 当然，官方还介绍另外一种自定义事件通信，只是我觉得有些麻烦，这里也一并简单说一下 1.给需要绑定的组件中指定ref属性 1&lt;TodoHeader ref=\"header\"/&gt; 2.因为事件是在加载的时候就因该被绑定，所以在mounted中执行异步代码 123mounted()&#123; this.$refs.header.$on('addTodo',this.addTodo)&#125; 3.子组件中同样的使用方法 1this.$emit('addTodo',todo) 说明：这种方式也只是适合直接父子组件之间传递函数，在隔代组件活着兄弟组件之间不合适； 组件通信：pubsub消息订阅与发布 使用pubsub.js进行消息的订阅与发布，需要我们下载和引入pubsub.js 1npm install --save pubsub-js 这个时候，我们如果要A–B–C之间传递函数，就可以不再使用props逐层传递和声明了； 和前面的对比：绑定事件监听就是订阅消息，触发事件就是发布消息； 1.父组件引入pubsub.js 1import PubSub from 'pubsub-js' 2.父组件中订阅消息 12345mounted()&#123; PubSub.subscribe('deleteTodo',(msg,index) =&gt; &#123; this.deleteTodo(index) &#125;)&#125; 3.孙子组件同理引入pubsub.js,同时发布消息 1PubSub.publish('deleteTodo',index) 说明：使用pubsub进行组件之间的通信，可以不关系组件之间的关系，例如兄弟组件都可以使用； 组件通信：slot 简单说，我们平时看的APP的顶部导航就是反复的使用，但是每一个页面的内容和样式又不一样，这个时候就可以使用slot，父组件向子组件传递标签数据； 1.首先在子组件中定义插头,定义了三个插头 1234567891011&lt;template&gt; &lt;div class=\"todo-footer\"&gt; &lt;label&gt; &lt;slot name=\"checkAll\"&gt;&lt;/slot&gt; &lt;/label&gt; &lt;span&gt; &lt;slot name=\"count\"&gt;&lt;/slot&gt; &lt;/span&gt; &lt;slot name=\"delete\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 2.在父组件中向子组件传递标签数据 12345&lt;TodoFooter&gt; &lt;input type=\"checkbox\" v-model=\"isAllCheck\" slot=\"checkAll\"/&gt; &lt;span slot=\"count\"&gt;已完成&#123;[completerSize]&#125;/ 全部&#123;[todos.length]&#125;&lt;/span&gt; &lt;button class=\"btn btn-danger\" v-show=\"completerSize\" @click=\"deleteCompleteTodos\" slot=\"delete\"&gt;清除已完成任务&lt;/button&gt;&lt;/TodoFooter&gt; 说明：传递的标签数据是在父组件渲染的，所以子组件的计算属性都要放在父组件中，子组件不需要写； 三、Vue请求方式vue-ajax在vue中，可以使用vue-ressource和axios来发送异步AJAX请求，其中vue-ressource在vue1.x中使用广泛,但在vue2.x之后官方推荐使用axios请求库 3.1.axios的使用1.下载axios 1npm install axios --save 2.组件中引入 1import axios from 'axios' 3.组件初始化时候调用 12345678mounted()&#123; const url = '' axios.get(url).then(response =&gt; &#123; const result = response.data &#125;).catch(error =&gt; &#123; alert('请求失败') &#125;)&#125; 四、Vue组件库常用的vue组件库，在移动端使用Mint UI,其官方文档为：MintUI,在PC端使用的是Element,官方文档为：Element,各个UI组件的使用方法基本一样，参考官方文档就可以使用，下面简单使用一下Mint UI； 4.1.使用Mint UI1.下载安装Mint UI 1npm install --save mint-ui 2.下载实现按需打包 1npm install --save-dev babel-plugin-component 3.修改babelrc配置文件 123456&quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;,[&quot;component&quot;,[&#123;&quot;libraryName&quot;: &quot;mint-ui&quot;,&quot;style&quot;: true&#125;]]] 4.由于是移动端，可以在index.html 中添加适配 123456789101112&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1, user-scalable=no\" /&gt;&lt;script src=\"https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js\"&gt;&lt;/script&gt;&lt;script&gt; if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false); &#125; if(!window.Promise) &#123; document.writeln('&lt;script src=\"https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js\"'+'&gt;'+'&lt;'+'/'+'script&gt;'); &#125;&lt;/script&gt; 5.可以在main.js中全局配置我们需要使用的组件 12import &#123;Button&#125; from 'mint-ui'Vue.component(Button.name,Button) 6.在组件中使用 1&lt;mt-button type=\"primary\" style=\"width: 100%\" @click=\"handleClick\"&gt;按钮&lt;/mt-button&gt; 五、Vue路由vue-router5.1.vue-router简介在spa 六、Vue状态管理vuex","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://caochenhins.github.io/tags/vue/"}]},{"title":"PostgreSQL学习总结","slug":"PostgreSQL学习总结","date":"2019-03-21T14:40:21.000Z","updated":"2019-03-21T15:18:39.550Z","comments":true,"path":"2019/03/21/PostgreSQL学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/PostgreSQL学习总结/","excerpt":"PostgreSQL基础部分PostgreSQL简介PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。","text":"PostgreSQL基础部分PostgreSQL简介PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。 PostgreSQL特点 PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。 PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。 PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。 在PostgreSQL中，表可以设置为从“父”表继承其特征。 可以安装多个扩展以向PostgreSQL添加附加功能。 PostgreSQL语法可以使用help语句查看所有postgreSQL语句的语法。 按照以下步骤查看PostgreSQL中所有语句的语法。 安装postgreSQL后，打开psql为：程序文件 -&gt; PostgreSQL 9.2 -&gt; SQL Shell(psql) 使用以下语句查看特定语句的语法。 postgres-＃\\ help＆ PostgreSQL数据类型数据类型指定要在表字段中存储哪种类型的数据。 在创建表时，对于每列必须使用数据类型。 以下是PostgreSQL中主要有三种类型的数据类型： 数值数据类型 字符串数据类型 日期/时间数据类型 数值数据类型 名称 描述 存储大小 范围 smallint 存储整数，小范围 2字节 -32768 至 +32767 integer 存储整数。使用这个类型可存储典型的整数 4字节 -2147483648 至 +2147483647 bigint 存储整数，大范围。 8字节 -9223372036854775808 至 9223372036854775807 decimal 用户指定的精度，精确 变量 小数点前最多为131072个数字; 小数点后最多为16383个数字。 numeric 用户指定的精度，精确 变量 小数点前最多为131072个数字; 小数点后最多为16383个数字。 real 可变精度，不精确 4字节 6位数字精度 double 可变精度，不精确 8字节 15位数字精度 serial 自动递增整数 4字节 1 至 2147483647 bigserial 大的自动递增整数 8字节 1 至 9223372036854775807 字符串数据类型 数据类型 描述 char(size) 这里size是要存储的字符数。固定长度字符串，右边的空格填充到相等大小的字符。 character(size) 这里size是要存储的字符数。 固定长度字符串。 右边的空格填充到相等大小的字符。 varchar(size) 这里size是要存储的字符数。 可变长度字符串。 character varying(size) 这里size是要存储的字符数。 可变长度字符串。 text 可变长度字符串。 日期/时间数据类型 名称 描述 存储大小 最小值 最大值 解析度 timestamp [ (p) ] [不带时区 ] 日期和时间(无时区) 8字节 4713 bc 294276 ad 1微秒/14位数 timestamp [ (p) ]带时区 包括日期和时间，带时区 8字节 4713 bc 294276 ad date 日期(没有时间) 4字节 4713 bc 5874897 ad 1微秒/14位数 time [ (p) ] [ 不带时区 ] 时间(无日期) 8字节 00:00:00 24:00:00 1微秒/14位数 time [ (p) ] 带时区 仅限时间，带时区 12字节 00:00:00+1459 24:00:00-1459 1微秒/14位数 interval [ fields ] [ (p) ] 时间间隔 12字节 -178000000年 178000000年 1微秒/14位数 PostgreSQL基本使用创建数据库可以使用数据库客户端pgAdmin来创建数据库,下面说的是使用SQL shell查询工具来创建数据库 1create database testdb; 查看数据库1postgres=# \\l 删除数据库123postgres=# drop database testdb;DROP DATABASEpostgres=# 创建表12345678CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); 删除表12postgres=# drop table student2;DROP TABLE PostgreSQL模式模式(也叫架构)是指定的表集合。 它还可以包含视图，索引，序列，数据类型，运算符和函数。 尤为重要 创建模式语法1CREATE SCHEMA schema_name; 创建模式实例1CREATE SCHEMA myschema; 在模式下新建表12345678CREATE TABLE myschema.tb_test( id integer, name character(254))WITH ( OIDS=FALSE); 使用模式的优点 模式有助于多用户使用一个数据库，而不会互相干扰。 它将数据库对象组织成逻辑组，使其更易于管理。 可以将第三方模式放入单独的模式中，以避免与其他对象的名称相冲突。 PostgreSQL查询工具INSERT语句1234567INSERT INTO EMPLOYEES( ID, NAME, AGE, ADDRESS, SALARY) VALUES (1, 'Maxsu', 25, '海口市人民大道2880号', 109990.00 ), (2, 'minsu', 25, '广州中山大道 ', 125000.00 ), (3, '李洋', 21, '北京市朝阳区', 185000.00), (4, 'Manisha', 24, 'Mumbai', 65000.00), (5, 'Larry', 21, 'Paris', 85000.00); SELECT语句1SELECT ID, NAME, AGE, SALARY FROM EMPLOYEES; UPDATE语句123UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; DELETE语句12DELETE FROM table_name WHERE [condition]; 注意：如果不使用“WHERE”条件，整个表中的记录都将被删除 ORDER BY语句ORDER BY子句用于按升序或降序对数据进行排序。数据在一列或多列的基础上进行排序。 1234SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; GROUP BY语句GROUP BY子句用于将具有相同数据的表中的这些行分组在一起。 它与SELECT语句一起使用。GROUP BY子句通过多个记录收集数据，并将结果分组到一个或多个列。 它也用于减少输出中的冗余 12345SELECT column-list FROM table_name WHERE [conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN 实例,按name分组，统计薪水 123SELECT NAME, SUM(SALARY) FROM EMPLOYEES GROUP BY NAME; HAVING IN语句HAVING子句与GROUP BY子句组合使用，用于选择函数结果满足某些条件的特定行。 123456SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 实例，查询表中名字相同数大于2 123SELECT NAME,COUNT (NAME) FROM EMPLOYEES GROUP BY NAME HAVING COUNT (NAME) &gt; 2; PostgreSQL条件查询PostgreSQL条件用于从数据库获取更具体的结果。 通常与WHERE子句一起使用。 具有子句的条件就像双层过滤器。 AND 条件 OR 条件 AND &amp; OR 条件 NOT 条件 LIKE 条件 IN 条件 NOT IN 条件 BETWEEN 条件 AND条件AND条件与WHERE子句一起使用，以从表中的多个列中选择唯一的数据。 1234SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] AND [search_condition]; OR条件OR条件与WHERE子句一起使用，以从表中的一列或多列列中选择唯一数据 1234SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] OR [search_condition]; OR和AND一起使用实例 1234SELECT * FROM EMPLOYEES WHERE (NAME = 'Minsu' AND ADDRESS = 'Delhi') OR (ID&gt;= 8); NOT条件NOT条件与WHERE子句一起使用以否定查询中的条件。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] NOT [condition]; 实例 1234567SELECT * FROM EMPLOYEES WHERE address IS NOT NULL ;--查询年龄不是21和24的所有记录SELECT * FROM EMPLOYEES WHERE age NOT IN(21,24) ; LIKE条件LIKE条件与WHERE子句一起用于从指定条件满足LIKE条件的表中获取数据 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] LIKE [condition]; 实例，查询名字以Ma开头记录 123SELECT * FROM EMPLOYEES WHERE NAME LIKE 'Ma%'; IN条件IN条件与WHERE子句一起使用，从指定条件满足IN条件的表中获取数据。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] IN [condition]; 实例,查询年龄是19,21的记录 123SELECT * FROM EMPLOYEES WHERE AGE IN (19, 21); NOT IN条件NOT IN条件与WHERE子句一起使用，以从指定条件否定IN条件的表中获取数据。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] NOT IN [condition]; BETWEEN条件BETWEEN条件与WHERE子句一起使用，以从两个指定条件之间的表中获取数据 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] BETWEEN [condition]; 实例，查询年龄在24到27之间的记录，包括24和27 123SELECT * FROM EMPLOYEES WHERE AGE BETWEEN 24 AND 27; PostgreSQL连接 内连接(INNER JOIN) 左外连接(LEFT OUTER JOIN) 右外连接(RIGHT OUTER JOIN) 全连接(FULL OUTER JOIN) 跨连接(CROSS JOIN) INNER JOIN内连接内部连接也被称为连接或简单连接。 这是最常见的连接类型。 此连接返回满足连接条件的多个表中的所有行。 简单讲，就是返回两张表中共同拥有的部分 1234SELECT table1.columns, table2.columns FROM table1 INNER JOIN table2 ON table1.common_filed = table2.common_field; LEFT JOIN左外连接左外连接返回从“ON”条件中指定的左侧表中的所有行，只返回满足条件的另一个表中的行。 简单讲on条件中左侧表的全部加上两张表共同的部分 1234SELECT table1.columns, table2.columns FROM table1 LEFT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 返回的是table1的全部和table1和table2共同的记录 RIGHT JOIN右外连接右外连接返回从“ON”条件中指定的右侧表中的所有行，只返回满足条件的另一个表中的行。 1234SELECT table1.columns, table2.columns FROM table1 RIGHT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 返回的是table2的全部记录和table1和table2共同的部分 FULL 全外连接FULL外连接从LEFT手表和RIGHT表中返回所有行。 它将NULL置于不满足连接条件的位置。 1234SELECT table1.columns, table2.columns FROM table1 FULL OUTER JOIN table2 ON table1.common_filed = table2.common_field; CROSS跨连接跨连接(CROSS JOIN)将第一个表的每一行与第二个表的每一行相匹配。 它也被称为笛卡儿积分。 如果table1具有“x”列，而table2具有“y”列，则所得到的表将具有(x + y)列。 123SELECT coloums FROM table1 CROSS JOIN table2 PostgreSQL高级部分PostgreSQL视图在PostgreSQL中，视图(VIEW)是一个伪表。 它不是物理表，而是作为普通表选择查询。 视图也可以表示连接的表。 它可以包含表的所有行或来自一个或多个表的所选行。 使用视图的优点 它以自然和直观的方式构建数据，并使其易于查找。 它限制对数据的访问，使得用户只能看到有限的数据而不是完整的数据。 它归总来自各种表中的数据以生成报告。 创建视图可以使用CREATE VIEW语句来在PostgreSQL中创建视图。 您可以从单个表，多个表以及另一个视图创建它。 1234CREATE [TEMP | TEMPORARY] VIEW view_name AS SELECT column1, column2..... FROM table_name WHERE [condition]; 创建视图实例,在Employees表创建一个视图，此视图仅包含Employee表中的几个列 123CREATE VIEW current_employees AS SELECT NAME, ID, SALARY FROM EMPLOYEES; 这个时候，你可以在视图下看到current_employees视图 使用视图 1SELECT * FROM current_employees; 删除视图 1DROP VIEW current_employees; PostgreSQL函数PostgreSQL函数也称为PostgreSQL存储过程。 PostgreSQL函数或存储过程是存储在数据库服务器上并可以使用SQL界面调用的一组SQL和过程语句(声明，分配，循环，控制流程等)。 它有助于您执行通常在数据库中的单个函数中进行多次查询和往返操作的操作。可以在许多语言(如SQL，PL/pgSQL，C，Python等)中创建PostgreSQL函数。 12345678910CREATE [OR REPLACE] FUNCTION function_name (arguments) RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN &lt; function_body &gt; [...] RETURN &#123; variable_name | value &#125; END; LANGUAGE plpgsql; 说明： function_name：指定函数的名称。 [OR REPLACE]：是可选的，它允许您修改/替换现有函数。 RETURN：它指定要从函数返回的数据类型。它可以是基础，复合或域类型，或者也可以引用表列的类型。 function_body：function_body包含可执行部分。 plpgsql：它指定实现该函数的语言的名称。 实例，在Employee表上创建一个total records() 函数 123456789CREATE OR REPLACE FUNCTION totalRecords () RETURNS integer AS $total$ declare total integer; BEGIN SELECT count(*) into total FROM EMPLOYEES; RETURN total; END; $total$ LANGUAGE plpgsql; 调用函数 1select totalRecords(); PostgreSQL触发器PostgreSQL触发器是一组动作或数据库回调函数，它们在指定的表上执行指定的数据库事件(即，INSERT，UPDATE，DELETE或TRUNCATE语句)时自动运行。 触发器用于验证输入数据，执行业务规则，保持审计跟踪等。 说明 PostgreSQL在以下情况下执行/调用触发器：在尝试操作之前(在检查约束并尝试INSERT，UPDATE或DELETE之前)。或者在操作完成后(在检查约束并且INSERT，UPDATE或DELETE完成后)。或者不是操作(在视图中INSERT，UPDATE或DELETE的情况下) 对于操作修改的每一行，都会调用一个标记为FOR EACH ROWS的触发器。 另一方面，标记为FOR EACH STATEMENT的触发器只对任何给定的操作执行一次，而不管它修改多少行。 您可以为同一事件定义同一类型的多个触发器，但条件是按名称按字母顺序触发。 当与它们相关联的表被删除时，触发器被自动删除。 创建触发器12345CREATE TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name ON table_name [ -- Trigger logic goes here.... ]; 在这里，event_name可以是INSERT，UPDATE，DELETE和TRUNCATE数据库操作上提到的表table_name。 您可以选择在表名后指定FOR EACH ROW。下面来看看看如何在INSERT操作中创建触发器的语法。 12345CREATE TRIGGER trigger_name AFTER INSERT ON column_name ON table_name [ -- Trigger logic goes here.... ]; 实例当插入一条数据到审核表COMPANY时，就会在AUDIL表中插入一条记录 先在审核表中创建一个函数auditlogfunc 123456CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$ BEGIN INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp); RETURN NEW; END; $example_table$ LANGUAGE plpgsql; COMPANY表上创建触发器 12CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY FOR EACH ROW EXECUTE PROCEDURE auditlogfunc(); 向审核表中插入数据测试 12INSERT INTO COMPANY VALUES(1, '小米科技', 8, '北京市朝阳区', 9999);INSERT INTO COMPANY VALUES(2, '京东中科', 6, '广州市天河区', 8999); 触发器使用场景 验证输入数据。 执行业务规则。 为不同文件中新插入的行生成唯一值。 写入其他文件以进行审计跟踪。 从其他文件查询交叉引用目的。 访问系统函数。 将数据复制到不同的文件以实现数据一致性。 触发器的优点 它提高了应用程序的开发速度。 因为数据库存储触发器，所以您不必将触发器操作编码到每个数据库应用程序中。 全局执法业务规则。定义触发器一次，然后将其重用于使用数据库的任何应用程序。 更容易维护 如果业务策略发生变化，则只需更改相应的触发程序，而不是每个应用程序。 提高客户/服务器环境的性能。 所有规则在结果返回之前在服务器中运行。 PostgreSQL索引索引是用于加速从数据库检索数据的特殊查找表。数据库索引类似于书的索引(目录)。 索引为出现在索引列中的每个值创建一个条目。 特点 索引使用SELECT查询和WHERE子句加速数据输出，但是会减慢使用INSERT和UPDATE语句输入的数据。 您可以在不影响数据的情况下创建或删除索引。 可以通过使用CREATE INDEX语句创建索引，指定创建索引的索引名称和表或列名称。 还可以创建一个唯一索引，类似于唯一约束，该索引防止列或列的组合上有一个索引重复的项 创建索引1CREATE INDEX index_name ON table_name; 索引类型PostgreSQL中有几种索引类型，如B-tree，Hash，GiST，SP-GiST和GIN等。每种索引类型根据不同的查询使用不同的算法。 默认情况下，CREATE INDEX命令使用B树索引。 单列索引如果仅在一个表列中创建索引，则将其称为单列索引。 12CREATE INDEX index_name ON table_name (column_name); 多列索引如果通过使用表的多个列创建索引，则称为多列索引。 12CREATE INDEX index_name ON table_name (column1_name, column2_name); 唯一索引创建唯一索引以获取数据的完整性并提高性能。它不允许向表中插入重复的值，或者在原来表中有相同记录的列上也不能创建索引。 12CREATE UNIQUE INDEX index_name on table_name (column_name); 删除索引1DROP INDEX index_name; 避免使用索引场景 应该避免在小表上使用索引。 不要为具有频繁，大批量更新或插入操作的表创建索引。 索引不应用于包含大量NULL值的列。 不要在经常操作(修改)的列上创建索引。 PostgreSQL日期函数 函数 描述 AGE() 减去参数 CURRENT DATE/TIME() 它指定当前日期和时间。 DATE_PART() 获取子字段(相当于提取) EXTRACT() 获得子字段 ISFINITE() 测试有限的日期，时间和间隔(非+/-无穷大) JUSTIFY 调整间隔 AGE(timestamp，timestamp)＆AGE(timestamp) 函数 描述 age(timestamp, timestamp) 当使用第二个参数的时间戳形式调用时，age()减去参数，产生使用年数和月份的类型为“interval”的“符号”结果。 age(timestamp) 当仅使用时间戳作为参数调用时，age()从current_date(午夜)减去。 AGE函数实例 1SELECT AGE(timestamp '2017-01-26', timestamp '1951-08-15'); --结果是65 year 5 mons 11 day 当前时间函数 函数 描述 CURRENT_DATE 提供当前日期 CURRENT_TIME 提供带时区的值 CURRENT_TIMESTAMP 提供带时区的值 CURRENT_TIME(precision) 选择使用precision参数，使结果在四分之一秒的范围内四舍五入到数位数。 CURRENT_TIMESTAMP(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 LOCALTIME 提供没有时区的值。 LOCALTIMESTAMP 提供没有时区的值。 LOCALTIME(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 LOCALTIMESTAMP(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 实例 12345SELECT CURRENT_TIME; --获取当前时间SELECT CURRENT_DATE; --获取当前日期SELECT CURRENT_TIMESTAMP; --获取当前时间戳SELECT CURRENT_TIMESTAMP(2); --虎丘当前时间戳更精确SELECT LOCALTIMESTAMP; --获取本地时间戳 PostgreSQL UNIONS语句PostgreSQL UNION子句/运算符用于组合两个或多个SELECT语句的结果，而不返回任何重复的行。要使用UNION，每个SELECT必须具有相同的列数，相同数量的列表达式，相同的数据类型，并且具有相同的顺序，但不一定要相同。 语法123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNIONSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] 实例 12345SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID UNION SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; UNION ALL语句UNION ALL运算符用于组合两个SELECT语句(包括重复行)的结果。 适用UNION的相同规则也适用于UNION ALL运算符。 123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNION ALLSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] PostgreSQL NULLPostgreSQL NULL是用于表示缺少值的术语。 表中的NULL值是一个字段中的值，显示为空白。具有NULL值的字段是没有值的字段。要知道一个NULL值与零值或包含空格的字段不同是非常重要的。 IS NOT NULL123SELECT ID, NAME, AGE, ADDRESS, SALARY FROM COMPANY WHERE SALARY IS NOT NULL; IS NULL123SELECT ID, NAME, AGE, ADDRESS, SALARY FROM COMPANY WHERE SALARY IS NULL; PostgreSQL修改表PostgreSQL ALTER TABLE命令用于添加，删除或修改现有表中的列。您还可以使用ALTER TABLE命令在现有表上添加和删除各种约束。 语法使用ALTER TABLE语句在现有表中添加新列的基本语法如下： 1ALTER TABLE table_name ADD column_name datatype; 现有表中ALTER TABLE到DROP COLUMN(删除某个字段)的基本语法如下： 1ALTER TABLE table_name DROP COLUMN column_name; ALTER TABLE更改表中列的DATA TYPE(修改字段类型)的基本语法如下： 1ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype; ALTER TABLE向表中的列添加NOT NULL约束的基本语法如下： 1ALTER TABLE table_name MODIFY column_name datatype NOT NULL; ALTER TABLE添加唯一约束ADD UNIQUE CONSTRAINT到表中的基本语法如下： 12ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...); ALTER TABLE将“检查约束”添加到表中的基本语法如下所示： 12ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION); ALTER TABLE添加主键ADD PRIMARY KEY约束的基本语法如下： 12ALTER TABLE table_nameADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...); 使用ALTER TABLE从表中删除约束(DROP CONSTRAINT)的基本语法如下： 12ALTER TABLE table_nameDROP CONSTRAINT MyUniqueConstraint; 使用ALTER TABLE从表中删除主键约束(DROP PRIMARY KEY)约束的基本语法如下： 12ALTER TABLE table_nameDROP CONSTRAINT MyPrimaryKey; PostgreSQL子查询子查询或内部查询或嵌套查询是一个PostgreSQL查询中的查询，它可以嵌入到WHERE子句中。子查询用于返回将在主查询中使用的数据作为进一步限制要检索的数据的条件。 子查询可以与SELECT，INSERT，UPDATE和DELETE语句以及运算符(如=，&lt;，&gt;，&gt;=，&lt;=，IN等)一起使用。 子查询必须括在括号中。 子查询在SELECT子句中只能有一列，除非主查询中有多个列用于比较其所选列的子查询。 ORDER BY不能用于子查询，主查询可以使用ORDER BY，GROUP BY可用执行与子查询中的ORDER BY相同的功能。 返回多行的子查询只能与多个值运算符一起使用，例如：IN，EXISTS，NOT IN，ANY / SOME，ALL运算符。 BETWEEN运算符不能与子查询一起使用; 但是，BETWEEN可以在子查询中使用。 带SELECT语句的子查询123456SELECT column_name [, column_name ]FROM table1 [, table2 ]WHERE column_name OPERATOR (SELECT column_name [, column_name ] FROM table1 [, table2 ] [WHERE]) 实例 12345SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &gt; 45000) ; 带INSERT语句的子查询子查询也可以用于INSERT语句。INSERT语句使用从子查询返回的数据插入另一个表。 可以使用任何字符，日期或数字函数修改子查询中选定的数据。 1234INSERT INTO table_name [ (column1 [, column2 ]) ] SELECT [ *|column1 [, column2 ] FROM table1 [, table2 ] [ WHERE VALUE OPERATOR ] 1234INSERT INTO COMPANY_BKP SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY) ; 带UPDATE语句的子查询子查询可以与UPDATE语句一起使用。 当使用具有UPDATE语句的子查询时，可以更新表中的单列或多列 123456UPDATE tableSET column_name = new_value[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 实例 假设我们有一个名为COMPANY_BKP表，它是COMPANY表的备份。以下示例将所有客户(其AGE大于或等于27)在COMPANY表中的SALARY更新为0.50倍： 1234UPDATE COMPANY SET SALARY = SALARY * 0.50 WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt;= 27 ); 带有DELETE语句的子查询12345DELETE FROM TABLE_NAME[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 实例 假设我们有一个COMPANY_BKP表，它是COMPANY表的备份。以下示例从COMPANY 表中删除所有客户的记录，其AGE大于或等于27数据记录 123DELETE FROM COMPANY WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt; 27 );","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://caochenhins.github.io/tags/PostgreSQL/"}]},{"title":"Mysql学习总结","slug":"Mysql学习总结","date":"2019-03-21T14:40:04.000Z","updated":"2019-03-21T15:19:13.580Z","comments":true,"path":"2019/03/21/Mysql学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/Mysql学习总结/","excerpt":"数据库简介数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 数据库相关概念","text":"数据库简介数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 数据库相关概念 DB：数据库，保存一组有组织的数据的容器 DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 SQL:结构化查询语言，用于和DBMS通信的语言 数据库存储特点 将数据放到表中，表再放到库中 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。 表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性” 表中的数据是按行存储的，每一行类似于java中的“对象”。 Mysql常用命令查看当前所有的数据库 1show databases; 打开指定的库 1use 库名 查看当前库的所有表 1show tables; 查看其它库的所有表 1show tables from 库名; 创建表 1234create table 表名( 列名 列类型, 列名 列类型 ); 查看表结构 1desc 表名; Mysql语法规范 不区分大小写,但建议关键字大写，表名、列名小写 每条命令最好用分号结尾 每条命令根据需要，可以进行缩进 或换行 注释 单行注释：#注释文字 单行注释：– 注释文字 多行注释：/ 注释文字 / SQL语言分类 DQL（Data Query Language）：数据查询语言，例如：select DML(Data Manipulate Language):数据操作语言，例如：insert 、update、delete DDL（Data Define Languge）：数据定义语言，例如：create、drop、alter TCL（Transaction Control Language）：事务控制语言，例如：commit、rollback DQL语言学习基础查询语法 12SELECT 要查询的东西【FROM 表名】; 特点 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据 语法 123456select 要查询的字段|表达式|常量值|函数from 表where 条件 ; 分类 条件表达式，例如：salary&gt;10000，条件运算符：&gt; &lt; &gt;= &lt;= = != &lt;&gt; 逻辑表达式，例如：salary&gt;10000 &amp;&amp; salary&lt;20000，逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true 模糊查询，例如：last_name like ‘a%’ 排序查询语法 1234567select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 常见函数字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数 数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断 日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符 流程控制函数 if 处理双分支 case语句 处理多分支情况1：处理等值判断 情况2：处理条件判断 分组函数 sum 求和 max 最大值 min 最小值 avg 平均值 count 计数 分组函数说明 以上五个分组函数都忽略null值，除了count(*) sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持：字段、*、常量值，一般放1 分组查询语法 123select 查询的字段，分组函数from 表group by 分组的字段 分组查询特点 可以按单个字段分组 和分组函数一同查询的字段最好是分组后的字段 分组筛选 分组前筛选： 原始表 group by的前面 where 分组后筛选： 分组后的结果集 group by的后面 having 可以按多个字段分组，字段之间用逗号隔开 可以支持排序 having后可以支持别名 多表查询语法 12345678select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 子查询子查询含义 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 子查询特点 子查询都放在小括号内 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧 子查询优先于主查询执行，主查询使用了子查询的执行结果 子查询根据查询结果的行数不同分为以下两类 单行子查询：结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= ，非法使用子查询的情况：子查询的结果为一组值或者子查询的结果为空 多行子查询：结果集有多行，一般搭配多行操作符使用：any、all、in、not in，in： 属于子查询结果中的任意一个就行，any和all往往可以用其他查询代替 分页查询语法 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点 起始条目索引从0开始 limit子句放在查询语句的最后 公式：select from 表 limit （page-1）sizePerPage,sizePerPage 联合查询语法 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点 多条查询语句的查询的列数必须是一致的 多条查询语句的查询的列的类型几乎相同 union代表去重，union all代表不去重 DML语言学习插入语法 12insert into 表名(字段名，...)values(值1，...); 特点 字段类型和值类型一致或兼容，而且一一对应 可以为空的字段，可以不用插入值，或用null填充 不可以为空的字段，必须插入值 字段个数和值的个数必须一致 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法 12update 表名 set 字段=新值,字段=新值【where 条件】 修改多表语法 1234update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件 删除单表删除 1delete from 表名 【where 筛选条件】 多表删除 1234delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 使用truncate语句删除 1truncate table 表名 delelte和truncate区别 truncate不能加where条件，而delete可以加where条件 truncate的效率高一丢丢 truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始 delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 truncate删除不能回滚，delete删除可以回滚 DDL语言学习库和表管理库的管理 1234--创建库create database 库名--删除库drop database 库名 表的管理 123456789101112131415161718192021--创建表CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;--修改表 alterALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;--修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;--修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;--修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;--添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;--删除字段ALTER TABLE studentinfo DROP COLUMN email;--删除表DROP TABLE [IF EXISTS] studentinfo; 数据库事务概念通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点 A：原子性：要么都执行，要么都回滚 C：一致性：保证数据的状态操作前和操作后保持一致 I：隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 D：持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 使用事务步骤 开启事务 编写事务的一组逻辑操作单元（多条sql语句） 提交事务或回滚事务 事务分类隐式事务，没有明显的开启和结束事务的标志 例如：insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 12345671、开启事务 取消自动提交事务的功能 2、编写事务的一组逻辑操作单元（多条sql语句） insert update delete 3、提交事务或回滚事务 关键字1234567set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别当多个事务同时操作同一个数据库的相同数据时就会产生事务并发问题，常见的事务并发问题有如下几种 脏读：一个事务读取到了另外一个事务未提交的数据 不可重复读：同一个事务中，多次读取到的数据不一致 如何避免事务的并发问题 通过设置事务的隔离级别 READ UNCOMMITTED READ COMMITTED 可以避免脏读 REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读 SERIALIZABLE可以避免脏读、不可重复读和幻读 如何设置事务的隔离级别 1set session|global transaction isolation level 隔离级别名; 如何查看事务的隔离级别 1select @@tx_isolation; 视图视图可以理解为一张虚拟的表，视图和表的区别如下 使用方式 占用物理空间 视图 完全相同 不占用，仅保存的是SQL逻辑 表 完全相同 占用 使用视图的好处 sql语句提高重用性，效率高 和表实现了分离，提高了安全性 视图的创建123CREATE VIEW 视图名AS查询语句; 视图操作123456789--查看视图的数据 SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners';--插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);--修改视图的数据UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';--删除视图的数据DELETE FROM my_v4; 不能更新的视图 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all 常量视图 Select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表 视图删除1DROP VIEW test_v1,test_v2,test_v3; 查看视图结构12DESC test_v7;SHOW CREATE VIEW test_v7; 存储过程存储过程：一组经过预先编译的sql语句的集合 使用存储过程的好处 提高了sql语句的重用性，减少了开发程序员的压力 提高了效率 减少了传输次数 存储过程分类 无返回无参 仅仅带in类型，无返回有参 仅仅带out类型，有返回无参 既带in又带out，有返回有参 带inout，有返回有参 注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程1234create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 注意 1234567891011CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $-- 存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end-- 参数前面的符号的意思 -- in:该参数只能作为输入 （该参数不能做返回值） -- out：该参数只能作为输出（该参数只能做返回值） -- inout：既能做输入又能做输出 调用存储过程1call 存储过程名(实参列表)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://caochenhins.github.io/tags/Mysql/"}]},{"title":"MybatisPlus","slug":"MybatisPlus","date":"2019-03-21T14:39:32.000Z","updated":"2019-03-21T15:28:13.971Z","comments":true,"path":"2019/03/21/MybatisPlus/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/MybatisPlus/","excerpt":"一、MybatisPlus简介1.1.简介Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2.文档地址官网文档地址","text":"一、MybatisPlus简介1.1.简介Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2.文档地址官网文档地址 1.3.MybatisPlus的特性 无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性 依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 预防Sql注入：内置 Sql 注入剥离器，有效预防Sql注入攻击 通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题 支持热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动 支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作 支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（P.S. 比 Mybatis 官方的 Generator 更加强大！） 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 支持关键词自动转义：支持数据库关键词（order、key……）自动转义，还可自定义关键词 内置分页插件：基于 Mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作 二、集成MybatisPlus2.1.Maven导入MybatisPlus依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.0-gamma&lt;/version&gt;&lt;/dependency&gt; 2.2.修改sqpsessionFactoryBean123456789101112&lt;!-- 配置SqlSessionFactoryBean Mybatis提供的: org.mybatis.spring.SqlSessionFactoryBean MP提供的:com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean --&gt;&lt;!-- 配置sqlsessionFactoryBean --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!-- 别名处理 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.luo.beans\"&gt;&lt;/property&gt;&lt;/bean&gt; 三、入门的Hello World3.1.准备数据表123456789101112131415DROP TABLE IF EXISTS `tbl_user`;CREATE TABLE `tbl_user` ( `email` varchar(50) DEFAULT NULL, `age` int(11) DEFAULT NULL, `gender` char(255) DEFAULT NULL, `user_name` varchar(255) DEFAULT NULL, `id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;INSERT INTO `tbl_user` VALUES ('243518985@qq.com', 24, '1', '罗康元 ', 1);INSERT INTO `tbl_user` VALUES ('1835856@qq.com', 34, '2', '张三', 2);INSERT INTO `tbl_user` VALUES ('323134435@163.com', 53, '1', '李四', 3);INSERT INTO `tbl_user` VALUES ('345464566@qq.com', 43, '1', '王五', 4);INSERT INTO `tbl_user` VALUES ('luokangyuansb@gmail.com', 45, '1', '赵六', 5); 3.2.准备Java实体类123456789101112public class User &#123; private Integer id; private String userName; private String email; private Integer gender; private Integer age;&#125; 3.3.加入依赖的jar包1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;!-- mp依赖:mybatisPlus 会自动的维护Mybatis 以及MyBatis-spring相关的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.5.mybatis-config.xml文件12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt; 3.6.log4j.xml文件12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt; &lt;log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\"&gt; &lt;appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;param name=\"Encoding\" value=\"UTF-8\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=\"java.sql\"&gt; &lt;level value=\"debug\" /&gt; &lt;/logger&gt; &lt;logger name=\"org.apache.ibatis\"&gt; &lt;level value=\"info\" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=\"debug\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 3.7.db.properties文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Hongkongjdbc.username=rootjdbc.password=jiamei@20141107. 3.8.applicationContext.xml文件123456789101112131415161718192021222324252627282930&lt;!-- 数据源 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\" /&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务管理器 --&gt;&lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--基于注解的事务管理 --&gt;&lt;tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" /&gt;&lt;!-- 配置SqlSessionFactoryBean Mybatis提供的: org.mybatis.spring.SqlSessionFactoryBean MP提供的:com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean --&gt;&lt;!-- 配置sqlsessionFactoryBean --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!-- 别名处理 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.luo.beans\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置mybatis扫描的mapper接口路径--&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.luo.mapper\"&gt;&lt;/property&gt;&lt;/bean&gt; 3.9.通用的CRUD操作假设我们有一张user表，我们需要对这个表进行增删改查操作，如果说没有代码生成的话，在mybatis我们需要编写UserMapper接口，手写CRUD方法，在UserMapper.xml文件中写对应的sql语句，但是，在MybatisPlus中，我们只需要创建UserMapper接口，继承BaseMapper接口，就可以完成CRUD操作，甚至不需要创建SQl映射文件。 123public interface UserMapper extends BaseMapper&lt;User&gt;&#123;&#125; 然后，我们就写一些基本的单元测试方法，测试我们的CRUD，来到我们的测试类中，如下： 123456public class TestMp &#123; private ApplicationContext ioc = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); private UserMapper userMapper = ioc.getBean(\"userMapper\",UserMapper.class);&#125; 说明：在测试类中我们将使用从SpringIOC容器中获取的userMapper进行CRUD一系列操作 保存一条数据userMapper.insert(user); 123456789101112@Testpublic void insert()&#123; User user = new User(); user.setUserName(\"luokangyuan\"); user.setAge(66); user.setEmail(\"2356775645@qq.com\"); user.setGender(2); Integer result = userMapper.insert(user); System.out.println(result); // 直接获取插入数据返回的自增主键值 System.out.println(user.getId()+\"======\");&#125; 插入数据的方法有两个：insert和insertAllColumn，二者的执行结果是一样的，区别在于，前者会根据实体类的每一个属性值进行一个非空校验，在插入的sql语句中不会出现实体类属性为空的字段； 注意：在没有使用全局配置之前，我们需要指定实体类对应的数据库表和主键生成策略 主键生成策略：@TableId(type = IdType.AUTO,value = &quot;id&quot;),value属性值当实体类字段名和数据库一致时可以不写，这里的value指的是数据库字段名称，type的类型有以下几种： IdType.AUTO：数据库ID自增 IdType.INPUT：用户输入ID IdType.ID_WORKER：全局唯一ID，内容为空自动填充（默认配置） IdType.UUID：全局唯一ID，内容为空自动填充 实体对应表名注解：@TableName(value = &quot;tbl_user&quot;);指定当前实体类对应的数据库表 数据库字段映射名称：@TableField(value = &quot;user_name&quot;),当禁止驼峰映射规则后可以使用 忽略插入到表的字段：@ableField(exist = false),如下，数据库没有money这个字段，如果不忽略，那么插入就会报错，找不到这个字段； 12@TableField(exist = false)private Double money; 更新一条数据 12345678910@Testpublic void update()&#123; User user = new User(); user.setId(7); user.setUserName(\"王八\"); user.setAge(56); //user.setEmail(\"2356775645@qq.com\"); user.setGender(2); Integer result = userMapper.updateById(user);&#125; 同理：更新方法也有两个updateById和updateAllColumnById,前者会对实体类属性名进行非空校验，为空的就不会出现在sql语句中，也就是不会更新原有数据，后者是会更新所有列，如果实体类属性值为空，则数据库对应字段名更新为null； 查询一条数据 12345678910111213141516171819202122232425@Testpublic void select()&#123; // 1.通过ID查询一条数据 User user = userMapper.selectById(7); // 2.通过多个列进行查询,如果查处的数据有多条就会报错 User u = new User(); u.setId(2); u.setUserName(\"张三\"); User user1 = userMapper.selectOne(u); // 3.查询符合多个ID的数据,使用的是in关键字查询 List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(3); ids.add(4); ids.add(5); List&lt;User&gt; users = userMapper.selectBatchIds(ids); // 4.通过封装map条件,注意的是封装的是列字段名，不是实体里属性名， // map中的key充当sql中的条件名称 Map&lt;String,Object&gt; maps = new HashMap&lt;String, Object&gt;(); maps.put(\"user_name\",\"张三\"); maps.put(\"age\",347); List&lt;User&gt; users1 = userMapper.selectByMap(maps); // 5.分页查询方法,查看第二页，每页2条数据,在sql语句并没有limit关键字 // 所以要实现物理分页，还需借助插件，例如mybatis的pageHepler或者MybatisPlus提供的分页插件 List&lt;User&gt; users2 = userMapper.selectPage(new Page&lt;User&gt;(2, 2), null);&#125; 删除一条数据 123456789101112131415@Testpublic void delete()&#123; // 1.根据ID删除 Integer integer = userMapper.deleteById(8); // 2.根据条件删除，map中的key为列名，千万注意 Map&lt;String ,Object&gt; maps = new HashMap&lt;String, Object&gt;(); maps.put(\"age\",66); maps.put(\"gender\",2); Integer integer1 = userMapper.deleteByMap(maps); // 3.根据ID批量删除,使用in关键字 List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(5); ids.add(7); Integer integer2 = userMapper.deleteBatchIds(ids);&#125; 3.10.MybatisPlus全局配置在前面的CRUD操作中，我们会使用直接注解指定主键生成策略和表名到实体类的映射，但是配置的仅仅会对当前实体类起作用，所以，引入了全局配置，如下： 123456789&lt;!-- 定义MybatisPlus的全局策略配置--&gt;&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt;&lt;/bean&gt; 然后，将MybatisPlus全局配置注入到sqlSessionFactoryBean中 12&lt;!-- 注入全局MP策略配置 --&gt;&lt;property name=\"globalConfig\" ref=\"globalConfiguration\"&gt;&lt;/property&gt; 3.11.mybatisPlusCRUD总结在前面，我们实现了基本的CRUD操作，操作简单，仅仅只需继承一个BaseMapper就可以完成，实现单一，批量，分页等等一系列操作，很大的减少了开发负担，但这仅仅是Mybatisplus的冰山一角，当我们需要多条件查询的时候，就会使用到MybatisPlus中强大的条件构造器EntityWrapper； 四、条件查询条件构造器就是EntityWrapper，就是一个封装查询条件对象，让开发者自由的定义查询条件，主要用于sql的拼接，排序或者实体参数等；条件构造器 注意：使用的参数是数据库字段名称，不是Java类属性名 4.1.selectPage中的条件查询1234567891011@Testpublic void entityWrapperTedst()&#123; // 分页查询第一页，每页2条记录，年龄在41-53之间，genger为1，user_name为王五的用户 List&lt;User&gt; users = userMapper.selectPage(new Page&lt;User&gt;(1, 2), new EntityWrapper&lt;User&gt;() .between(\"age\", 41, 53) .eq(\"gender\",1) .eq(\"user_name\",\"王五\") );&#125; 4.2.模糊查询和或查询123456789@Testpublic void selectListTest()&#123; List&lt;User&gt; users = userMapper.selectList(new EntityWrapper&lt;User&gt;() .eq(\"gender\", 1) .like(\"user_name\", \"三\") .orNew() .like(\"email\", \"5\") );&#125; 使用或条件查询可以使用or()也可以使用orNew(),二者的区别在于sql中的条件部分不一样，如下： 使用or()的sql语句 1SELECT id AS id,user_name AS userName,email,gender,age FROM tbl_user WHERE (gender = ? AND user_name LIKE ? OR email LIKE ?) 使用orNew()的sql语句 1SELECT id AS id,user_name AS userName,email,gender,age FROM tbl_user WHERE (gender = ? AND user_name LIKE ?) OR (email LIKE ?) 4.3.修改满足条件的数据1234567891011@Testpublic void updataByEntityWrapper()&#123; User user = new User(); user.setEmail(\"luokangyuan@sina,com\"); user.setAge(24); user.setUserName(\"四川麻酱\"); Integer update = userMapper.update(user, new EntityWrapper&lt;User&gt;() .eq(\"user_name\",\"李四\") .eq(\"age\",53) );&#125; 4.4.删除满足条件的数据1234567@Testpublic void deleteByEntityWrapper()&#123; userMapper.delete(new EntityWrapper&lt;User&gt;() .eq(\"user_name\",\"王八\") .eq(\"age\",56) );&#125; 4.5.条件查询之ConditionCondition继承了Wrapper类，另外，我们不需要再new一个Condition对象，直接调用condition类的静态方法create就可以得到一个condition对象，然后使用wrapper的所有方法，简单使用如下： 123456@Testpublic void testCondition()&#123; userMapper.selectPage(new Page&lt;User&gt;(1,2), Condition.create() .between(\"age\",45,56) );&#125; 五、活动记录ARActive Record(活动记录)，简称AR，是一种领域模型模式，特点就是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一条记录； 5.1.开启AR模式开启AR模式的方法很简单，就是让我们的实体类继承Model类，并实现其抽象方法，指定主键即可，如下 1234567public class User extends Model&lt;User&gt; &#123; @Override protected Serializable pkVal() &#123; return id; &#125;&#125; 5.2.插入一条数据123456789@Testpublic void insert()&#123; User user = new User(); user.setUserName(\"杉木\"); user.setAge(25); user.setEmail(\"shancnu@163.com\"); user.setGender(1); boolean rs = user.insert();&#125; 5.3.修改一条数据12345678@Testpublic void update()&#123; User user = new User(); user.setUserName(\"杉木博客\"); user.setAge(35); user.setId(10); boolean rs = user.updateById();&#125; 说明：和通用的CRUD中的更新方法一样，updateAllColumnById()会更新所有列 5.4.查询数据12345678910111213141516@Testpublic void select()&#123; User user = new User(); user.setId(2); // 根据ID查询一条数据 User user1 = user.selectById(); // 查询所有的数据 List&lt;User&gt; users = user.selectAll(); // 根据条件查询 List&lt;User&gt; usersList = user.selectList(new EntityWrapper&lt;User&gt;() .like(\"user_name\", \"三\")); // 统计满足条件的数据数量 int gender = user.selectCount(new EntityWrapper&lt;User&gt;().eq(\"gender\", 1)); // 统计全表数量 int count = user.selectCount(null);&#125; 5.5.删除一条数据1234567@Testpublic void delete()&#123; User user = new User(); user.setId(7); boolean rs = user.deleteById(); System.out.print(rs);&#125; 当然，也可以根据条件删除多条数据，这里需要注意的是：当删除不存在的数据时候，返回的结果也是true； 1234// 删除不存在逻辑属于成功public static boolean delBool(Integer result) &#123; return null != result &amp;&amp; result &gt;= 0;&#125; 5.6.分页查询数据在前面的CRUD中的分页查询返回的是list数据集合，但是在AR中返回的却是Page对象，如下 1234567@Testpublic void selectPage()&#123; User user = new User(); Page&lt;User&gt; userPage = user.selectPage(new Page&lt;User&gt;(1, 2), new EntityWrapper&lt;User&gt;().like(\"user_name\", \"三\")); List&lt;User&gt; records = userPage.getRecords();&#125; 5.7.AR总结AR提供的是一种更为快速的实现CRUD操作，本质很是调用Mybatis对应的方法，说的简单一点就是语法糖； 糖虽然好吃，但是，不要管不住嘴； 六、代码生成器我们知道mybatis有一个代码生成器MBG，可以生成Java实体类mapper接口和映射文件，但是MybatisPlus却更加强大，可以生成service和controller，可以配置实体类是否支持AR等，代码生成器 说明：建议数据库表名和字段名采用驼峰命名方式，和实体来一致，可以避免在对应实体类产生的性能损耗 6.1.导入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 说明：MybatisPlus默认使用的是velocity模版引 6.2.编写配置类12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void testMbg()&#123; // 1.全局配置 GlobalConfig globalConfig = new GlobalConfig(); globalConfig.setActiveRecord(true)// 是否开启AR模式 .setAuthor(\"luokangyuan\") // 指定作者 .setOutputDir(\"/Users/luokangyuan/Documents/project/mybatisdemo/src/main/java\") .setFileOverride(true) // 指定文件覆盖 .setIdType(IdType.AUTO) // 设置主键自增策略 .setServiceImplName(\"%sService\") // 设置生成的services接口的名字的首字母是否为I .setBaseResultMap(true) // 基本的字段映射 .setBaseColumnList(true); // 基本的sql片段 // 2.配置数据源 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setDbType(DbType.MYSQL) // 设置数据库类型 .setDriverName(\"com.mysql.jdbc.Driver\") .setUrl(\"jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Hongkong\") .setUsername(\"root\") .setPassword(\"jiamei@20141107.\"); // 3.策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true) //全局大写命名 .setDbColumnUnderline(true) // 指定表名和字段名是否使用了下划线 .setNaming(NamingStrategy.underline_to_camel) // 数据库字段下划线转驼峰命令策略 .setTablePrefix(\"tbl_\") // 设置表前缀 .setInclude(\"tbl_dept\",\"tbl_file\"); // 设置需要生成的表 // 4.包名策略配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(\"com.luo\") // 设置父包 .setMapper(\"mapper\") .setService(\"service\") .setController(\"controller\") .setEntity(\"beans\") .setXml(\"mapper\"); // 5. 开始生成代码 AutoGenerator autoGenerator = new AutoGenerator(); autoGenerator.setGlobalConfig(globalConfig) .setDataSource(dataSourceConfig) .setStrategy(strategyConfig) .setPackageInfo(packageConfig); autoGenerator.execute();&#125; 6.3.生成的service代码查看1234@Servicepublic class DeptService extends ServiceImpl&lt;DeptMapper, Dept&gt; implements IDeptService &#123;&#125; DeptService继承了ServiceImpl，在ServiceImpl中就已经注入了DeptMapper，所以，我们就不需要再次注入，在ServiceImpl中也帮我们提供了常用的CRUD方法，我们可以直接使用， 1234567891011@Controller@RequestMapping(\"/dept\")public class DeptController &#123; @Autowired private IDeptService service; public String select()&#123; service.selectList(null); return null; &#125;&#125; 七、插件扩展7.1.注册分页插件1234567891011121314&lt;bean id=\"sqlSessionFactoryBean\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!-- 别名处理 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.luo.beans\"&gt;&lt;/property&gt; &lt;!-- 注入全局MP策略配置 --&gt; &lt;property name=\"globalConfig\" ref=\"globalConfiguration\"&gt;&lt;/property&gt; &lt;property name=\"plugins\"&gt; &lt;list&gt; &lt;bean class=\"com.baomidou.mybatisplus.plugins.PaginationInterceptor\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 真正的分页查询 12345678910111213141516ApplicationContext ioc = new ClassPathXmlApplicationContext(\"applicationContext.xml\");private UserMapper userMapper = ioc.getBean(\"userMapper\",UserMapper.class);@Testpublic void testPage()&#123; Page&lt;User&gt; page = new Page&lt;User&gt;(1,4); List&lt;User&gt; users = userMapper.selectPage(page,null); page.setRecords(users); System.out.print(\"总记录数\"+page.getTotal()); System.out.print(\"当前页码\"+page.getCurrent()); System.out.print(\"总页码\"+page.getPages()); System.out.print(\"每页记录数\"+page.getSize()); System.out.print(\"是否有前一页\"+page.hasPrevious()); System.out.print(\"是否有后一页\"+page.hasNext());&#125; 说明：我们可以将分页查询的数据放在page对象中，返回前端一个page对象即可 7.2.执行分析插件123&lt;bean class=\"com.baomidou.mybatisplus.plugins.SqlExplainInterceptor\"&gt; &lt;property name=\"stopProceed\" value=\"true\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试如下： 1234@Testpublic void testDeltetAll()&#123; userMapper.delete(null);&#125; sql分析插件只支持mysql5.6.3以上的版本，本质就是通过sql分析命令Explain分析当前的sql语句，根据结果集中的Extra列来断定当前是否全表操作； 7.3.性能分析插件性能分析插件用于输出每秒sql语句和其执行时间,首先注册插件，如下： 123&lt;bean class=\"com.baomidou.mybatisplus.plugins.PerformanceInterceptor\"&gt; &lt;property name=\"format\" value=\"true\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试如下： 12345678@Testpublic void testPer()&#123; Dept dept = new Dept(); dept.setDeptName(\"开发部\"); dept.setDeptCount(\"34\"); dept.setDeptBegintime(new Date()); dept.insert();&#125; 结果如下： 12345678Time：142 ms - ID：com.luo.mapper.DeptMapper.insertExecute SQL： INSERT INTO tbl_dept ( dept_count, dept_name, dept_beginTime ) VALUES ( '34', '开发部', '2018-08-26 23:09:17.293' )] 7.4.乐观锁插件当我们在开发中，有时需要判断，当我们更新一条数据库记录时，希望这条记录没有被别人更新，这个时候就可以使用乐观锁插件，他的原理就是，取出记录时，获取当前的version，更新的时候带上这个version，执行更新的时候set version = yourVersion+1 where version = yourVersion,如果version不对，则更新失败，注意的是：@version用于注解实体字段，必须要有； 首先，注册插件 1&lt;bean class=\"com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor\"&gt;&lt;/bean&gt; 实体类添加对应属性,同时数据库表也要添加对应字段 12@Versionprivate Integer version; 测试如下： 12345678@Testpublic void testVersion()&#123; Dept dept = new Dept(); dept.setDeptName(\"测试部\"); dept.setVersion(1); dept.setId(1); dept.updateById();&#125; 如果：这个时候将数据库version改为2，在执行更新就会显示更新记录数为0； 八、自定义全局操作8.1.自定义全局实例自定义全局操作，就是将我们需要的sql在项目启动的时候就注入到全局中，操作步骤如下： 在Mapper接口中定义我们需要注入的方法； 扩展AutoSqlInjector中的inject方法，实现Mapper中我们自定义方法要注入的sql； 最后，在全局配置中，配置我们自定义的注入器即可； 第一步：mapper中定义方法 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123; int deleteAll();&#125; 第二步：重写inject方法 1234567891011121314public class MySqlInjector extends AutoSqlInjector &#123; @Override public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table) &#123; // 构造sql语句 String sql = \"delete from \" + table.getTableName(); // 构造方法名 String method = \"deleteAll\"; // 构造SqlSource对象 SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass); // 构造一个删除的MapperStatement this.addDeleteMappedStatement(mapperClass,method,sqlSource); &#125;&#125;ß 第三步：注入自定义配置 1234567891011&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt; &lt;!--注入自定义全局操作--&gt; &lt;property name=\"sqlInjector\" ref=\"mySqlInjector\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean class=\"com.luo.injector.MySqlInjector\" id=\"mySqlInjector\"&gt;&lt;/bean&gt; 测试 12345678ApplicationContext ioc = new ClassPathXmlApplicationContext(\"applicationContext.xml\");private UserMapper userMapper = ioc.getBean(\"userMapper\",UserMapper.class);@Testpublic void testInject()&#123; int rs = userMapper.deleteAll();&#125; 8.2.逻辑删除所谓逻辑删除，就是不真正的删除数据的记录，而是变为无效状态，在MybatisPlus中，给我们提供logicSqlInjector 第一步：数据库添加逻辑字段 第二步：实体类添加对应属性和注解 12@TableLogicprivate Integer logicFlag; 第三步：MybatisPlus全局配置中加入logicSqlInjector 123456789101112131415&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt; &lt;!--注入自定义全局操作--&gt; &lt;property ref=\"logicSqlInjector\" name=\"sqlInjector\"&gt;&lt;/property&gt; &lt;!--注入逻辑删除全局值--&gt; &lt;property name=\"logicDeleteValue\" value=\"-1\"&gt;&lt;/property&gt; &lt;property name=\"logicNotDeleteValue\" value=\"1\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--逻辑删除--&gt;&lt;bean class=\"com.baomidou.mybatisplus.mapper.LogicSqlInjector\" id=\"logicSqlInjector\"&gt;&lt;/bean&gt; 测试 1234@Testpublic void testLogin()&#123; Integer integer = userMapper.deleteById(1);&#125; 说明：我们做的是删除操作，但是，执行的却是update操作，同时，查询的时候自动添加了有效判断 九、公共字段填充这里涉及到一个元数据处理接口MetaObjectHandler,元对象是Mybatis提供的一个用于更加方便，更加优雅的访问对象的属性，给对象的属性赋值的一个对象，本质上metaObject获取对象的值或者是给对象的属性赋值，都是通过反射获取到属性对应方法的Invoker； 9.1.使用实例第一步：注解需要填充的字段 12@TableField(value = \"user_name\",fill = FieldFill.INSERT_UPDATE)private String userName; 第二步：自定义填充处理器 12345678910111213141516171819202122232425public class MetaHandler extends MetaObjectHandler &#123; /** * 插入操作：自动填充 * @param metaObject */ public void insertFill(MetaObject metaObject) &#123; // 获取到需要被填充的字段值 Object userName = getFieldValByName(\"userName\", metaObject); if(userName == null)&#123; setFieldValByName(\"userName\",\"四川码酱\",metaObject); &#125; &#125; /** * 更新操作：自动填充 * @param metaObject */ public void updateFill(MetaObject metaObject) &#123; // 获取到需要被填充的字段值 Object userName = getFieldValByName(\"userName\", metaObject); if(userName == null)&#123; setFieldValByName(\"userName\",\"康哥哥\",metaObject); &#125; &#125;&#125; 第三步：注入全局配置 123456789101112131415161718&lt;bean id =\"globalConfiguration\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\"&gt; &lt;!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射--&gt; &lt;property name=\"dbColumnUnderline\" value=\"true\"&gt;&lt;/property&gt; &lt;!-- 全局的主键策略 --&gt; &lt;property name=\"idType\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 全局的表前缀策略配置 --&gt; &lt;property name=\"tablePrefix\" value=\"tbl_\"&gt;&lt;/property&gt; &lt;!--注入自定义全局操作--&gt; &lt;!--&lt;property name=\"sqlInjector\" ref=\"mySqlInjector\"&gt;&lt;/property&gt;--&gt; &lt;property ref=\"logicSqlInjector\" name=\"sqlInjector\"&gt;&lt;/property&gt; &lt;!--注入逻辑删除全局值--&gt; &lt;property name=\"logicDeleteValue\" value=\"-1\"&gt;&lt;/property&gt; &lt;property name=\"logicNotDeleteValue\" value=\"1\"&gt;&lt;/property&gt; &lt;!--注入公共字段填充处理器--&gt; &lt;property name=\"metaObjectHandler\" ref=\"metaHandler\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--自定义公共字段填充处理器--&gt;&lt;bean class=\"com.luo.bandler.MetaHandler\" id=\"metaHandler\"&gt;&lt;/bean&gt; 第四步：测试 1234567@Testpublic void testCom()&#123; User user = new User(); user.setId(11); user.setLogicFlag(1); user.updateById();&#125; 十、IEDA开发插件10.1.安装方法打开IDEA设置–Plugins–Browse repositories –搜索mybatisx,安装即可 10.2.支持的功能根据mapper接口方法自动生成xml文件，接口方法定位xml,xml自动定位mapper接口；","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://caochenhins.github.io/tags/MybatisPlus/"}]},{"title":"jQuery学习总结","slug":"jQuery学习总结","date":"2019-03-21T14:39:04.000Z","updated":"2019-03-21T15:20:24.054Z","comments":true,"path":"2019/03/21/jQuery学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/jQuery学习总结/","excerpt":"jQuery学习笔记jQuery简介jQuery是一个优秀的JS函数库,其官网可以看一下，jQuery包含了HTML元素选取，HTML元素操作，CSS操作，HTML事件等内容。 jQuery的两把利器jQuery核心函数jQuery核心函数就是$或者jQuery，它定义了这个全局的函数供我们使用，它既可以用于一般的函数调用，且传递的参数类型不同，格式不同功能就完全不同，也可以作为对象调用其定义好的方法，此时的$就是一个工具对象。","text":"jQuery学习笔记jQuery简介jQuery是一个优秀的JS函数库,其官网可以看一下，jQuery包含了HTML元素选取，HTML元素操作，CSS操作，HTML事件等内容。 jQuery的两把利器jQuery核心函数jQuery核心函数就是$或者jQuery，它定义了这个全局的函数供我们使用，它既可以用于一般的函数调用，且传递的参数类型不同，格式不同功能就完全不同，也可以作为对象调用其定义好的方法，此时的$就是一个工具对象。 作为函数调用 参数为函数即$(function) 参数为选择器字符串即$(&quot;#btn&quot;) 参数为DOM对象即$(div) 参数为html标签字符串即$(&quot;&lt;div&gt;&quot;) 123456789101112&lt;body&gt; &lt;input type=\"text\" name=\"userName\" id=\"userName\" /&gt; &lt;button id=\"search\" value=\"搜索\"&gt;搜索&lt;/button&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.1.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123;/*绑定文档加载完成的监听*/ $('#search').click(function()&#123;/*给按钮添加点击监听事件*/ var userName = $('#userName').val();/*获取DOM元素的值*/ &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 说明：上述代码使用了jQuery核心函数：$/jQuery，使用了jQuery核心对象：执行$()返回的对象，$(&#39;#search&#39;) 作为函数的时候，不同参数实例 123456789101112131415161718192021&lt;body&gt; &lt;div&gt; &lt;button id=\"btn\"&gt;确定&lt;/button&gt; &lt;input type=\"text\" name=\"msg1\" /&gt; &lt;input type=\"text\" name=\"msg2\" /&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.10.1.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123;/*参数为函数即$(function):执行此回调函数*/ /*参数为选择器字符串即$(\"#btn\"):查找所匹配的标签，并将他们封装为jQuery对象*/ $('#btn').click(function()&#123;/*绑定监听事件*/ alert(this.innerHTML)/*this:发生事件的DOM元素*/ /*参数为DOM对象即$(div):此时的this就是一个DOM元素， *此时将dom对象封装为jQuery对象，就可以使用jQuery对象的方法*/ alert($(this).html()) /*参数为html标签字符串即$(\"&lt;div&gt;\"):创建标签对象，并封装为jQuery对象*/ $('&lt;input type=\"text\" name=\"msg3\" /&gt;').appendTo('div'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 作为对象使用作为对象使用的时候，时长用于发送AJAX请求或者遍历数组等，例如$.ajax()，$.each()，$.get()，实例如下： 12345678var arr = [2,3,4];/*$.each():隐式遍历数组 */$.each(arr,function(index,item)&#123; console.log(index,item)&#125;)/*$.trim():去除两端空格*/var str = ' Hello Word 'console.log($.trim(str)); jQuery核心对象即执行jQuery核心函数返回的对象，jQuery对象内部包含的是dom元素对象的伪数组(可能只有一个元素)，jQuery对象拥有很多有用的属性和方法, 让程序员能方便的操作dom 属性和方法 基本行为：size()/length，[index]/get(index)，each()，index() 属性：操作内部标签的属性或值 CSS：操作标签的样式 文档：对标签进行增删改操作 筛选：根据指定的规则过滤内部的标签 事件：处理事件监听相关 效果：实现一些动画效果 使用jQuery核心函数选择器","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://caochenhins.github.io/tags/jQuery/"}]},{"title":"JavaScript学习总结","slug":"JavaScript学习总结","date":"2019-03-21T14:38:15.000Z","updated":"2019-03-21T15:19:09.699Z","comments":true,"path":"2019/03/21/JavaScript学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaScript学习总结/","excerpt":"JavaScript基础部分JavaScript简介JavaScript实现JavaScript是一种专门为网页交互设计的脚本语言，有以下三部分组成： ECMAScript，提供和核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口； HTML中使用JavaScript","text":"JavaScript基础部分JavaScript简介JavaScript实现JavaScript是一种专门为网页交互设计的脚本语言，有以下三部分组成： ECMAScript，提供和核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口； HTML中使用JavaScript 标签的位置传统位置将JavaScript放在title后面 12345&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../js/index.js\"&gt;&lt;/script&gt;&lt;/head&gt; 由于解析网页的时候按照从上到写的加载原则，只有等所有的JavaScript文件加载成功后页面才能显示，如果JavaScript文件有一处错误，那么整个页面都就是一片空白，因此，位置应该放置与body内容后面，如下： 1234&lt;body&gt; &lt;!--这里放页面内容--&gt; &lt;script type=\"text/javascript\" src=\"../js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt; JavaScript基本概念JavaScript语法严格区分大小写 在ECMAScript中的一切变量，函数名和操作符都严格区分大小写，例如变量名test和Test是两个不同的变量名。 标识符 标识符就是指变量，函数，属性的名字，或者函数的参数名，标识符是由满足下列规则组合的一个或者多个字符 第一个字符必须是一个字母、下划线（_）或者一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或者数字； 标识符一般采用驼峰命名法，首字母小写，每一个单词的开头字母大写（规范，不是强制要求） 注意：不能将关键字，保留字，true，false和null用作标识符 注释 ECMAScript中有单行注释和块级注释，单行注释以两个斜杠开头，块级注释以一个斜杠加一个星号开头（/*），一个星号加一个斜杠结尾。 语句 ECMAScript语句以一个分号结尾，虽然不加分号也是能运行的，但是不加分号，是浏览器很会帮我们添加分号，这样依赖降低性能，二来，浏览器有时会加错分号的位置，所以，养成良好的代码编写风格，自己加。 关键字和保留字在ECMAScript中具有特定用途的标识符称之为关键字，这些关键字可表示控制语句的开始或者结束，或者用于描述一个变量等，如下： breake；do；instanceof；typeof；case；else；new；var,catch；finally；return； void；continue；for；switch；while；default；if,throw；delete；in；try； function；this；with；debugger；false；true；null 还存在一些没有特殊用途的标识符，但是以后可能有特殊用途的标识符称之为保留字，如下： class ；enum；extends；super；const；export； import；implements；le:；private；public；yield；interface；package；protected；static 说明：在ES6中已经将let作为关键字定义变量 JavaScript数据类型变量在ES中，变量是松散类型的，所谓松散类型就是说变量可以保存任何类型的数据，换句话说，这个变量仅仅是一个用于保存值的占位符，使用关键字var，在ES6中推荐使用let关键字； 数据类型在ES中定义了六种数据类型，其中包含了五种基本数据类型，分别是：String，Number，Boolean，Null，Underfined和一种复杂数据类型Object； typeof操作符因为在ES中的数据类型是松散类型的，因此需要一种手段来检测变量的数据类型，这个时候就使用typeof，使用该操作符可能返回以下值，分别为： underfined：表示这个值未定义； boolean：表示这个值是布尔值； string：表示这个值是一个字符串； number：表示这个值是一个数值； object：表示这个值是一个对象或者null； function：表示这个值是一个函数； 123var a = \"hello\"console.log(typeof a);console.log(Number.MAX_VALUE * Number.MAX_VALUE)/*返回的是Infinity无穷大*/ Undefined类型Undefined类型就只有一个undefined值，在使用var定义变量后，未初始化该变量，那么使用typeof检测，返回的就是undefined，例如： 123var message;console.log(message)/*undefined*/console.log(message == undefined);/*true*/ Null类型NULL类型也只有一个NULL值，从逻辑角度看，这个NULL值代表的是一个空对象指针，所以当我们使用typeof null返回的是Object，如下： 12var user = null;console.log(typeof user);/*object*/ 注意：如果定义变量是在将来用于保存对象，那么最好在定义的时候就初始化为NULL Boolean类型Boolean类型有两个值，分别为:true，false；这两个值和数字值没有关系，true并不代表1，如下： 12var message = false;var test = true; 注意：Boolean类型的值是区分大小写的，True和False，或者大小写混写都只是代表标识符，不是Boolean值； 虽然Boolean类型的值只有两个，但是在ES中任何类型的值都可以与这两个Boolean值有着等价的值，要将一个值转换为对应的Boolean值，可以调用转型函数Boolean()，如下所示： 1234var test = \"Helo\";var testBoolean = Boolean(test);console.log(typeof testBoolean)/*boolean*/console.log(testBoolean);/*true*/ 有关各种数据类型的转换规则如下： String类型，非空字符转换为true，空字符串转换为false； number类型，任何非零数字值（包括无穷大），转换为true，0和NaN转换为false； Object类型，任何对象转换为true，NUL转换为false； 使用这些转换规则可以更方便的使用if流程语句，例如： 1234var message = \"Hello Word\";if(message)&#123; console.log(\"我执行了。。。\")/*该行代码会被执行*/&#125; Number类型ES中Number数据类型包含整数和浮点数值，在JavaScript中可以使用number类型保存正零和负零，正零和负零被认为是相等的。 浮点数值 在JavaScript中浮点数值就是数值中必须包含一个小数点，并且小数点后至少有一位数字，虽然小数点前面可以没有整数，但是不建议这种写法，如下： 123var floatN1 = \"1.1\";var floatN2 = \"0.1\";var floatN3 = \".1\";/*虽有效，但不推荐*/ 由于保存浮点数值需要的内存空间是整数的两倍，所以，只要可以将浮点数转换为整数，就会转换为整数，如下： 1var floatN1 = \"1.0\"; 当然也可以使用科学计数法，如下： 1var floatN1 = 3.12e7; 注意：使用浮点数值进行计算会产生误差的问题，所以和钱相关的就不要使用JavaScript计算了。 整数数值 由于内存的限制，JavaScript不可能保存最大的数值，所以就有了JavaScript中的最大值和最小值，如果超出这个值就会返回一个Infinity无穷大和-Infinity负无穷，如下 12console.log(Number.MIN_VALUE);/*5e-324*/console.log(Number.MAX_VALUE);/*1.7976931348623157e+308*/ 非数值NANNAN,是一个特殊的数值，表示一个本来应该返回数值的操作却没有返回数值的情况，例如任何数值除以非数值就会返回NAN，但是在其他编程语言中就会保存，就是程序的运行。有关非数值NAN需要注意以下几点： 任何涉及到NAN的操作都会返回NAN,例如NAN/10; 任何数值和NAN都不相等，包括NAN本身； 在JavaScript中针对NAN的特殊性，定义了isNaN()函数，这个函数接受一个参数，该参数可以是任何类型，这个函数可以帮我们确定这个参数是否是不是数值，这个函数接收一个参数后，会尝试将这个参数转换为数值类型，不能被转换的就会返回false，否则返回true，如下： 12345console.log(isNaN(NaN));/*true*/console.log(isNaN(10));/*false*/console.log(isNaN(\"10\"));/*false*/console.log(isNaN(\"hello\"));/*true*/ console.log(isNaN(true));/*false*/ 数值转换在JavaScript中有三个函数可以将非数值转换为数值类型，分别是：Number()、parseInt()和parseFloat(),其中Number()函数可以用于任何数据类型，而其他两个用于将字符串转换为数值，三个函数对于同样的输入却有不同的输出，具体的转换规则如下： Number()函数的转换规则 如果是Boolean值，则true和false分别转换为1和0； 如果是数字值，就只是简单的传入和返回； 如果是NULL，返回的是0； 如果是undefined，返回的是NAN； 如果是字符串，具体转换如下： 如果字符串只包含数字（包括前面的正负号），则将其转换为十进制数值； 如果字符串包含有效的浮点格式，就会转换为对应的浮点数值； 如果字符串包含有效的十六进制格式，就会转换为相同大小的十进制数值； 如果字符串是空字符串，则转换为数值0； 如果字符串不是以上类型的格式，就会转换为NaN； 如果是对象，则调用对象的valueOf()方法，然后按照上述的规则转换，如果转换结果为NaN，则调用对象的toString()方法，然后再按照上述规则转换； 1234console.log(Number(\"hello word\"))/*NaN*/console.log(Number(\"\"))/*0*/console.log(Number(\"0000011\"))/*11*/console.log(Number(true))/*1*/ parsenInt()函数转换规则 parsenInt()函数在转换数值的时候，注重的是看是否复合数值模式，它会忽略字符串前面的空格，直至找到第一个非空字符串，如果第一个字符串不是数字或者正负号，就返回NaN； 对空字符串，返回的是NaN,Number函数对于空字符串返回的是0 1234567console.log(parseInt(\"1234hello\"));/*1234*/console.log(parseInt(\"\"));/*NaN*/console.log(parseInt(\"0xA\"));/*十六进制：10*/console.log(parseInt(\"22.5\"));/*22*/console.log(parseInt(\"070\"));/*八进制：70*/console.log(parseInt(\"70\"));/*十进制：70*/console.log(parseInt(\"0xf\"));/*十六进制：15*/ parseFloat函数转换规则 从第一个字符开始解析，直到解析到字符串末尾结束，或者遇见一个无效的浮点数字字符位置； 字符串中的第一个小数点是有效的，第二个小数点是无效的； 如果字符串包含的是一个可解析为整数的数，则会返回整数； 123456console.log(parseFloat(\"1234hello\"));/*1234*/console.log(parseFloat(\"0xA\"));/*0*/console.log(parseFloat(\"22.5\"));/*22.5*/console.log(parseFloat(\"22.34.45\"));/*22.34*/console.log(parseFloat(\"0986.6\"));/*986.6*/console.log(parseFloat(\"3.144e7\"));/*31440000*/ String类型string类型用于表示由零个或者多个16位Unicode字符组成的字符串序列，就是字符串，在JavaScript中字符串可以使用单引号和双引号，但是不可混用。 转义字符 \\n：表示换行，\\t：表示制表符，\\b：表示退格，\\r：表示回车 \\\\:表示斜杠，\\&#39;：表示单引号，\\&quot;：表示双引号 说明：任何字符串可以通过length属性获取字符串的长度，例如：text.length 字符串的特点 在JavaScript中字符串是不可变的，换句话说，就是字符一旦创建，他的值就不能改变，要改变某一个变量的字符串，就要先销毁原来的字符串，在创建一个新的字符串值填充该变量。 转换为字符串 调用toString()方法；例如数值，布尔值，对象和字符串值都有toString方法；null和undefined没toString方法； 使用String()转型函数， 123456var num = 10;console.log(num.toString());/*\"10\"*/console.log(num.toString(2));/*按照二进制转换：\"1010\"*/console.log(num.toString(8));/*按照八进制转换：\"12\"*/console.log(num.toString(10));/*按照十进制转换：\"10\"*/console.log(num.toString(16));/*按照十六进制转换：\"a\"*/ 注意：调用toString方法可以指定基数，转换成不同的字符串 12345var value;console.log(String(10));/*\"10\"*/console.log(String(true));/*\"true\"*/console.log(String(null));/*\"null\"*/console.log(String(value));/*\"undefined\"*/ Object类型在JavaScript中对象是一组数据和功能的集合，对象通过new的方式创建，例如var u = new Object()，Object类型是所有它的实例的基础，也就是说，Object具有的任何属性和方法也都存在与具体的对象中，和java中的Object对象一样，Object具有的属性和方法如下： constructor：保存着用于创建当前对象的函数，构造函数constructor就是Object()； hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中是否存在； isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型； propertyIsEnumerable(propertyName)：用于检查给定的属性能否使用for-in语句来枚举； toLocaleString()：返回对象的字符串表示； toString()：返回对象的字符串表示； valueOf()：返回对象的字符串、数值或者布尔值。 JavaScript操作符一元操作符","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://caochenhins.github.io/tags/JavaScript/"}]},{"title":"JavaScript高级学习总结","slug":"JavaScript高级学习总结","date":"2019-03-21T14:37:52.000Z","updated":"2019-03-21T15:19:56.788Z","comments":true,"path":"2019/03/21/JavaScript高级学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaScript高级学习总结/","excerpt":"[TOC] JavaScript高级学习笔记基础总结数据类型","text":"[TOC] JavaScript高级学习笔记基础总结数据类型 数据类型分为两类，基本(值)类型（Number: 任意数值，String: 任意文本，Boolean: true/false，undefined: undefined，null: null）和对象类型（Object: 一般对象类型，Array: 特别的对象类型(下标/内部数据有序)，Function: 特别的对象类型(可执行)）。 数据类型的判别方法有typeof，instanceof和===，其中typeof可以区别: 数值, 字符串, 布尔值, undefined, function不能区别: null与对象, 一般对象与数组；instanceof专门用来判断对象数据的类型: Object, Array与Function；===可以判断: undefined和null； undefined与null的区别?undefined代表变量没有赋值，null: 代表变量赋值了, 只是值为null 什么时候将变量赋值为null?初始化赋值: 将要作为引用变量使用, 但对象还没有确定，结束时: 将变量指向的对象成为垃圾对象 严格区别变量类型与数据类型?js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型，变量类型包括基本类型( 保存基本类型数据的变量)引用类型(保存对象地址值的变量)，数据对象包括基本类型和对象类型 数据和变量和内存什么是数据？存储于内存中代表特定信息的’东西’, 本质就是0101二进制，具有可读和可传递的基本特性，万物(一切)皆数据, 函数也是数据，程序中所有操作的目标: 数据，例如：算术运算，逻辑运算，赋值，调用函数传参等； 什么是内存? 内存条通电后产生的存储空间(临时的)，产生和死亡: 内存条(集成电路板)==&gt;通电==&gt;产生一定容量的存储空间==&gt;存储各种数据==&gt;断电==&gt;内存全部消失，内存的空间是临时的, 而硬盘的空间是持久的，内存分为栈（全局变量, 局部变量 (空间较小)）和堆（对象 (空间较大)）；一块内存包含2个数据，分别为内部存储的数据(一般数据/地址数据)和内存地址值数据； 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据 释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用) 自动释放: 栈空间的局部变量 垃圾回调器回调: 堆空间的垃圾对象 什么是变量？值可以变化的量, 由变量名与变量值组成,一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容; 三者的关系内存是一个容器, 用来存储程序运行需要操作的数据，变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据 赋值和内存的问题对于var a = xxx,a内存中到底保存的是什么，当xxx是基本数据，对象和变量时保存对应的类型。 引用变量赋值问题2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见；2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象 在js调用函数时传递变量参数时, 是值传递还是引用传递?只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据，如果后一种看成是引用传递, 那就值传递和引用传递都可以有； 对象什么是对象代表现实中的某个事物, 是该事物在编程中的抽象；多个数据的集合体(封装体)；用于保存多个数据的容器 为什么要使用对象便于对多个数据进行统一管理 对象的组成属性：代表现实事物的状态数据，由属性名和属性值组成，属性名都是字符串类型, 属性值是任意类型 方法：代表现实事物的行为数据；是特别的属性==&gt;属性值是函数 如何访问对象内部数据通过.属性名的方式，还可以通过[&#39;属性名&#39;]的方式 函数什么是函数？具有特定功能的n条语句的封装体，只有函数是可执行的, 其它类型的数据是不可执行。 为什么要用函数? 提高代码复用和便于阅读和交流； 如何定义函数？ 函数声明加表达式的方式； 如何调用(执行)函数？可以通过如下几种方式调用定义的函数：test()，new test()，obj.test()，test.call/apply(obj) 回调函数什么函数才是回调函数？回调函数满足以下三个条件，你定义的，你没有直接调用，但最终它执行了(在特定条件或时刻)； 常见的回调函数？DOM事件函数；定时器函数；Ajax回调函数等； 匿名函数自调用IIEF全称: Immediately-Invoked Function Expression 立即调用函数表达式，别名: 匿名函数自调用，他的作用有两点隐藏内部实现和不污染外部命名空间；","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://caochenhins.github.io/tags/JavaScript/"}]},{"title":"JavaEE进阶知识学习-----SpringBoot学习总结","slug":"JavaEE进阶知识学习-SpringBoot学习总结","date":"2019-03-21T14:37:00.000Z","updated":"2019-03-21T15:19:16.842Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-SpringBoot学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-SpringBoot学习总结/","excerpt":"一、SpringBoot入门1.1.什么是SpringBoot采用官方的话说，SpringBoot是简化Spring应用开发的一个框架，将整个Spring技术全家桶进行整合，被称为JavaEE开发的一站式解决方案； 1.2.SpringBoot和SpringCloud的关系 SpringBoot是专注于快速方便的开发单个体微服务； SpringCloud是关注全局的微服务协调治理框架，他将多个SpringBoot开发的单个微服务进行整合管理，为微服务之间提供配置管理，服务发现等一系列服务； SpringBoot可以离开SpringCloud单独开发项目，但是SpringCloud离不来SpringBoot；","text":"一、SpringBoot入门1.1.什么是SpringBoot采用官方的话说，SpringBoot是简化Spring应用开发的一个框架，将整个Spring技术全家桶进行整合，被称为JavaEE开发的一站式解决方案； 1.2.SpringBoot和SpringCloud的关系 SpringBoot是专注于快速方便的开发单个体微服务； SpringCloud是关注全局的微服务协调治理框架，他将多个SpringBoot开发的单个微服务进行整合管理，为微服务之间提供配置管理，服务发现等一系列服务； SpringBoot可以离开SpringCloud单独开发项目，但是SpringCloud离不来SpringBoot； 1.3.SpringBoot的入门demo 使用IDEA开发工具，新建一个Spring Boot项目，只选中web模块，服务端响应请求，如下： 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello()&#123; return \"hello this is my first demo\"; &#125;&#125; 二、SpringBoot配置文件2.1.基本使用在项目的resource目录下，有一个SpringBoot的全局配置文件application.properties，当我们需要修改配置文件的时候就可以修改，如下，修改项目的端口号： 1server.port=8081 当然，properties配置文件也会存在很多重复的配置代码，这个时候就出现了一种新的配置文件application.yaml 12server: port: 8082 2.2.yaml语法说明在前面的使用中，大家也可以看到yaml语法是采用一对键值对（中间存在空格）,同时使用空格来控制层级关系，只要是左对齐的一列数据，就说明是一个层级的；需要注意的是；属性和值对大小写是敏感的； 1234567891011121314151617181920server: port: 8082# 在yaml语法中，值为数字，字符串或者布尔就直接写，字符串默认不用添加单引号或者双引号name: 你好# 字符串添加了双引号，代表特殊字符不会转义，会直接输出特殊字符所代表的含义，这里会换行lastName: \"你好 \\n 世界\"# 字符串添加了单引号，特殊字符会被转义，这个的换行就会被转义为一个普通的字符串firstname: '你好 \\ 世界'# 当值为对象，Map时，也是采用属性和值的写法，使用空格缩进来区分，如下所示person: name: luokangyuan age: 23# 另外一个写法user: &#123;name: luokangyuan, age: 34&#125;# 当值为数组，list或者set时候，使用-加空格的方式，如下：age: - man - woman# 数组的另外一种写法sport: [football,pingpang] 2.3.配置文件注入所谓的配置文件注入就是在java类中获取配置文件中配置的属性值，在SpringBoot中可以使用@Value注解和@ConfigurationProperties注解完成，两者的区别是：@value需要一个一个的绑定需要获取的属性值，不支持松散语法，不支持JSR303校验，也不支持复杂类型封装，仅支持SpEL，相对而言，@ConfigurationProperties就支持批量注入配置文件属性，支持JSR303数据校验，也支持复杂类型封装,当你只需要从配置文件中获取一个属性值的时候就可以使用@Value注解，当你需要将配置文件封装成一个JavaBean的时候，就可以使用@ConfigurationProperties注解，使用方法如下： 配置文件yaml中配置需要注入的属性值： 1234567891011121314# 配置文件注入systemuser: userName: luokangyuan age: 24 boss: false birthday: 1995/03/16 habbit: - football - basketball - pingpangball friend: &#123;cd: hanger,sc: biner&#125; dog: name: mengmeng age: 3 映射的实体类如下（省略了getter和setter）： 12345678910111213141516171819@Component@ConfigurationProperties(prefix = \"systemuser\")@Validatedpublic class SystemUser &#123; private String userName; private Integer age; private Boolean boss; private Date birthday; private List&lt;String&gt; habbit; private Map&lt;String,String&gt; friend; private Dog dog;&#125; 在SpringBoot的测试类中，使用@Autowired注解注入SystemUser类，然后在执行方法中打印，就可以看见我们已经从配置文件中获取到了属性值； 注意：如果，配置文件中的别名和实体类名第一个字母小写一样，就会报错，例如：systemUser 2.4.配置文件占位符在配置文件中我们可以使用占位符来给一些属性住设置默认值或者随机数等，例如${random.int(10)}，${random.uuid}或者使用冒号指定默认值 123cat: name: zhangsan$&#123;random.uuid&#125; fullName: $&#123;cat.name:xiaohong&#125;_cat 2.5.多个配置文件切换在SpringBoot的应用中可以书写多个配置文件，使用applocation-dev.properties来标识这是一个开发配置文件，在application.properties文件中使用配置spring.profiles.active = dev来激活我们需要的配置文件；如果使用yaml为配置文件格式，那么可以使用yaml特有的多文档模式来切换配置文件，如下： 123456789101112131415spring: profiles: active: prod---server: port: 8082spring: profiles: dev---server: port: 8084spring: profiles: prod 2.6.配置文件加载顺序SpringBoot启动后会顺序扫描:类路径下的config文件夹、项目根下的配置文件、classpath:config、classpath:/，优先级从高到低，高优先级的配置会覆盖低优先级的配置； 三、SLF4J日志框架日志框架就是记录系统运行时候产生了一些痕迹，方便问题的追踪和排查，这里我们说的是SLF4J+Logback 3.1.使用方法12345678910Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; logger.trace(\"这是trace日志信息\"); logger.debug(\"这是debug日志信息\"); logger.info(\"这是info日志信息\"); logger.warn(\"这是warn日志信息\"); logger.error(\"这是error日志信息\"); &#125; 当然你也可以在项目的配置文件中配置日志的输出格式，输出路径等信息，例如：logging.path配置在当前项目下生成log文件，使用logging.file指定完整的文件保存路径等等一些列都可以设置； 四、整合数据访问层4.1.整合JDBC数据访问pom.xml文件 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; application.yml文件 123456spring: datasource: username: root password: jiamei@20141107. url: jdbc:mysql://127.0.0.1:3306/springbootstydy driver-class-name: com.mysql.jdbc.Driver Springboot默认使用的数据源 1class com.zaxxer.hikari.HikariDataSource 说明：整合jdbc的时候，已经给我们自动配置的JdbcTemplate，直接注入使用即可； 12@Autowiredprivate JdbcTemplate jdbcTemplate; 4.2.整合Druid数据源引入pom文件 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; application.yaml文件 1234567spring: datasource: username: root password: jiamei@20141107. url: jdbc:mysql://127.0.0.1:3306/springbootstydy driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource application.yaml文件中增加数据源的其他配置 1234567891011121314151617# 数据源其他配置initialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: statmaxPoolPreparedStatementPerConnectionSize: 20useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 DruidConfig配置文件 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; /** * 配置Druid的监控 * @return */ @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),\"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123\"); initParams.put(\"allow\",\"\"); initParams.put(\"deny\",\"127.183,12,34\"); bean.setInitParameters(initParams); return bean; &#125; /** * 配置一个web监控的filter * @return */ @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter( new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 4.3.整合Mybatispom.xml文件 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 注解版的mapper接口 123456789101112131415@Mapperpublic interface UsersMapper &#123; @Select(\"select * from users where id = #&#123;id&#125;\") public Users getUsersById(Integer id); @Delete(\"delete from users where id = #&#123;id&#125;\") public int deleteUsersById(Integer id); @Insert(\"insert into users (id,name,sex,age,salary) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;salary&#125;)\") public int insertusers(Users users); @Update(\"update users set id = #&#123;id&#125;, name = #&#123;name&#125;, sex = #&#123;sex&#125;, age = #&#123;age&#125;, salary = #&#123;salary&#125; where id = #&#123;id&#125;\") public int updateUsersById(Users users);&#125; 说明：可以在启动主类上添加包扫描注解@MapperScan(value = &quot;com.luo.springboot.mapper&quot;)批量扫描mapper 配置文件的Mapper 123mybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*Mapper.xml 五、整合redis","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caochenhins.github.io/tags/SpringBoot/"}]},{"title":"JavaEE进阶知识学习-----PostgreSQL学习总结","slug":"JavaEE进阶知识学习-PostgreSQL学习总结","date":"2019-03-21T14:36:35.000Z","updated":"2019-03-21T15:18:35.744Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-PostgreSQL学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-PostgreSQL学习总结/","excerpt":"PostgreSQL基础部分PostgreSQL简介PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。","text":"PostgreSQL基础部分PostgreSQL简介PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。 PostgreSQL特点 PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。 PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。 PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。 在PostgreSQL中，表可以设置为从“父”表继承其特征。 可以安装多个扩展以向PostgreSQL添加附加功能。 PostgreSQL语法可以使用help语句查看所有postgreSQL语句的语法。 按照以下步骤查看PostgreSQL中所有语句的语法。 安装postgreSQL后，打开psql为：程序文件 -&gt; PostgreSQL 9.2 -&gt; SQL Shell(psql) 使用以下语句查看特定语句的语法。 postgres-＃\\ help＆ PostgreSQL数据类型数据类型指定要在表字段中存储哪种类型的数据。 在创建表时，对于每列必须使用数据类型。 以下是PostgreSQL中主要有三种类型的数据类型： 数值数据类型 字符串数据类型 日期/时间数据类型 数值数据类型 名称 描述 存储大小 范围 smallint 存储整数，小范围 2字节 -32768 至 +32767 integer 存储整数。使用这个类型可存储典型的整数 4字节 -2147483648 至 +2147483647 bigint 存储整数，大范围。 8字节 -9223372036854775808 至 9223372036854775807 decimal 用户指定的精度，精确 变量 小数点前最多为131072个数字; 小数点后最多为16383个数字。 numeric 用户指定的精度，精确 变量 小数点前最多为131072个数字; 小数点后最多为16383个数字。 real 可变精度，不精确 4字节 6位数字精度 double 可变精度，不精确 8字节 15位数字精度 serial 自动递增整数 4字节 1 至 2147483647 bigserial 大的自动递增整数 8字节 1 至 9223372036854775807 字符串数据类型 数据类型 描述 char(size) 这里size是要存储的字符数。固定长度字符串，右边的空格填充到相等大小的字符。 character(size) 这里size是要存储的字符数。 固定长度字符串。 右边的空格填充到相等大小的字符。 varchar(size) 这里size是要存储的字符数。 可变长度字符串。 character varying(size) 这里size是要存储的字符数。 可变长度字符串。 text 可变长度字符串。 日期/时间数据类型 名称 描述 存储大小 最小值 最大值 解析度 timestamp [ (p) ] [不带时区 ] 日期和时间(无时区) 8字节 4713 bc 294276 ad 1微秒/14位数 timestamp [ (p) ]带时区 包括日期和时间，带时区 8字节 4713 bc 294276 ad date 日期(没有时间) 4字节 4713 bc 5874897 ad 1微秒/14位数 time [ (p) ] [ 不带时区 ] 时间(无日期) 8字节 00:00:00 24:00:00 1微秒/14位数 time [ (p) ] 带时区 仅限时间，带时区 12字节 00:00:00+1459 24:00:00-1459 1微秒/14位数 interval [ fields ] [ (p) ] 时间间隔 12字节 -178000000年 178000000年 1微秒/14位数 PostgreSQL基本使用创建数据库可以使用数据库客户端pgAdmin来创建数据库,下面说的是使用SQL shell查询工具来创建数据库 1create database testdb; 查看数据库1postgres=# \\l 删除数据库123postgres=# drop database testdb;DROP DATABASEpostgres=# 创建表12345678CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); 删除表12postgres=# drop table student2;DROP TABLE PostgreSQL模式模式(也叫架构)是指定的表集合。 它还可以包含视图，索引，序列，数据类型，运算符和函数。 尤为重要 创建模式语法1CREATE SCHEMA schema_name; 创建模式实例1CREATE SCHEMA myschema; 在模式下新建表12345678CREATE TABLE myschema.tb_test( id integer, name character(254))WITH ( OIDS=FALSE); 使用模式的优点 模式有助于多用户使用一个数据库，而不会互相干扰。 它将数据库对象组织成逻辑组，使其更易于管理。 可以将第三方模式放入单独的模式中，以避免与其他对象的名称相冲突。 PostgreSQL查询工具INSERT语句1234567INSERT INTO EMPLOYEES( ID, NAME, AGE, ADDRESS, SALARY) VALUES (1, 'Maxsu', 25, '海口市人民大道2880号', 109990.00 ), (2, 'minsu', 25, '广州中山大道 ', 125000.00 ), (3, '李洋', 21, '北京市朝阳区', 185000.00), (4, 'Manisha', 24, 'Mumbai', 65000.00), (5, 'Larry', 21, 'Paris', 85000.00); SELECT语句1SELECT ID, NAME, AGE, SALARY FROM EMPLOYEES; UPDATE语句123UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; DELETE语句12DELETE FROM table_name WHERE [condition]; 注意：如果不使用“WHERE”条件，整个表中的记录都将被删除 ORDER BY语句ORDER BY子句用于按升序或降序对数据进行排序。数据在一列或多列的基础上进行排序。 1234SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; GROUP BY语句GROUP BY子句用于将具有相同数据的表中的这些行分组在一起。 它与SELECT语句一起使用。GROUP BY子句通过多个记录收集数据，并将结果分组到一个或多个列。 它也用于减少输出中的冗余 12345SELECT column-list FROM table_name WHERE [conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN 实例,按name分组，统计薪水 123SELECT NAME, SUM(SALARY) FROM EMPLOYEES GROUP BY NAME; HAVING IN语句HAVING子句与GROUP BY子句组合使用，用于选择函数结果满足某些条件的特定行。 123456SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 实例，查询表中名字相同数大于2 123SELECT NAME,COUNT (NAME) FROM EMPLOYEES GROUP BY NAME HAVING COUNT (NAME) &gt; 2; PostgreSQL条件查询PostgreSQL条件用于从数据库获取更具体的结果。 通常与WHERE子句一起使用。 具有子句的条件就像双层过滤器。 AND 条件 OR 条件 AND &amp; OR 条件 NOT 条件 LIKE 条件 IN 条件 NOT IN 条件 BETWEEN 条件 AND条件AND条件与WHERE子句一起使用，以从表中的多个列中选择唯一的数据。 1234SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] AND [search_condition]; OR条件OR条件与WHERE子句一起使用，以从表中的一列或多列列中选择唯一数据 1234SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] OR [search_condition]; OR和AND一起使用实例 1234SELECT * FROM EMPLOYEES WHERE (NAME = 'Minsu' AND ADDRESS = 'Delhi') OR (ID&gt;= 8); NOT条件NOT条件与WHERE子句一起使用以否定查询中的条件。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] NOT [condition]; 实例 1234567SELECT * FROM EMPLOYEES WHERE address IS NOT NULL ;--查询年龄不是21和24的所有记录SELECT * FROM EMPLOYEES WHERE age NOT IN(21,24) ; LIKE条件LIKE条件与WHERE子句一起用于从指定条件满足LIKE条件的表中获取数据 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] LIKE [condition]; 实例，查询名字以Ma开头记录 123SELECT * FROM EMPLOYEES WHERE NAME LIKE 'Ma%'; IN条件IN条件与WHERE子句一起使用，从指定条件满足IN条件的表中获取数据。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] IN [condition]; 实例,查询年龄是19,21的记录 123SELECT * FROM EMPLOYEES WHERE AGE IN (19, 21); NOT IN条件NOT IN条件与WHERE子句一起使用，以从指定条件否定IN条件的表中获取数据。 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] NOT IN [condition]; BETWEEN条件BETWEEN条件与WHERE子句一起使用，以从两个指定条件之间的表中获取数据 123SELECT column1, column2, ..... columnN FROM table_name WHERE [search_condition] BETWEEN [condition]; 实例，查询年龄在24到27之间的记录，包括24和27 123SELECT * FROM EMPLOYEES WHERE AGE BETWEEN 24 AND 27; PostgreSQL连接 内连接(INNER JOIN) 左外连接(LEFT OUTER JOIN) 右外连接(RIGHT OUTER JOIN) 全连接(FULL OUTER JOIN) 跨连接(CROSS JOIN) INNER JOIN内连接内部连接也被称为连接或简单连接。 这是最常见的连接类型。 此连接返回满足连接条件的多个表中的所有行。 简单讲，就是返回两张表中共同拥有的部分 1234SELECT table1.columns, table2.columns FROM table1 INNER JOIN table2 ON table1.common_filed = table2.common_field; LEFT JOIN左外连接左外连接返回从“ON”条件中指定的左侧表中的所有行，只返回满足条件的另一个表中的行。 简单讲on条件中左侧表的全部加上两张表共同的部分 1234SELECT table1.columns, table2.columns FROM table1 LEFT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 返回的是table1的全部和table1和table2共同的记录 RIGHT JOIN右外连接右外连接返回从“ON”条件中指定的右侧表中的所有行，只返回满足条件的另一个表中的行。 1234SELECT table1.columns, table2.columns FROM table1 RIGHT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 返回的是table2的全部记录和table1和table2共同的部分 FULL 全外连接FULL外连接从LEFT手表和RIGHT表中返回所有行。 它将NULL置于不满足连接条件的位置。 1234SELECT table1.columns, table2.columns FROM table1 FULL OUTER JOIN table2 ON table1.common_filed = table2.common_field; CROSS跨连接跨连接(CROSS JOIN)将第一个表的每一行与第二个表的每一行相匹配。 它也被称为笛卡儿积分。 如果table1具有“x”列，而table2具有“y”列，则所得到的表将具有(x + y)列。 123SELECT coloums FROM table1 CROSS JOIN table2 PostgreSQL高级部分PostgreSQL视图在PostgreSQL中，视图(VIEW)是一个伪表。 它不是物理表，而是作为普通表选择查询。 视图也可以表示连接的表。 它可以包含表的所有行或来自一个或多个表的所选行。 使用视图的优点 它以自然和直观的方式构建数据，并使其易于查找。 它限制对数据的访问，使得用户只能看到有限的数据而不是完整的数据。 它归总来自各种表中的数据以生成报告。 创建视图可以使用CREATE VIEW语句来在PostgreSQL中创建视图。 您可以从单个表，多个表以及另一个视图创建它。 1234CREATE [TEMP | TEMPORARY] VIEW view_name AS SELECT column1, column2..... FROM table_name WHERE [condition]; 创建视图实例,在Employees表创建一个视图，此视图仅包含Employee表中的几个列 123CREATE VIEW current_employees AS SELECT NAME, ID, SALARY FROM EMPLOYEES; 这个时候，你可以在视图下看到current_employees视图 使用视图 1SELECT * FROM current_employees; 删除视图 1DROP VIEW current_employees; PostgreSQL函数PostgreSQL函数也称为PostgreSQL存储过程。 PostgreSQL函数或存储过程是存储在数据库服务器上并可以使用SQL界面调用的一组SQL和过程语句(声明，分配，循环，控制流程等)。 它有助于您执行通常在数据库中的单个函数中进行多次查询和往返操作的操作。可以在许多语言(如SQL，PL/pgSQL，C，Python等)中创建PostgreSQL函数。 12345678910CREATE [OR REPLACE] FUNCTION function_name (arguments) RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN &lt; function_body &gt; [...] RETURN &#123; variable_name | value &#125; END; LANGUAGE plpgsql; 说明： function_name：指定函数的名称。 [OR REPLACE]：是可选的，它允许您修改/替换现有函数。 RETURN：它指定要从函数返回的数据类型。它可以是基础，复合或域类型，或者也可以引用表列的类型。 function_body：function_body包含可执行部分。 plpgsql：它指定实现该函数的语言的名称。 实例，在Employee表上创建一个total records() 函数 123456789CREATE OR REPLACE FUNCTION totalRecords () RETURNS integer AS $total$ declare total integer; BEGIN SELECT count(*) into total FROM EMPLOYEES; RETURN total; END; $total$ LANGUAGE plpgsql; 调用函数 1select totalRecords(); PostgreSQL触发器PostgreSQL触发器是一组动作或数据库回调函数，它们在指定的表上执行指定的数据库事件(即，INSERT，UPDATE，DELETE或TRUNCATE语句)时自动运行。 触发器用于验证输入数据，执行业务规则，保持审计跟踪等。 说明 PostgreSQL在以下情况下执行/调用触发器：在尝试操作之前(在检查约束并尝试INSERT，UPDATE或DELETE之前)。或者在操作完成后(在检查约束并且INSERT，UPDATE或DELETE完成后)。或者不是操作(在视图中INSERT，UPDATE或DELETE的情况下) 对于操作修改的每一行，都会调用一个标记为FOR EACH ROWS的触发器。 另一方面，标记为FOR EACH STATEMENT的触发器只对任何给定的操作执行一次，而不管它修改多少行。 您可以为同一事件定义同一类型的多个触发器，但条件是按名称按字母顺序触发。 当与它们相关联的表被删除时，触发器被自动删除。 创建触发器12345CREATE TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name ON table_name [ -- Trigger logic goes here.... ]; 在这里，event_name可以是INSERT，UPDATE，DELETE和TRUNCATE数据库操作上提到的表table_name。 您可以选择在表名后指定FOR EACH ROW。下面来看看看如何在INSERT操作中创建触发器的语法。 12345CREATE TRIGGER trigger_name AFTER INSERT ON column_name ON table_name [ -- Trigger logic goes here.... ]; 实例当插入一条数据到审核表COMPANY时，就会在AUDIL表中插入一条记录 先在审核表中创建一个函数auditlogfunc 123456CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$ BEGIN INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp); RETURN NEW; END; $example_table$ LANGUAGE plpgsql; COMPANY表上创建触发器 12CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY FOR EACH ROW EXECUTE PROCEDURE auditlogfunc(); 向审核表中插入数据测试 12INSERT INTO COMPANY VALUES(1, '小米科技', 8, '北京市朝阳区', 9999);INSERT INTO COMPANY VALUES(2, '京东中科', 6, '广州市天河区', 8999); 触发器使用场景 验证输入数据。 执行业务规则。 为不同文件中新插入的行生成唯一值。 写入其他文件以进行审计跟踪。 从其他文件查询交叉引用目的。 访问系统函数。 将数据复制到不同的文件以实现数据一致性。 触发器的优点 它提高了应用程序的开发速度。 因为数据库存储触发器，所以您不必将触发器操作编码到每个数据库应用程序中。 全局执法业务规则。定义触发器一次，然后将其重用于使用数据库的任何应用程序。 更容易维护 如果业务策略发生变化，则只需更改相应的触发程序，而不是每个应用程序。 提高客户/服务器环境的性能。 所有规则在结果返回之前在服务器中运行。 PostgreSQL索引索引是用于加速从数据库检索数据的特殊查找表。数据库索引类似于书的索引(目录)。 索引为出现在索引列中的每个值创建一个条目。 特点 索引使用SELECT查询和WHERE子句加速数据输出，但是会减慢使用INSERT和UPDATE语句输入的数据。 您可以在不影响数据的情况下创建或删除索引。 可以通过使用CREATE INDEX语句创建索引，指定创建索引的索引名称和表或列名称。 还可以创建一个唯一索引，类似于唯一约束，该索引防止列或列的组合上有一个索引重复的项 创建索引1CREATE INDEX index_name ON table_name; 索引类型PostgreSQL中有几种索引类型，如B-tree，Hash，GiST，SP-GiST和GIN等。每种索引类型根据不同的查询使用不同的算法。 默认情况下，CREATE INDEX命令使用B树索引。 单列索引如果仅在一个表列中创建索引，则将其称为单列索引。 12CREATE INDEX index_name ON table_name (column_name); 多列索引如果通过使用表的多个列创建索引，则称为多列索引。 12CREATE INDEX index_name ON table_name (column1_name, column2_name); 唯一索引创建唯一索引以获取数据的完整性并提高性能。它不允许向表中插入重复的值，或者在原来表中有相同记录的列上也不能创建索引。 12CREATE UNIQUE INDEX index_name on table_name (column_name); 删除索引1DROP INDEX index_name; 避免使用索引场景 应该避免在小表上使用索引。 不要为具有频繁，大批量更新或插入操作的表创建索引。 索引不应用于包含大量NULL值的列。 不要在经常操作(修改)的列上创建索引。 PostgreSQL日期函数 函数 描述 AGE() 减去参数 CURRENT DATE/TIME() 它指定当前日期和时间。 DATE_PART() 获取子字段(相当于提取) EXTRACT() 获得子字段 ISFINITE() 测试有限的日期，时间和间隔(非+/-无穷大) JUSTIFY 调整间隔 AGE(timestamp，timestamp)＆AGE(timestamp) 函数 描述 age(timestamp, timestamp) 当使用第二个参数的时间戳形式调用时，age()减去参数，产生使用年数和月份的类型为“interval”的“符号”结果。 age(timestamp) 当仅使用时间戳作为参数调用时，age()从current_date(午夜)减去。 AGE函数实例 1SELECT AGE(timestamp '2017-01-26', timestamp '1951-08-15'); --结果是65 year 5 mons 11 day 当前时间函数 函数 描述 CURRENT_DATE 提供当前日期 CURRENT_TIME 提供带时区的值 CURRENT_TIMESTAMP 提供带时区的值 CURRENT_TIME(precision) 选择使用precision参数，使结果在四分之一秒的范围内四舍五入到数位数。 CURRENT_TIMESTAMP(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 LOCALTIME 提供没有时区的值。 LOCALTIMESTAMP 提供没有时区的值。 LOCALTIME(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 LOCALTIMESTAMP(precision) 选择使用精度参数，这将使结果在四分之一秒的范围内四舍五入到数位数。 实例 12345SELECT CURRENT_TIME; --获取当前时间SELECT CURRENT_DATE; --获取当前日期SELECT CURRENT_TIMESTAMP; --获取当前时间戳SELECT CURRENT_TIMESTAMP(2); --虎丘当前时间戳更精确SELECT LOCALTIMESTAMP; --获取本地时间戳 PostgreSQL UNIONS语句PostgreSQL UNION子句/运算符用于组合两个或多个SELECT语句的结果，而不返回任何重复的行。要使用UNION，每个SELECT必须具有相同的列数，相同数量的列表达式，相同的数据类型，并且具有相同的顺序，但不一定要相同。 语法123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNIONSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] 实例 12345SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID UNION SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; UNION ALL语句UNION ALL运算符用于组合两个SELECT语句(包括重复行)的结果。 适用UNION的相同规则也适用于UNION ALL运算符。 123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNION ALLSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] PostgreSQL NULLPostgreSQL NULL是用于表示缺少值的术语。 表中的NULL值是一个字段中的值，显示为空白。具有NULL值的字段是没有值的字段。要知道一个NULL值与零值或包含空格的字段不同是非常重要的。 IS NOT NULL123SELECT ID, NAME, AGE, ADDRESS, SALARY FROM COMPANY WHERE SALARY IS NOT NULL; IS NULL123SELECT ID, NAME, AGE, ADDRESS, SALARY FROM COMPANY WHERE SALARY IS NULL; PostgreSQL修改表PostgreSQL ALTER TABLE命令用于添加，删除或修改现有表中的列。您还可以使用ALTER TABLE命令在现有表上添加和删除各种约束。 语法使用ALTER TABLE语句在现有表中添加新列的基本语法如下： 1ALTER TABLE table_name ADD column_name datatype; 现有表中ALTER TABLE到DROP COLUMN(删除某个字段)的基本语法如下： 1ALTER TABLE table_name DROP COLUMN column_name; ALTER TABLE更改表中列的DATA TYPE(修改字段类型)的基本语法如下： 1ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype; ALTER TABLE向表中的列添加NOT NULL约束的基本语法如下： 1ALTER TABLE table_name MODIFY column_name datatype NOT NULL; ALTER TABLE添加唯一约束ADD UNIQUE CONSTRAINT到表中的基本语法如下： 12ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...); ALTER TABLE将“检查约束”添加到表中的基本语法如下所示： 12ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION); ALTER TABLE添加主键ADD PRIMARY KEY约束的基本语法如下： 12ALTER TABLE table_nameADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...); 使用ALTER TABLE从表中删除约束(DROP CONSTRAINT)的基本语法如下： 12ALTER TABLE table_nameDROP CONSTRAINT MyUniqueConstraint; 使用ALTER TABLE从表中删除主键约束(DROP PRIMARY KEY)约束的基本语法如下： 12ALTER TABLE table_nameDROP CONSTRAINT MyPrimaryKey; PostgreSQL子查询子查询或内部查询或嵌套查询是一个PostgreSQL查询中的查询，它可以嵌入到WHERE子句中。子查询用于返回将在主查询中使用的数据作为进一步限制要检索的数据的条件。 子查询可以与SELECT，INSERT，UPDATE和DELETE语句以及运算符(如=，&lt;，&gt;，&gt;=，&lt;=，IN等)一起使用。 子查询必须括在括号中。 子查询在SELECT子句中只能有一列，除非主查询中有多个列用于比较其所选列的子查询。 ORDER BY不能用于子查询，主查询可以使用ORDER BY，GROUP BY可用执行与子查询中的ORDER BY相同的功能。 返回多行的子查询只能与多个值运算符一起使用，例如：IN，EXISTS，NOT IN，ANY / SOME，ALL运算符。 BETWEEN运算符不能与子查询一起使用; 但是，BETWEEN可以在子查询中使用。 带SELECT语句的子查询123456SELECT column_name [, column_name ]FROM table1 [, table2 ]WHERE column_name OPERATOR (SELECT column_name [, column_name ] FROM table1 [, table2 ] [WHERE]) 实例 12345SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &gt; 45000) ; 带INSERT语句的子查询子查询也可以用于INSERT语句。INSERT语句使用从子查询返回的数据插入另一个表。 可以使用任何字符，日期或数字函数修改子查询中选定的数据。 1234INSERT INTO table_name [ (column1 [, column2 ]) ] SELECT [ *|column1 [, column2 ] FROM table1 [, table2 ] [ WHERE VALUE OPERATOR ] 1234INSERT INTO COMPANY_BKP SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY) ; 带UPDATE语句的子查询子查询可以与UPDATE语句一起使用。 当使用具有UPDATE语句的子查询时，可以更新表中的单列或多列 123456UPDATE tableSET column_name = new_value[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 实例 假设我们有一个名为COMPANY_BKP表，它是COMPANY表的备份。以下示例将所有客户(其AGE大于或等于27)在COMPANY表中的SALARY更新为0.50倍： 1234UPDATE COMPANY SET SALARY = SALARY * 0.50 WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt;= 27 ); 带有DELETE语句的子查询12345DELETE FROM TABLE_NAME[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 实例 假设我们有一个COMPANY_BKP表，它是COMPANY表的备份。以下示例从COMPANY 表中删除所有客户的记录，其AGE大于或等于27数据记录 123DELETE FROM COMPANY WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt; 27 );","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://caochenhins.github.io/tags/PostgreSQL/"}]},{"title":"JavaEE进阶知识学习-----Mybatis知识总结","slug":"JavaEE进阶知识学习-Mybatis知识总结","date":"2019-03-21T14:36:08.000Z","updated":"2019-03-21T15:16:55.433Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-Mybatis知识总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-Mybatis知识总结/","excerpt":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. Mybatis与其他持久化方式对比 MyBatis是一个半自动化的持久化框架 JDBC是SQL夹在Java代码中，耦合度高导致硬编码，维护不易且实际开发中SQL会经常变化 Hibernate和JPA是内部自动产生的SQL语句，不容易做特殊优化，长而复杂的SQL，hibernate处理也不容易，是基于全映射的全自动化框架，大量子弹的pojo进行部分映射比较困难，导致数据库性能下降 对于开发人员，核心SQL需要自己优化，所以需要SQL和java编码分开，功能界面明显，一个专注业务，一个专注数据 文档资料下载地址：https://github.com/mybatis/mybatis-3 中文文档：http://www.mybatis.org/mybatis-3/zh/index.html","text":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. Mybatis与其他持久化方式对比 MyBatis是一个半自动化的持久化框架 JDBC是SQL夹在Java代码中，耦合度高导致硬编码，维护不易且实际开发中SQL会经常变化 Hibernate和JPA是内部自动产生的SQL语句，不容易做特殊优化，长而复杂的SQL，hibernate处理也不容易，是基于全映射的全自动化框架，大量子弹的pojo进行部分映射比较困难，导致数据库性能下降 对于开发人员，核心SQL需要自己优化，所以需要SQL和java编码分开，功能界面明显，一个专注业务，一个专注数据 文档资料下载地址：https://github.com/mybatis/mybatis-3 中文文档：http://www.mybatis.org/mybatis-3/zh/index.html MyBatis的HelloWord概述随着Maven的流行，现在几乎很少有使用jar的方式来搭建开发环境，这里也就不在单个使用Mybatis去操作数据库，不会的可以自行百度，MyBatis只是一个持久化框架，只有和其他框架整合才能更好的使用，例如SpringMVC，SpringBoot等，与Spring整合后，Mybatis的一些配置文件都会交于Spring管理。 MyBatis的全局配置文件概述MyBatis的全局配置文件可以配置的属性如下 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 properties属性MyBatis使用properties来引入外部properties配置文件的内容，resource：引入类路径下的资源，url引入网络路径或者磁盘路径下的资源。可以用于将数据源连接信息放在properties文件中，与Spring整合后就写在Spring的配置文件中。 引入外部properties文件 1&lt;properties resource=\"org/mybatis/example/config.properties\"&gt;&lt;/properties&gt; 使用引入的properties文件 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; settings运行时设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。 设置参数 描述 有效值 默认值 cacheEnabled 全局开启或关闭配置文件中的所有映射器任何缓存 true \\ false true lazyLoadingEnabled 延迟加载的全局开关 true \\ false false aggressiveLazyLoading 开启，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 true \\ false false multipleResultSetsEnabled 是否允许单一语句返回多结果集 true \\ false true useColumnLabel 使用列标签代替列名。 true \\ false true useGeneratedKeys 允许 JDBC 支持自动生成主键 如果设置为 true 则这个设置强制使用自动生成主键 true \\ false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出提醒 NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 任意正整数 defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 任意正整数 safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。 true \\ false False safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。 true \\ false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true \\ false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION \\ STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始) callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 true \\ false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始） true \\ false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象用到的代理工具。 CGLIB \\ JAVASSIST 常用的Setting设置 设置参数 描述 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名规则映射A_COLUNM到aColumn false defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 Settings设置示例1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases别名类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余,但是往往我们不会使用别名，是为了方便查看代码。 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，给包和子包下的所有类起一个默认的别名（类名小写） 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。 12@Alias(\"author\")public class Author &#123;&#125; typeHandlers 类型处理器无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 类型处理器 Java类型 JDBC类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SHORT INTEGER IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 LONG INTEGER FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）。 InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR or LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE plugins插件MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments环境配置MyBatis可以配置多种环境，default代表指定使用某种环境，这样就可以快速切换环境，尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一 ，所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例 。每个数据库对应一个 SqlSessionFactory 实例 环境配置实例 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 环境配置说明 默认的环境 ID（比如:default=”development”）。 每个 environment 元素定义的环境 ID（比如:id=”development”）。 事务管理器的配置（比如:type=”JDBC”）。 数据源的配置（比如:type=”POOLED”）。 MyBatis映射文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在 。SQL 映射文件有很少的几个顶级元素 ，如下 cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 Select查询查询语句是 MyBatis 中最常用的元素之一 ，简单查询的 select 元素是非常简单的。比如 123&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 该查询接受一个 int（或 Integer）类型的参数，返回一个 HashMap 类型的对象，键是列名，值是结果行中的对应值。 select 元素有很多属性允许你配置，来决定每条语句的作用细节 ，如下 123456789101112&lt;select id=\"selectPerson\" parameterType=\"int\" parameterMap=\"deprecated\" resultType=\"hashmap\" resultMap=\"personResultMap\" flushCache=\"false\" useCache=\"true\" timeout=\"10000\" fetchSize=\"256\" statementType=\"PREPARED\" resultSetType=\"FORWARD_ONLY\"&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 insert update delete数据变更语句 insert，update 和 delete 的实现非常接近 ,如下 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" keyColumn=\"\" useGeneratedKeys=\"\" timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 属性说明 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 示例 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 多行插入 1234567&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username, password, email, bio) values &lt;foreach item=\"item\" collection=\"list\" separator=\",\"&gt; (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;) &lt;/foreach&gt;&lt;/insert&gt; 自动生成主键 12345&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 映射文件小结 Mybatis允许增删改直接定义的返回值：Integer，Long，Boolean,返回的是改变数据库表的记录数和true和false 支持自动生成主键的字段，设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。 数据库还支持多行插入, 你也可以传入一个数组或集合，并返回自动生成的主键 映射文件参数处理 单个参数：MyBatis不会做特殊处理，#{参数名/任意名}：取出参数值 多个参数：MyBatis会做特殊处理，多个参数被封装为一个map,key：param1…param10或者参数的索引 命名参数，多个参数使用#{param1}来取值导致错乱，故使用命名参数，明确指定封装map的key,如下 1public Person getPerson(@Param(\"id\") Integer id,@Param(\"name\") String laseName); 这个时候在xml文件中可以使用#{id}和#{name}来取值 如果传入多个参数正好是POJO：可以使用#{属性名}直接获取。 如果传入多个参数不是POJO,为了方便，我们可以传入map,如下 1public Person getPerson(Map&lt;String,Object&gt; map); 这个时候也就可以在xml文件中使用#{key}直接取出传入map的key对应的值 如果传入多个参数不是POJO,但是查询频率高，使用map不方便，可以编写一个TO(数据传输对象) 如果传入了一个Collection（list，set）类型或者数组，也会特殊处理，也是吧list或者数组封装到map中，传入的类型不一样，对应的key如下：Collection（collection）,List（list），数组（array）,示例如下 1public Person get(List&lt;Integer&gt; ids); 传入的是一个list集合，在xml文件中，我们如果需要取出list中的第一个元素为：#{list[0]} #和$取值区别 取值的方式#{}是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}:取出的值直接拼装在sql语句中；会有安全问题；大多情况下，我们去参数的值都应该去使用#{}； 原生jdbc不支持占位符的地方我们就可以使用${}进行取值比如分表、排序。；按照年份分表拆分 12select * from $&#123;year&#125;_salary where xxx;select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125; select查询返回类型 返回一个集合：resultType写集合中元素的类型 返回一条记录的map，key为列名，value为列对应的值，例如 1public Map&lt;String ,Object&gt; getPersonByMap(Integer id); 123&lt;select id = \"getPersonByMap\" resultType=\"map\"&gt; select * from person where id = #&#123;id&#125;&lt;/select&gt; 返回多条记录封装的一个map，Map&lt;Integer,Person&gt;:key是这条记录的主键，值是记录封装后的pojo,如下 12@MapKey(\"id\")public Map&lt;Integer,Person&gt; getPersonByName(String name); 123&lt;select id = \"getPersonByName\" resultType=\"com.test.Person\"&gt; select * from person where last_name like #&#123;name&#125;&lt;/select&gt; @MapKey(“id”)注解表示使用那个属性作为返回结果map的key。 resultMap自定义结果集示例 1234567&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt;&lt;/restMap&gt;&lt;select id=\"getPerson\" restMap=\"baseMap\"&gt; select * from person&lt;/select&gt; resultMap关联属性_级联属性封装结果集 例如：员工有部门属性，联合查询返回封装结果 123456&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;result column=\"dept_id\" property=\"dept.id\" &gt;&lt;/result&gt; &lt;result column=\"dept_name\" property=\"dept.name\" &gt;&lt;/result&gt;&lt;/restMap&gt; 使用association指定联合的java对象 12345678&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;/association&gt;&lt;/restMap&gt; 使用collection定义关联集合的封装规则 例如，查询部门的时候，查询出当前部门下的所有员工 12345678&lt;restMap id=\"baseMap\" type=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;collection property=\"persons\" javaType=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;/collection&gt;&lt;/restMap&gt; sql标签这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如： 1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如： 1234567&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;, &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; MyBatis的动态SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 如下 if choose (when, otherwise) trim (where, set) foreach if的使用动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如 注意：在xml文件中特殊符号，像&lt;，&gt;要使用转义字符 12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; choose，when，otherwise有时我们不想应用到所有的条件语句，而只想从中择其一项 ，如下 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim, where, set在前面，如果所有的条件都是动态sql,那么可能会出现一下情况的SQL语句 12SELECT * FROM BLOG WHERESELECT * FROM BLOG WHERE AND title like ‘someTitle’ 出现以上错误的sql语句，MyBatis提供了一种解决方式 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除 。注意：WHERE只会去掉开头第一个AND或OR 使用where会出错的情况，And放在后面 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; AND &lt;/if&gt; &lt;if test=\"title != null\"&gt; title like #&#123;title&#125; AND &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 另外一种解决办法就是使用标签，使用where，也可能造成最后一个and，使用trim方法如下 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ... &lt;/trim&gt; prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容（移除前面多余的AND 或者OR），并且插入 prefix 属性中指定的内容。 使用suffixOverrides会移除后面多余的AND或者OR。 set标签与if结合实现动态更新 12345678910&lt;update id=\"updateAuthorIfNecessary\"&gt; update Author &lt;set&gt; &lt;if test=\"username != null\"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=\"password != null\"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"bio != null\"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号,也可以使用trim，注意这里我们删去的是后缀值，同时添加了前缀值。 123&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; ...&lt;/trim&gt; foreach动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： 123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 说明: collection：指定要遍历的集合 item：将当前遍历的每一个元素赋给指定的变量 separator：每一个元素之间的分隔符 open：遍历出所有的结果拼接一个开始的字符 close：遍历出所有的结果拼接一个结束的字符 index：遍历list的就是索引，遍历map的时候就是map的key,item是map的值 Mysql下的批量插入1public void addEmp(@Param(\"emps\") List&lt;Employee&gt; emps); 1234567&lt;insert id=\"addEmp\"&gt; INSERT into employee(name,age)values &lt;foreach item=\"emp\" index=\"index\" collection=\"emps\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;emp.name&#125;, #&#123;emp.age&#125; &lt;/foreach&gt;&lt;/insert&gt; bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如 12345&lt;select id=\"selectBlogsLike\" resultType=\"Blog\"&gt; &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 如果是模糊查询，使用下面的方式是行不通的，如下 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%#&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之一，可以使用$符号(不安全) 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%$&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之二，使用bind标签 1234567&lt;select&gt; &lt;bind name=\"_lastName\" value=\"'%'+lastName+'%'\"&gt;&lt;/bind&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like #&#123;_lastName&#125; &lt;/if&gt;&lt;/select&gt; 1&lt;bind name=\"_lastName\" value=\"'_'+lastName+'%'\"&gt;&lt;/bind&gt;&lt;!--表示以什么开始，后面是参数的模糊查询--&gt; MyBatis的缓存机制概述MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。MyBatis系统中默认定义了两级缓存，一级缓存和二级缓存。 默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存（本地缓存）与数据库同一次会话期间查询的数据会放在本地缓存中，以后如果需要获取相同数据，直接从缓存中拿，不再查询数据库 一级缓存失效的四种情况 一级缓存是sqlSession级别的缓存，也就说一个sqlSession拥有自己的一级缓存，一级缓存是一直开启的，没有使用一级缓存的情况 不同的sqlSession对应不同的一级缓存 同一个sqlSession,但是查询条件不一样 同一个sqlSession两次查询期间执行了任何一次增删改操作 同一个sqlSession两次查询期间手动清空了缓存 二级缓存（全局缓存） 二级缓存基于namespace默认不开启，需要手动配置 MyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口 二级缓存在SqlSession 关闭或提交之后才会生效 工作机制 一个会话，查询一条数据，这个数据就会放在当前会话的一级缓存中 如果会话关闭，一级缓存中的数据就会保存到二级缓存中，新的查询信息，就参照二级缓存 使用步骤 全局配置文件中开启二级缓存 1&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 需要使用二级缓存的映射文件mapper.xml处使用cache配置缓存 1&lt;cach&gt;&lt;/cach&gt; 注意：POJO需要实现Serializable接口 Mybatis提供了整合ehcache缓存，具体整合方法参考官网文档， MyBatis的逆向工程概述MyBatis Generator：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写 官方文档地址：http://www.mybatis.org/generator/ 官方工程地址：https://github.com/mybatis/generator/releases MBG使用步骤 编写MBG的配置文件（重要几处配置） jdbcConnection配置数据库连接信息 javaModelGenerator配置javaBean的生成策略 sqlMapGenerator配置sql映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置要逆向解析的数据表 tableName：表名 domainObjectName：对应的javaBean名 运行代码生成器生成代码 注意： Context标签targetRuntime=“MyBatis3“可以生成带条件的增删改查targetRuntime=“MyBatis3Simple“可以生成基本的增删改查如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。 MBG配置文件12345678910111213141516171819202122232425&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; //数据库连接信息配置 &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/bookstore0629\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; //javaBean的生成策略 &lt;javaModelGenerator targetPackage=\"com.atguigu.bean\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; //映射文件的生成策略 &lt;sqlMapGenerator targetPackage=\"mybatis.mapper\" targetProject=\".\\conf\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; //dao接口java文件的生成策略 &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.atguigu.dao\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; //数据表与javaBean的映射 &lt;table tableName=\"books\" domainObjectName=\"Book\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 生成器代码1234567891011public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new efaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; QBC风格的带条件查询123456789101112131415@Testpublic void test01()&#123; SqlSession openSession = build.openSession(); DeptMapper mapper = openSession.getMapper(DeptMapper.class); DeptExample example = new DeptExample(); //所有的条件都在example中封装 Criteria criteria = example.createCriteria(); //select id, deptName, locAdd from tbl_dept WHERE //( deptName like ? and id &gt; ? ) criteria.andDeptnameLike(\"%部%\"); criteria.andIdGreaterThan(2); List&lt;Dept&gt; list = mapper.selectByExample(example); for(Dept dept : list) &#123; System.out.println(dept);&#125; Mybatis的插件开发PageHelper分页插件项目地址：https://github.com/pagehelper/Mybatis-PageHelper 文档地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md 使用步骤12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 在 MyBatis 配置 xml 中配置拦截器插件 1234567&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=\"param1\" value=\"value1\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 代码中使用方法12345678910111213141516171819202122232425262728293031323334353637//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 常用方法介绍RowBounds方式的调用 1List&lt;Country&gt; list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页 PageHelper.startPage静态方法调用 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 PageInfo用法 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); Mybatis批量保存在MyBatis的全局设置中有设置，defaultExecutorType 配置默认的执行器 SIMPLE 就是普通的执行器； REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新 但是，如果在全局设置中设置批量执行器，那么每一个mapper中的方法都会执行批量操作，所以我们一般都是在与Spring整合后在Application.xml中配置一个可以执行批量操作的sqlSession,如下 123456789101112&lt;!--创建出SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- configLocation指定全局配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!--mapperLocations: 指定mapper文件的位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"executorType\" value=\"BATCH\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 在Service中自动注入SQLSession 123456@Autowiredprivate SqlSession sqlSession;public List&lt;Employee&gt; getEmps()&#123; EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); return mapper.getEmps();&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochenhins.github.io/tags/Mybatis/"}]},{"title":"JavaEE进阶知识学习-----Java8新特性学习总结","slug":"JavaEE进阶知识学习-Java8新特性学习总结","date":"2019-03-21T14:35:29.000Z","updated":"2019-03-21T15:18:04.624Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-Java8新特性学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-Java8新特性学习总结/","excerpt":"lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 语法格式1.无参数，无返回值（）-&gt; System.out.print(“Hello Word”);","text":"lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 语法格式1.无参数，无返回值（）-&gt; System.out.print(“Hello Word”); 12345678910111213@Testpublic void test1()&#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.print(\"Hello Word\"); &#125; &#125;; r.run(); System.out.print(\"===============================\"); Runnable r1 = () -&gt; System.out.print(\"Hello Word\"); r1.run();&#125; 2.一个参数，无返回值（x）-&gt; System.out.print(x);12345@Testpublic void test2()&#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept(\"Hello Word\");&#125; 如果只有一个参数，无返回值可以省略小括号不写。 3.两个参数，有返回值，并且有多条执行语句123456789@Testpublic void test3()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt;&#123; System.out.println(\"函数式接口\"); return Integer.compare(x,y); &#125;; int max = com.compare(4,5); System.out.println(max);&#125; 4.如果只有一条返回语句1234@Testpublic void test4()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);&#125; 注意说明lambda表达式中的参数类型可以省略不写，JVM可以根据上下文推断出类型 Lambda表达式需要函数式接口的支持。 函数式接口接口中只有一个抽象方法的接口，就叫函数式接口。可以使用注解@FunctionalInterface检查是否为函数式接口。 1234@FunctionalInterfacepublic interface MyPredicat &lt;T&gt;&#123; public boolean test(T t);&#125; 函数式接口示例1.定义一个函数式接口1234@FunctionalInterfacepublic interface MyFun &#123; public Integer getValue(Integer num);&#125; 2.定义一个方法，方法的参数为函数式接口123public Integer operation(Integer num,MyFun mf)&#123; return mf.getValue(num); &#125; 3.使用Lambda表达式12345@Testpublic void test5()&#123; Integer num = operation(100,(x)-&gt; x*x); System.out.println(num);&#125; Lambda表达式左侧是函数式接口的参数，右侧是函数式接口的实现。 Lambda练习练习一将集合中的员工排序，按照年龄从小到大排序，如果年龄相同就按照名称排序 123456789101112131415161718192021public class TestLambda &#123; List&lt;Employee&gt; emps = Arrays.asList( new Employee(\"张三\",13,9999.99), new Employee(\"李四\",67,444.44), new Employee(\"王五\",45,55.55), new Employee(\"赵六\",45,6666.66) ); @Test public void test1()&#123; Collections.sort(emps,(e1,e2) -&gt; &#123; if(e1.getAge() == e2.getAge())&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return Integer.compare(e1.getAge(),e2.getAge()); &#125; &#125;); for(Employee emp:emps)&#123; System.out.println(emp); &#125; &#125;&#125; 练习二对字符串进行处理 1.申明一个函数式接口，用于处理字符串1234@FunctionalInterfacepublic interface MyFunction &#123; public String getValue(String str);&#125; 2.申明一个处理字符串的方法，返回处理后的结果123public String strHandle(String str,MyFunction mf)&#123; return mf.getValue(str);&#125; 3.调用处理方法，使用Lambda表达式实现字符串的不同处理123456789101112@Testpublic void test2()&#123; //将传入的字符串做去除空格处理 String trimStr = strHandle(\" \\t\\t\\t\\tHello Word\",(str) -&gt; str.trim()); System.out.println(trimStr); //将传入的字符串做大写转换处理 String uper = strHandle(\"abce\",(str) -&gt; str.toUpperCase()); System.out.println(uper); //将传入的字符串做截取处理 String subStr = strHandle(\"我要好好学习，成为一个大神\",(str) -&gt; str.substring(1,5)); System.out.println(subStr);&#125; 练习三计算两个long型参数做处理 1.声明一个函数式接口1234@FunctionalInterfacepublic interface MyFunction2 &lt;T,R&gt;&#123; public R getValue(T t1,T t2);&#125; 2.定义处理方法123public void operator(Long l1,Long l2,MyFunction2&lt;Long,Long&gt; mf)&#123; System.out.println(mf.getValue(l1,l2));&#125; 3.使用Lambda表达式12345@Testpublic void test4()&#123; operator(100L,200L,(x,y) -&gt; x+y); operator(100L,200L,(x,y) -&gt; x*y);&#125; lambda表达式总结从上述代码中，我们可以看出Lambda表达式的好处，但是我们会发现，每次使用都会新建一个函数式接口，增加了很多麻烦，所以，Java8给我们增加了很多函数式接口， 四大核心函数接口 Consumer消费型接口： 参数类型 T 返回类型 void 对类型T的对象应用操作 Supplier供给型接口： 参数类型 无 返回类型 T 返回类型为T的对象 Function&lt;T,R&gt;函数型接口： 参数类型 T 返回类型 R 对了类型为T的对象应用操作，并返回结果 Predicate断言型接口： 参数类型 T 返回类型 boolean 确定类型为T的对象是否满足某约束，并返回布尔值。 Consumer示例1234567@Testpublic void test1()&#123; happy(10000,(m) -&gt; System.out.println(\"购买笔记本电脑，每次消费\"+m+\"元\"));&#125;public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; Supplier示例123456789101112131415@Testpublic void test2()&#123; List&lt;Integer&gt; list = getNumList(10, () -&gt; (int)(Math.random()*100)); for(Integer num: list)&#123; System.out.println(num); &#125;&#125;public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;num ; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; 上述使用Lambda表达式就是产生10个100以内的随机数。 Function示例12345678@Testpublic void test3()&#123; String upperStr = strHandle(\"abce\",(str) -&gt; str.toUpperCase()); System.out.println(upperStr);&#125;public String strHandle(String str, Function&lt;String,String&gt; fun)&#123; return fun.apply(str);//对str进行处理，具体处理方式调用的时候使用Lambda表达式指定&#125; Predicate示例将满足条件的字符串添加到集合中 123456789101112131415161718@Testpublic void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"Hello\",\"www.baidu.com\",\"zhangsan\",\"lisi\"); List&lt;String&gt; strList = filterStr(list,(s) -&gt; s.length() &gt; 4); for(String str: strList)&#123; System.out.println(str); &#125;&#125;public List&lt;String&gt; filterStr(List&lt;String&gt; list , Predicate&lt;String&gt; per)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str: list) &#123; if(per.test(str))&#123;//对str进行过滤操作，具体操作调用的时候才执行 strList.add(str); &#125; &#125; return strList;&#125; 函数接口总结 Consumer消费型是传入一个参数，进行处理 Supplier供给型是得到一些结果 Function函数型是传入一个参数，处理后返回一个结果 Predicate断言型就是做一些判断操作 有无参数和返回值是指Predicate per等调用的方法需不需要参数和有无返回值，例如：per.test(str)、fun.apply(str)、sup.get()等。 方法引用当要传递给Lambda体的操作，已经有了实现的方法，可以使用方法引用.(实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致)。方法引用：使用操作符“::”将方法名和对象或类的名字分割开，例如： 对象::实例方法 类::静态方法 类::实例方法 对象::实例方法示例1234567@Testpublic void test1()&#123; //注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 Consumer&lt;String&gt; com = (x) -&gt; System.out.println(x); PrintStream ps = System.out; Consumer&lt;String&gt; con = ps::println;&#125; 例如打印一个字符串： 12345@Testpublic void test1()&#123; Consumer&lt;String&gt; con = System.out::println; con.accept(\"Hello Word\");&#125; 注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 类::静态方法方法引用的实质就是使用更简单的方式代替Lambda表达式。下述代码就是类::静态方法的一个实例。 123456@Testpublic void test2()&#123; Comparator&lt;Integer&gt; con = (x,y) -&gt; Integer.compare(x,y); //上述代码中Lambda表达体中的compare方法已经被实现，可以简写为 Comparator&lt;Integer&gt; con1 = Integer::compare;&#125; 类::实例方法如下123456@Testpublic void test3()&#123; BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); //上述代码简写为 BiPredicate&lt;String,String&gt; bp2 = String::equals;&#125; 构造器引用12345678@Testpublic void test4()&#123; Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); //构造器引用 Supplier&lt;Employee&gt; sup2 = Employee::new; Employee employee = sup.get(); System.out.println(employee.getName());&#125; 其中构造器方法调用哪一个构造器取决与接口Supplier中的方法参数，Supplier就是调用的无参构造器，例如Function函数接口就是传入一个参数，并返回一个结果。如下 12345678@Testpublic void test5()&#123; Function&lt;String,Employee&gt; fun = (x) -&gt; new Employee(x); //构造器引用 Function&lt;String,Employee&gt; fun2 = Employee::new; Employee emp = fun2.apply(\"王五\"); System.out.println(emp);&#125; Function&lt;String,Employee&gt;中的String是传入参数类型，Employee是返回结果类型。如果我们想传入两个参数，并返回一个结果，就必须要在Employee中创建两个含两个参数的构造器，如下 123456@Testpublic void test6()&#123; BiFunction&lt;String,Integer,Employee&gt; fun = Employee::new; Employee emp = fun.apply(\"赵六\",123); System.out.println(emp);&#125; 注意：Employee中构造器参数列表和接口中的方法fun.apply(“赵六”,123);参数列表保持一致。 数组引用数组引用格式type[]::new 123456@Testpublic void test7()&#123; Function&lt;Integer,String[]&gt; fun = (x) -&gt; new String[x]; String[] str= fun.apply(10); System.out.println(str.length);&#125; 上述代码就是使用Lambda表达式传入一个数组大小，从而创建一个指定大小和类型的数组。使用数组引用为： 123Function&lt;Integer,String[]&gt; fun2 = String[]::new;String[] str2 = fun2.apply(10);System.out.println(str2.length); StreamAPIStream简介Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行测操作，可以执行非常复杂的查找，过滤和映射数据的操作，使用Stream API对集合数据进行操作就类似于使用SQL执行的数据库查询查询，Stream API提供了一种高效且易于使用的处理数据的方式。流（Stream）是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列，“集合讲的是数据，流讲的是计算”，需要注意的是以下三点 Stream自己不会存储元素 Stream不会改变源对象，相会，他们会返回一个持有结果的新的Stream Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。 Stream使用方法 创建Stream：一个数据源（集合、数组）获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作：一个终止操作，执行中间操作链，并产生结果。 创建Stream的方法 通过Collection系列提供的stream()或parallelStream()，如下： 通过Arrays中的静态方法stream()方法获取流 通过Stream类中的静态方法of() 创建无限流 创建Stream的方法示例12345678910111213141516171819202122232425@Testpublic void test1()&#123; // 1.通过Collection系列提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); // 2.通过Arrays中的静态方法stream()方法获取流 Employee[] emps = new Employee[10]; Stream&lt;Employee&gt; stream1 = Arrays.stream(emps); // 3.通过Stream类中的静态方法of() Stream&lt;String&gt; stream2 = Stream.of(\"AA\",\"BB\",\"CC\"); // 4.创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0,(x) -&gt; x+2); //只要前10个（中间操作） stream3.limit(10).forEach(System.out::println); //打印了所有的中间流操作 //stream3.forEach(System.out::println); //4.2生成 Stream.generate(() -&gt; Math.random()) .limit(10) .forEach(System.out::println);&#125; 中间操作 filter—-接受lambda,从流中排除某一些元素 limit—-截断流，使其元素不超过给定的数量 skip(n)—-跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流 distinct—-筛流，通过流生成元素的hashcode()和equals()去除重复元素 filter示例1234567891011@Testpublic void test1()&#123; //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; &#123; System.out.println(\"中间操作\"); return e.getAge() &gt; 16; &#125;); //终止操作 stream.forEach(System.out::println);&#125; 惰性求值和内部迭代 如果没有终止操作，是不会打印中间操作的，这就是流只有需要结果的时候才会被调用，这就是惰性求值。 上述打印是Stream自己给我们迭代输出的，这个就是内部迭代。 筛选和切片示例如下1234567891011@Testpublic void test1()&#123; //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; e.getAge() &gt; 15) .limit(4) .skip(1) .distinct(); //终止操作 stream.forEach(System.out::println);&#125; 说明：由于distinct是根据hashcode()和equals()去重，所以Employee中要重写equals和hashCode方法。 映射 map(Function f) 接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 map示例1234567891011@Testpublic void test2()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println);System.out.println(\"================\"); employees.stream() .map(Employee::getName) .forEach(System.out::println);&#125; flatMap示例123456789101112131415@Testpublic void test3()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); Stream&lt;Character&gt; sm = list.stream() .flatMap(TestMiddle::filterCharacter); sm.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(Character ch: str.toCharArray())&#123; list.add(ch); &#125; return list.stream();&#125; 排序sorted()-自然排序（comparable）12345678@Test public void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"ccc\",\"aaa\",\"bbb\",\"eee\"); list.stream() .sorted() .forEach(System.out::println); &#125;&#125; sorted(Comparator com)-定制排序（Comparator）1234567891011@Testpublic void test5()&#123; employees.stream() .sorted((e1,e2) -&gt; &#123; if(e1.getAge().equals(e2.getAge()))&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e2.getAge().compareTo(e2.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作终止操作会从流的流水线生成结果，该结果可以是任何不是流的值，例如：List、Integer、void。 查找和匹配 allMatch(Predicate p) 检查是否匹配所有的元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有的元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素个数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestStreamAPI &#123; List&lt;Employee&gt; employees = Arrays.asList( new Employee(\"张三\",16,9999.99, Employee.Status.FREE), new Employee(\"李四\",18,8888.99, Employee.Status.VOCATION), new Employee(\"王五\",20,7777.99, Employee.Status.BUSY), new Employee(\"赵六\",22,6666.99, Employee.Status.FREE), new Employee(\"田七\",24,5555.99, Employee.Status.BUSY), new Employee(\"小八\",26,4444.99, Employee.Status.VOCATION), new Employee(\"陈九\",28,3333.99, Employee.Status.VOCATION), new Employee(\"王五\",32,9999.99, Employee.Status.BUSY), new Employee(\"王五\",34,9999.99, Employee.Status.FREE), new Employee(\"王五\",36,9999.99, Employee.Status.BUSY) ); @Test public void test1()&#123; //检查是否所有的状态为BUSY状态 Boolean b1 = employees.stream() .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否至少匹配一个元素 Boolean b2 = employees.stream() .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否没有匹配元素 Boolean b3 = employees.stream() .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //先按照工资排序，再去除第一个元素放在Option容器中 Optional&lt;Employee&gt; op = employees.stream() .sorted((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())) .findFirst(); System.out.println(op.get()); //findAny返回当前流中的任意元素，先过滤再返回一个， //mployees.stream()实现的是串行流，每次返回的值一定的。 //employees.parallelStream()实现的是并行流 ，返回的就是满足条件的随机结果。 Optional&lt;Employee&gt; op2 = employees.parallelStream() .filter((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)) .findAny(); System.out.println(op2.get()); //返回流中元素个数 Long count = employees.stream() .count(); //返回流中最大值 Optional&lt;Employee&gt; op1 = employees.stream() .max((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())); System.out.println(op1.get()); //返回流中最低工资 Optional&lt;Double&gt; op3 = employees.stream() .map(Employee::getSalay) .min(Double::compare); System.out.println(op3.get()); &#125;&#125; 归约reduce(T iden,BinaryOperator b)可以将流中元素反复结合起来，得到一个值，返回T,示例如下： 123456789101112@Testpublic void test2()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0,(x,y) -&gt; x+y); System.out.println(sum); //计算工资的总和 Optional&lt;Double&gt; op = employees.stream() .map(Employee::getSalay) .reduce(Double::sum); System.out.println(op.get());&#125; 上述代码中使用map得到所有的工资，再有reduce将所有的工资累加，map和reduce配合使用情况比较多。 收集collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。Colletor接口中的方法实现决定了如何对流执行收集操作（如收集到List，Set,Map）,但是Collectors实用类提供了很多静态的方法，可以方便的创建常用收集器实例，具体方法与实例如下： toList 返回List 将流中元素搜集到List toSet 返回Set 将流中元素手机到Set toCollection 返回Collection 把流中元素收集到创建的集合中 counting 返回Long 计算流中元素的个数 summinglnt 返回Integer 对流中元素的整数属性求和 averaginglnt 返回Double 计算流中元素Integer属性的平均值 summarizinglnt 返回IntSummaryStatistics 计算流中Integer属性的统计值，如平均值。 joining 返回String 连接流中每一个字符串 maxBy 返回Optional 根据比较器选择最大值 minBy 返回Optional 根据比较器选择最小值 reducing 归约产生的类型 collectionAndThen 转换函数返回的类型 实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Testpublic void test3()&#123; //将名字添加到list中 List&lt;String&gt; list = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); //将名字添加到Set中 Set&lt;String&gt; set = employees.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); //将名字添加到特定的数据结构中 HashSet&lt;String&gt; hashSet = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); //总数 Long count = employees.stream() .collect(Collectors.counting()); //平均数 Double avg = employees.stream() .collect(Collectors.averagingDouble(Employee::getSalay)); //总和 Double sum = employees.stream() .collect(Collectors.summingDouble(Employee::getSalay)); //最大值，返回工资最大的员工信息 Optional&lt;Employee&gt; max = employees.stream() .collect(Collectors.maxBy((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay()))); //最小值，返回最小工资 Optional&lt;Double&gt; min = employees.stream() .map(Employee::getSalay) .collect(Collectors.minBy(Double::compare)); //按照状态分组 Map&lt;Employee.Status,List&lt;Employee&gt;&gt; map = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus)); map.get(Employee.Status.BUSY); //多级分组 Map&lt;Employee.Status,Map&lt;String,List&lt;Employee&gt;&gt;&gt; map1 = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus,Collectors.groupingBy((e) -&gt;&#123; if(((Employee)e).getAge() &lt;= 18)&#123; return \"少年\"; &#125;else if(((Employee)e).getAge() &lt;= 26)&#123; return \"中年\"; &#125;else&#123; return \"老年\"; &#125; &#125;))); System.out.println(map1); //分区。满足条件一个区，不满足条件的一个区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map2 = employees.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalay() &gt;5000)); System.out.println(map2); //其他的一种获取方式 DoubleSummaryStatistics dss = employees.stream() .collect(Collectors.summarizingDouble(Employee::getSalay)); System.out.println(dss.getSum()); System.out.println(dss.getAverage()); System.out.println(dss.getMax()); //连接字符串 String str = employees.stream() .map(Employee::getName) .collect(Collectors.joining(\",\",\"====\",\"===\"));&#125; StreamAPI练习1.给定一个数字列表，返回一个由每一个数的平方构成的列表。12345678@Testpublic void test()&#123; Integer[] nums = new Integer[]&#123;1,2,3,4,5&#125;; Arrays.stream(nums) .map((x) -&gt; x*x) .forEach(System.out::println);&#125; 2.使用map和reduce方法数一数流中有多少个Employee1234567@Testpublic void test1()&#123; Optional&lt;Integer&gt; count = employees.stream() .map((e) -&gt; 1) .reduce(Integer::sum); System.out.println(count.get());&#125; 交易员类1234567891011121314151617181920212223242526272829303132333435public class Trader &#123; private String name; private String city; public Trader() &#123; &#125; public Trader(String name, String city) &#123; this.name = name; this.city = city; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; @Override public String toString() &#123; return \"Trader [name=\" + name + \", city=\" + city + \"]\"; &#125;&#125; 交易类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Transaction &#123; private Trader trader; private int year; private int value; public Transaction() &#123; &#125; public Transaction(Trader trader, int year, int value) &#123; this.trader = trader; this.year = year; this.value = value; &#125; public Trader getTrader() &#123; return trader; &#125; public void setTrader(Trader trader) &#123; this.trader = trader; &#125; public int getYear() &#123; return year; &#125; public void setYear(int year) &#123; this.year = year; &#125; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Transaction [trader=\" + trader + \", year=\" + year + \", value=\" + value + \"]\"; &#125;&#125; 练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class TestTransaction &#123; List&lt;Transaction&gt; transactions = null; @Before public void before()&#123; Trader raoul = new Trader(\"Raoul\", \"Cambridge\"); Trader mario = new Trader(\"Mario\", \"Milan\"); Trader alan = new Trader(\"Alan\", \"Cambridge\"); Trader brian = new Trader(\"Brian\", \"Cambridge\"); transactions = Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); &#125; //1. 找出2011年发生的所有交易， 并按交易额排序（从低到高） @Test public void test1()&#123; transactions.stream() .filter((t) -&gt; t.getYear() == 2011)//过滤2011年的交易 .sorted((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())) .forEach(System.out::println); &#125; //2. 交易员都在哪些不同的城市工作过？ @Test public void test2()&#123; transactions.stream() .map((t) -&gt; t.getTrader().getCity()) .distinct() .forEach(System.out::println); &#125; //3. 查找所有来自剑桥的交易员，并按姓名排序 @Test public void test3()&#123; new ArrayList&lt;Integer&gt;(); transactions.stream() .filter((t) -&gt; t.getTrader().getCity().equals(\"Cambridge\")) .map(Transaction::getTrader) .sorted((t1,t2) -&gt; t1.getName().compareTo(t2.getName())) .distinct() .forEach(System.out::println); &#125; //4. 返回所有交易员的姓名字符串，按字母顺序排序 @Test public void test4()&#123; transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .forEach(System.out::println); System.out.println(\"====================================\"); String str = transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .reduce(\"\",String::concat); System.out.println(str); &#125; //5. 有没有交易员是在米兰工作的？ @Test public void test5()&#123; Boolean b1 = transactions.stream() .anyMatch((t) -&gt; t.getTrader().getCity().equals(\"Milan\")); System.out.println(b1); &#125; //6. 打印生活在剑桥的交易员的所有交易额 @Test public void test6()&#123; Optional&lt;Integer&gt; sum = transactions.stream() .filter((e) -&gt; e.getTrader().getCity().equals(\"Cambridge\")) .map(Transaction::getValue) .reduce(Integer::sum); System.out.println(sum.get()); &#125; //7. 所有交易中，最高的交易额是多少 @Test public void test7()&#123; Optional&lt;Integer&gt; max = transactions.stream() .map((t) -&gt; t.getValue()) .max(Integer::compare); System.out.println(max); &#125; //8. 找到交易额最小的交易 @Test public void test8()&#123; Optional&lt;Transaction&gt; op = transactions.stream() .min((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())); System.out.println(op.get()); &#125;&#125; LocalDateTimeLocalDateTime是一个不可变的日期时间对象，代表日期时间，通常被视为年 - 月 - 日 - 时 - 分 - 秒。 方法摘要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687Temporal adjustInto(Temporal temporal) 调整指定的时间对象与此对象具有相同的日期和时间。 OffsetDateTime atOffset(ZoneOffset offset) 将此日期时间与偏移量相结合以创建 OffsetDateTime 。 ZonedDateTime atZone(ZoneId zone) 将此日期时间与时区相结合以创建 ZonedDateTime 。 int compareTo(ChronoLocalDateTime&lt;?&gt; other) 将此日期时间与其他日期时间进行比较。 boolean equals(Object obj) 检查这个日期时间是否等于另一个日期时间。 String format(DateTimeFormatter formatter) 使用指定的格式化程序格式化此日期时间。 static LocalDateTime from(TemporalAccessor temporal) 从时间对象获取一个 LocalDateTime的实例。 int get(TemporalField field) 从此日期时间获取指定字段的值为 int 。 int getDayOfMonth() 获取月份字段。 DayOfWeek getDayOfWeek() 获取星期几字段，这是一个枚举 DayOfWeek 。 int getDayOfYear() 获得日期字段。 int getHour() 获取时间字段。 long getLong(TemporalField field) 从此日期时间获取指定字段的值为 long 。 int getMinute() 获取小时字段。 Month getMonth() 使用 Month枚举获取月份字段。 int getMonthValue() 将月份字段从1到12。 int getNano() 获得纳秒第二场。 int getSecond() 获得第二分钟的字段。 int getYear() 获取年份字段。 int hashCode() 这个日期时间的哈希码。 boolean isAfter(ChronoLocalDateTime&lt;?&gt; other) 检查这个日期时间是否在指定的日期之后。 boolean isBefore(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否在指定的日期时间之前。 boolean isEqual(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否等于指定的日期时间。 boolean isSupported(TemporalField field) 检查指定的字段是否受支持。 boolean isSupported(TemporalUnit unit) 检查指定的单位是否受支持。 LocalDateTime minus(long amountToSubtract, TemporalUnit unit) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minus(TemporalAmount amountToSubtract) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minusDays(long days) 返回此 LocalDateTime的副本，其中指定的时间间隔以天为单位。 LocalDateTime minusHours(long hours) 以指定的时间段返回此 LocalDateTime的副本，以减少的小时数。 LocalDateTime minusMinutes(long minutes) 返回此 LocalDateTime的副本，以指定的时间间隔减去。 LocalDateTime minusMonths(long months) 返回此 LocalDateTime的副本，指定的时间以月为单位减去。 LocalDateTime minusNanos(long nanos) 返回这个 LocalDateTime的副本，以指定的时间减去纳秒。 LocalDateTime minusSeconds(long seconds) 返回此 LocalDateTime的副本，其中指定的时间间隔以秒为单位。 LocalDateTime minusWeeks(long weeks) 返回此 LocalDateTime的副本，其中指定的周期以周为单位减去。 LocalDateTime minusYears(long years) 返回此 LocalDateTime的副本，并以减去的年份为单位。 static LocalDateTime now() 从默认时区的系统时钟获取当前的日期时间。 static LocalDateTime now(Clock clock) 从指定的时钟获取当前的日期时间。 static LocalDateTime now(ZoneId zone) 从指定时区的系统时钟获取当前的日期时间。static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得LocalDateTime的实例，将第二和纳秒设置为零。static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) 获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得 LocalDateTime的实例，将第二和纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(LocalDate date, LocalTime time) 从日期和时间获取 LocalDateTime一个实例。 static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) 使用从1970-01-01T00：00：00Z的时代开始的秒数获得一个 LocalDateTime的实例。 static LocalDateTime ofInstant(Instant instant, ZoneId zone) 从 Instant和区域ID获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text) 从一个文本字符串（如 2007-12-03T10:15:30获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) 使用特定的格式化 LocalDateTime从文本字符串获取 LocalDateTime的实例。 LocalDateTime plus(long amountToAdd, TemporalUnit unit) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plus(TemporalAmount amountToAdd) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plusDays(long days) 返回此 LocalDateTime的副本，并以指定的时间段添加天数。 LocalDateTime plusHours(long hours) 以指定的时间（以小时为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMinutes(long minutes) 以指定的时间（以分钟为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMonths(long months) 返回这个 LocalDateTime的副本，其中指定的时间段以月为单位。 LocalDateTime plusNanos(long nanos) 返回这个 LocalDateTime的副本，其指定时间以纳秒为单位。 LocalDateTime plusSeconds(long seconds) 以指定的时间段返回此 LocalDateTime的副本，以秒为单位。 LocalDateTime plusWeeks(long weeks) 返回这个 LocalDateTime的副本，并以指定的周期添加周数。 LocalDateTime plusYears(long years) 返回这个 LocalDateTime的副本，其中指定的时间段以添加的年数表示。 &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) 使用指定的查询查询此日期时间。 ValueRange range(TemporalField field) 获取指定字段的有效值的范围。 LocalDate toLocalDate() 获得这个日期时间的 LocalDate一部分。 LocalTime toLocalTime() 获得这个日期时间的 LocalTime一部分。 String toString() 将此日期时间输出为 String ，例如 2007-12-03T10:15:30 。 LocalDateTime truncatedTo(TemporalUnit unit) 返回此 LocalDateTime的副本， LocalDateTime时间。 long until(Temporal endExclusive, TemporalUnit unit) 根据指定的单位计算到另一个日期时间的时间量。 LocalDateTime with(TemporalAdjuster adjuster) 返回此日期时间的调整副本。 LocalDateTime with(TemporalField field, long newValue) 返回此日期时间的副本，并将指定的字段设置为新值。 LocalDateTime withDayOfMonth(int dayOfMonth) 返回此 LocalDateTime的副本。 LocalDateTime withDayOfYear(int dayOfYear) 返回这个 LocalDateTime的副本，并更改日期。 LocalDateTime withHour(int hour) 返回此日期值更改的 LocalDateTime的副本。 LocalDateTime withMinute(int minute) 返回这个 LocalDateTime的副本，小时值更改。 LocalDateTime withMonth(int month) 返回此年份更改的 LocalDateTime的副本。 LocalDateTime withNano(int nanoOfSecond) 返回这个 LocalDateTime的副本，纳秒变化值。 LocalDateTime withSecond(int second) 返回这个 LocalDateTime的副本，其中 LocalDateTime了第二分钟的值。 LocalDateTime withYear(int year) 返回这个 LocalDateTime的副本，年份被更改。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习-----Java8时间API知识总结","slug":"JavaEE进阶知识学习-Java8时间API知识总结","date":"2019-03-21T14:35:13.000Z","updated":"2019-03-21T15:20:16.767Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-Java8时间API知识总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-Java8时间API知识总结/","excerpt":"一、Java8时间常用操作 前言：时间操作在开发中经常被使用到，最近项目是用Java8开发，因此总结一下时间操作常用方法。 1.常用方法总结1.1.获取当前时间123456// 当前日期：2019-03-16LocalDate date = LocalDate.now();// 当前时间：22:13:03.450LocalTime time = LocalTime.now();// 当前日期和时间：2019-03-16T22:13:03.450LocalDateTime dateTime = LocalDateTime.now();","text":"一、Java8时间常用操作 前言：时间操作在开发中经常被使用到，最近项目是用Java8开发，因此总结一下时间操作常用方法。 1.常用方法总结1.1.获取当前时间123456// 当前日期：2019-03-16LocalDate date = LocalDate.now();// 当前时间：22:13:03.450LocalTime time = LocalTime.now();// 当前日期和时间：2019-03-16T22:13:03.450LocalDateTime dateTime = LocalDateTime.now(); 1.2.月份的第一天和最后一天12345 LocalDate now = LocalDate.now();// 本月第一天： 2019-03-01LocalDate with = now.with(TemporalAdjusters.firstDayOfMonth());// 本月最后一天：2019-03-31LocalDate with1 = now.with(TemporalAdjusters.lastDayOfMonth()); 1.3.下一月的第一天和下一年的第一天12345LocalDate now = LocalDate.now();// 下一个月的第一天：2019-04-01LocalDate with2 = now.with(TemporalAdjusters.firstDayOfNextMonth());// 下一年的第一天：2020-01-01LocalDate with3 = now.with(TemporalAdjusters.firstDayOfNextYear()); 1.4.获取当前年第一个周一的日期12345LocalDate now = LocalDate.now();// 获取当前年的第一天LocalDate with4 = now.with(TemporalAdjusters.firstDayOfYear());// 获取当前年的第一个周一所在的日期：2019-01-07LocalDate.parse(with4.toString()).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); 1.5.指定时间的后几天日期12345LocalDate now = LocalDate.now();// 当前时间的后两天： 2019-03-18LocalDate date1 = now.plusDays(2);// 当前时间的后两月：2019-05-16LocalDate date2 = now.plusMonths(2); 1.6.计算两个日期相距12345678// 实例化一个时间LocalDate of = LocalDate.of(2014, 11, 07);// 相距多少年long until = now.until(of, ChronoUnit.YEARS);// 相距多少月long until2 = now.until(of, ChronoUnit.MONTHS);// 相距多少天long until3 = now.until(of, ChronoUnit.DAYS); 1.7.判断年月的周期性123456789LocalDate nowDate = LocalDate.of(2019, 03, 17);LocalDate birthDayTime = LocalDate.of(1995, 03, 16);MonthDay birthday = MonthDay.of(birthDayTime.getMonth(), birthDayTime.getDayOfMonth());MonthDay today = MonthDay.from(nowDate);if(birthday.equals(today))&#123; System.out.println(\"今天是我的生日\");&#125;else&#123; System.out.println(\"今天不是我的生日\");&#125; 1.8.一周后的日期12LocalDate today = LocalDate.now(); LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS); 1.9.一年前或一年后的日期123LocalDate today = LocalDate.now(); LocalDate preYear = today.minus(1, ChronoUnit.YEARS); LocalDate nextYear = today.plus(1, ChronoUnit.YEARS); 1.10.检查闰年123456LocalDate today = LocalDate.now(); if (today.isLeapYear()) &#123; System.out.println(\"今年是闰年！\");&#125; else &#123; System.out.println(\"今年不是闰年！\");&#125; 1.11.信用卡到期12345YearMonth currentYearMonth = YearMonth.now();// 月份有多少天currentYearMonth.lengthOfMonth();// 信用卡到期日期YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY); 2.附录2.1.date转为LocalTime1234// date转为LocalTimeDate from = Date.from(instant);Instant instant2 = from.toInstant();instant2.atZone(zone).toLocalTime(); 2.2.将LocalDateTime转为date1234// 将LocalDateTime转为dateZoneId zone = ZoneId.systemDefault();Instant instant = now.atZone(zone).toInstant();Date from = Date.from(instant); 说明：目前项目中就使用了这些，如果你有其他常用的操作，请留言，持续更新","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE进阶知识学习-----ElasticSearch学习总结","slug":"JavaEE进阶知识学习-ElasticSearch学习总结","date":"2019-03-21T14:34:56.000Z","updated":"2019-03-21T15:18:57.419Z","comments":true,"path":"2019/03/21/JavaEE进阶知识学习-ElasticSearch学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE进阶知识学习-ElasticSearch学习总结/","excerpt":"一、ElasticSearch学习笔记 撸一门技术，必先登其官网，扒其皮，喝其血 官网地址：https://www.elastic.co/products/elasticsearch 官方中文文档地址：https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html 1.1.ElasticSearch简介ElasticSearch是一个分布式搜索服务，提供的是一组Restful API，底层基于Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能。是目前全文搜索引擎的首选，可以快速的存储、搜索和分析海量数据，Springboot通过整合Spring Data ElasticSearch为我们提供了非常方便的检索功能支持。","text":"一、ElasticSearch学习笔记 撸一门技术，必先登其官网，扒其皮，喝其血 官网地址：https://www.elastic.co/products/elasticsearch 官方中文文档地址：https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html 1.1.ElasticSearch简介ElasticSearch是一个分布式搜索服务，提供的是一组Restful API，底层基于Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能。是目前全文搜索引擎的首选，可以快速的存储、搜索和分析海量数据，Springboot通过整合Spring Data ElasticSearch为我们提供了非常方便的检索功能支持。 1.2.ElasticSearch原始安装系统环境 CentOS 7.6.1810 jdk 1.8.0_201 所需安装文件 elasticsearch-6.6.0.tar.gz jdk-8u201-linux-x64.tar.gz elasticsearch-head-master.zip node-v10.15.1-linux-x64.tar.gz elasticsearch安装方法1tar -zxvf elasticsearch-6.6.0.tar.gz -C /opt/module/ # 解压安装包 1[root@localhost elasticsearch-6.6.0]# mkdir data # 创建数据文件夹（6.0自带logs文件夹） 1vi elasticsearch.yml # 修改配置文件 123456789cluster.name: my-application # 集群名称（多集群时候只需节点名称一直即可）node.name: node-102 # 节点名称path.data: /opt/module/elasticsearch-6.6.0/data # 数据路径path.logs: /opt/module/elasticsearch-6.6.0/logs # 日志路径bootstrap.memory_lock: falsebootstrap.system_call_filter: falsenetwork.host: 192.168.1.8 # 网络地址http.port: 9200 # 端口discovery.zen.ping.unicast.hosts: [\"hadoop102\"] # 主机名 注意：node.name可以随便取，但是一个集群中不能重复，注意path.data前不能有空格，冒号后必须有一个空格 elasticsearch常见问题解决问题一：ERROR: bootstrap checks failed 12su rootvi /etc/security/limits.conf 1234* soft nofile 65536* hard nofile 131072* soft nproc 2048* hard nproc 4096 问题二：max number of threads [1024] for user [lish] likely too low, increase to at least [2048] 12vi /etc/security/limits.d/90-nproc.conf* soft nproc 2048 问题三：max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] 123vi /etc/sysctl.confvm.max_map_count=655360sysctl -p elasticsearch启动 elasticsearch禁止使用root用户启动，需要新建一个testuser用户 1[testuser@hadoop102 elasticsearch-6.6.0]$ ./bin/elasticsearch 访问地址：http://192.168.1.8:9200/ ElasticSearch插件安装插件地址：https://github.com/zt1115798334/elasticsearch-head-master Nodejs安装1tar -zxvf node-v10.15.1-linux-x64.tar.gz -C /opt/module/ 1234vi /etc/profileexport NODE_HOME=/opt/module/node-v10.15.1-linux-x64export PATH=$PATH:$NODE_HOME/binsource /etc/profile elasticsearch-head-master安装1[root@hadoop102 sortware]# unzip elasticsearch-head-master.zip -d /opt/module/ 1[root@hadoop102 elasticsearch-head-master]# npm install grunt --save 1npm install -g cnpm --registry=https://registry.npm.taobao.org 1npm install -g grunt-cli 1vim Gruntfile.js 123456options: &#123; hostname:'0.0.0.0', port: 9100, base: '.', keepalive: true&#125; 123# 检查head根目录下是否存在base文件夹 没有：将 _site下的base文件夹及其内容复制到head根目录下mkdir basecp base/* ../base/ 1[root@hadoop102 module]# chown -R luokangyuan:luokangyuan elasticsearch-head-master/ 1[luokangyuan@hadoop102 elasticsearch-head-master]$ grunt server -d 123456npm install grunt-contrib-clean -registry=https://registry.npm.taobao.orgnpm install grunt-contrib-concat -registry=https://registry.npm.taobao.orgnpm install grunt-contrib-watch -registry=https://registry.npm.taobao.org npm install grunt-contrib-connect -registry=https://registry.npm.taobao.orgnpm install grunt-contrib-copy -registry=https://registry.npm.taobao.org npm install grunt-contrib-jasmine -registry=https://registry.npm.taobao.org 1http://192.168.1.8:9100/ 123vi elasticsearch.ymlhttp.cors.enabled: truehttp.cors.allow-origin: \"*\" 1.3.ElasticSearch的docker安装启动Docker1[root@localhost /]# systemctl start docker 搜索镜像1[root@localhost /]# docker search elasticsearch 使用镜像加速器下载1[root@localhost /]# docker pull registry.docker-cn.com/library/elasticsearch 检查是否安装成功1[root@localhost /]# docker images 启动ElasticSearch1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -p 9200:9200 -p 9300:9300 --name ES01 5acf0e8da90b 检查是否启动1[root@localhost /]# docker ps 访问测试1http://192.168.1.14:9200/ 1.4.ElasticSearch核心概念Cluster集群集群就是包含了多个节点，每一个节点属于哪一个集群是通过一个集群名称配置。 Node节点集群中的一个节点，节点也存在名称，默认是随机分配一个名称，默认节点会加入到一个elasticsearch集群中。 Index索引索引包含的是一大推相似结构的文档数据，例如我们的商品索引，订单索引等，类比于我们的数据库。 Type类型每一个索引里面可以有一个或者多个type，type是index中的一个逻辑数据分类，比如我的博客系统，一个索引，可以定义用户数据type，可以定义文章数据type，也可以定义评论数据type，类比数据库的表。 Document文档文档是ElasticSearch中最小的数据单元，一条Document可以是一条文章数据，一条用户数据，一条评论数据，通常使用JSON数据结构来表示，每个index下的type中，存储多个document，类别数据库中的行。 Field字段Field是ElasticSearch中的最小单位，一个document里面粗在多个Field字段，每个Field就是一个数据字段，类比数据库中的列。 mapping映射数据如何存储在索引上，需要一个约束配置，例如数据类型，是否存储，查询的时候是否分词等等，类比数据库汇总的约束。 ElasticSearch和数据库对别 关系型数据库Mysql 非关系型数据库ElasticSearch 数据库Database 索引Index 表Table 类型Type 数据行Row 文档Document 数据列Column 字段Field 约束Schema 映射Mapping ElasticSearch核心概念图解 1.5.Springboot集成ElasticSearch Springboot默认使用Spring Data Elasticsearch模块进行操作，同时也存在另外一个操作ElasticSearch的模块，那就是jest。 使用Jest与ElasticSearch进行交互Jest的GitHub地址：https://github.com/searchbox-io/Jest Jest文档地址：https://github.com/searchbox-io/Jest/tree/master/jest 第一步：增加POM 文件 12345&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;5.3.4&lt;/version&gt;&lt;/dependency&gt; 第二步：增加ElasticSearch配置项 1234spring: elasticsearch: jest: uris: http://192.168.1.9:9200/ 第三步：使用JestClient进行交互 12345678910public class Users &#123; // 标示主键字段 @JestId private Integer id; private Integer code; private String name; private String sex; private String age; private String notes;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142@AutowiredJestClient jestClient;@Testpublic void contextLoads() &#123; // 给es中保存一份文档 Users users = new Users(); users.setId(2); users.setCode(123456); users.setAge(\"87\"); users.setName(\"鲁班七号\"); users.setSex(\"男\"); users.setNotes(\"王者峡谷人见人想揍的小鲁班\"); // 构建一个王者荣耀的索引和英雄角色类型 Index build = new Index.Builder(users).index(\"wzry\").type(\"yxjs\").build(); try &#123; jestClient.execute(build); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;@Testpublic void testSeach()&#123; // 测试搜索es中满足条件的数据 String json = \"&#123;\\n\" + \" \\\"query\\\" : &#123;\\n\" + \" \\\"match\\\" : &#123;\\n\" + \" \\\"notes\\\" : \\\"峡谷小人\\\"\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \"&#125;\"; Search build = new Search.Builder(json).addIndex(\"wzry\").addType(\"yxjs\").build(); try &#123; SearchResult execute = jestClient.execute(build); System.out.println(execute.getJsonString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 最后测试 1http://192.168.1.9:9200/wzry/yxjs/2 使用Spring Data Elasticsearch官方文档地址：https://docs.spring.io/spring-data/elasticsearch/docs/3.1.5.RELEASE/reference/html/ 第一步：增加POM文件 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：增加配置项 1234567spring: data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.1.9:9300 repositories: enabled: true 第三步：进行数据交互 123456@Document(indexName = \"study\", type = \"book\")public class Book &#123; private Integer id; private String name; private String notes;&#125; 12public interface BookRepository extends ElasticsearchRepository&lt;Book, Integer&gt; &#123;&#125; 1234567891011@AutowiredBookRepository bookRepository;@Testpublic void testSpringDataEs()&#123; Book book = new Book(); book.setId(11); book.setName(\"一个陌生女人的来信\"); book.setNotes(\"还不错\"); bookRepository.index(book);&#125; 注意：如果启动报错，可能是spring data elasticsearch和elasticsearch存在版本对应关系 版本对应参考官方文档：https://github.com/spring-projects/spring-data-elasticsearch/blob/master/README.md spring data elasticsearch elasticsearch 3.2.x 6.5.0 3.1.x 6.2.2 3.0.x 5.5.0 2.1.x 2.4.0 2.0.x 2.2.0 1.3.x 1.5.2 版本不适配解决方法 查看spring data elasticsearch的版本号 安装对应版本的elasticsearch即可 当然也可以根据安装的elasticsearch版本改变Springboot版本 解决办法示例： 12# 安装对应版本的elasticsearch[root@localhost /]# docker pull registry.docker-cn.com/library/elasticsearch:2.4 12# 启动对应版本的elasticsearch[root@localhost /]# docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -p 9201:9200 -p 9301:9300 --name ES14 01e5bee1e059 我个人本次测试环境： Springboot：1.5.19 elasticsearch：2.4 附录一：使用的Linux命令 mkdir 创建文件夹 pwd 查看当前所在路径 scp -r CentOS-7-x86_64-Minimal-1810.iso root@192.168.1.8:/opt/sortware 在当前文件上传文件到指定服务器文件夹 cat /etc/centos-release 查看系统版本 rm -rf jdk-8u201-linux-i586.tar.gz 不提示的递归删除文件或者文件夹 tar -zxvf jdk-8u201-linux-x64.tar.gz 解压 hostnamectl查看主机名 whereis sudoers 查找文件位置 ls -l /etc/sudoers 查看文件权限 chmod -v u+w /etc/sudoers 加入可写权限 firewall-cmd --state 查看防火墙状态 systemctl stop firewalld.service 关闭防火墙 附录二：CentOs7安装jdk1.81.上传安装文件 1/opt/sortware/jdk-8u201-linux-x64.tar.gz 2.解压 1tar -zxvf jdk-8u201-linux-x64.tar.gz 3.重命名 1mv jdk1.8.0_201 jdk1.8 4.打开系统配置文件 1vi /etc/profile 5.添加环境变量 1234## Javaexport JAVA_HOME=/opt/sortware/jdk1.8export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 6.重启配置文件 1source /etc/profile 7.查看版本 1java -version 附录三：CentOs7安装docker 附录四：常用docker命令删除所有容器 1docker rm `docker ps -a -q` 查看存在的镜像 1docker images 查看所有启动的容器 1docker ps -a 停止容器 1docker stop 搜索仓库 1docker search elasticsearch 拉取仓库 1docker pull registry.docker-cn.com/library/elasticsearch 附录四：docker安装kibana下载kibana镜像1docker pull kibana:latest 启动kibana1docker run --name kibana --link ES14:elasticsearch -p 5601:5601 -d kibana","categories":[{"name":"分布式搜索服务","slug":"分布式搜索服务","permalink":"https://caochenhins.github.io/categories/分布式搜索服务/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://caochenhins.github.io/tags/ElasticSearch/"},{"name":"分布式搜索服务","slug":"分布式搜索服务","permalink":"https://caochenhins.github.io/tags/分布式搜索服务/"}]},{"title":"JavaEE基础知识学习-----代码整洁之道学习笔记","slug":"JavaEE基础知识学习-代码整洁之道学习笔记","date":"2019-03-21T14:34:07.000Z","updated":"2019-03-21T15:19:45.752Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-代码整洁之道学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-代码整洁之道学习笔记/","excerpt":"一、代码整洁之道学习笔记大约在1951年的日本出现了一种5s原则体系，5s的精髓就是精益。 整理；搞清事物的所在，通过准确恰当的命名十分重要。 整顿；A place for everything and everything in its plase（物皆有其位，而后物尽归其位）。 清除；清理工作地的拉线，对于那种四处遗弃的带注释的打代码，应该除之而后快。 清洁；及标准化，在开发代码中使用一贯的代码风格和实践手段。 身美；或称纪律，在实践中贯彻规程，并时时体现在个人的工作中，并要乐于改进。 1.1.什么是整洁代码 我喜欢优雅和高效的代码，代码逻辑应当直截了当，叫缺陷难以隐藏，尽量减少依赖关系，使之便于维护，依据某种分层战略完善错误处理代码，性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来，整洁代码之做好了一件事。–Bjarne Stroustrup 1.能通过所有的测试；2.没有重复代码；3.体现系统中的全部设计理念；4.包括尽量少的实体，比如类、方法、函数等，–Michael 我的理解：在Java开发中应该坚持单一简单的原则，一个类，一个方法都应该只做一件事，如果，一个方法还能在提取出另外一个方法，就说明违反了单一职责，优雅的代码就是不仅自己看着舒服，也能让别人看着舒服，能很轻松的看懂代码的业务逻辑，这里涉及到有意义的命名，下面也会总结到。","text":"一、代码整洁之道学习笔记大约在1951年的日本出现了一种5s原则体系，5s的精髓就是精益。 整理；搞清事物的所在，通过准确恰当的命名十分重要。 整顿；A place for everything and everything in its plase（物皆有其位，而后物尽归其位）。 清除；清理工作地的拉线，对于那种四处遗弃的带注释的打代码，应该除之而后快。 清洁；及标准化，在开发代码中使用一贯的代码风格和实践手段。 身美；或称纪律，在实践中贯彻规程，并时时体现在个人的工作中，并要乐于改进。 1.1.什么是整洁代码 我喜欢优雅和高效的代码，代码逻辑应当直截了当，叫缺陷难以隐藏，尽量减少依赖关系，使之便于维护，依据某种分层战略完善错误处理代码，性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来，整洁代码之做好了一件事。–Bjarne Stroustrup 1.能通过所有的测试；2.没有重复代码；3.体现系统中的全部设计理念；4.包括尽量少的实体，比如类、方法、函数等，–Michael 我的理解：在Java开发中应该坚持单一简单的原则，一个类，一个方法都应该只做一件事，如果，一个方法还能在提取出另外一个方法，就说明违反了单一职责，优雅的代码就是不仅自己看着舒服，也能让别人看着舒服，能很轻松的看懂代码的业务逻辑，这里涉及到有意义的命名，下面也会总结到。 1.2.有意义的命名在开发中，我们随处可见的都是名字，我们也时时给变量、函数、方法、参数、类、包等命名，整洁代码的第一点就是要有意义的命名。 名副其实名副其实就是说你个方法是做什么的，参数是什么，就应该名副其实的命名，如果你的方法是删除一条记录，你就不能用get作为方法的开始，参数名、方法名应该是能够告诉阅读者，它为什么存在，它做了什么事，应该怎么用。 1int d; // 消逝的时间，以日计 1int elapsedTimeInDays; 上述代码中，这个d并不能代表消逝的时间，以日计这个注释所代表的含义，我们应该选择指明了计量对象和计量单位的命名，再看elapsedTimeInDays就可以体现出注释的含义了。 123456789public List&lt;int[]&gt; getThem() &#123; List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;(); for(int[] x : theList)&#123; if(x[0] == 4)&#123; list1.add(x); &#125; &#125; return list1;&#125; 上述代码中，当我们要取理解这段代码干了什么的时候，我们都会想问几个问题 theList是什么东西？ theList的零下标的值有什么含义吗？ 值等于4的意义是什么？ 返回的list1又代表什么？又怎么使用？ 避免误导编写代码的时候应该避免留下掩藏代码本意的错误线索，误导性最可怕的就是将大写字母O作为变量名。 123456int a = 1;if(O = 0)&#123; a = 0l;&#125;else&#123; a = O1;&#125; 虽然，上述代码一般不会这么写，但是，在这里，我们真的很难分清大写字母O、数字0、大写字母I和数字1等情况。 做有意义的区分我们在编写代码的时候经常会遇见命名重复的情况，这个时候，可能你会为了满足编译器不报错而随意更改其中的一个名称，有时候你会很简单的在后面加一个1或者2等等，这样的名称同样会引起误导，也没有提供正确的信息， 12345public void copyChars(char[] a1, char[] a2)&#123; for(int i = 0; i &lt; a1.length; i++)&#123; a2[i] = a1[i]; &#125;&#125; 上面的参数名称就表达不出任何意义的区分，也不能很清楚的明白是将谁复制给谁，如果，我们换一个命名，如下，应该就可以清楚了吧。 12345public void copyChars(char[] source, char[] target)&#123; for(int i = 0; i &lt; source.length; i++)&#123; target[i] = source[i]; &#125;&#125; 使用读的出来的名称在开发的时候，我们经常会与别人讨论代码，所以不要自己造词，增加沟通成本。 使用可以搜索的名称单字母和单数字的命名很难在项目中找到自己想要找到的，无论是为了快速定位，还是为了后期如果需要更改可以一键查找和替换，我们都应该在开始命名的时候，使用可搜索的名称。 避免使用编码编码已经太多，把类型编进名称里面，白白增加了解码的负担，带编码的名称也不利于发音，容易打错。 避免思维映射不应当让读者在脑中把你代码的名称翻译成他们熟悉的名称。 类名类名和对象名应该是名词和名词短语，不应该是动词。 方法名方法名应该是动词或者动词短语，依靠JavaBean并在前面添加get、delete等前缀。 别扮可爱不要想一个小学生一样，搞一个非主流的名称，这种做法在代码中只能是俗。 每个概念对应一个词给每一个抽象概念选中一个词，并且一以贯之。 避免使用双关语避免将同一个单词用于不同的目的，同一个术语","categories":[{"name":"书籍","slug":"书籍","permalink":"https://caochenhins.github.io/categories/书籍/"}],"tags":[{"name":"代码整洁之道","slug":"代码整洁之道","permalink":"https://caochenhins.github.io/tags/代码整洁之道/"},{"name":"book","slug":"book","permalink":"https://caochenhins.github.io/tags/book/"}]},{"title":"JavaEE基础知识学习-----StringUtils学习笔记","slug":"JavaEE基础知识学习-StringUtils学习笔记","date":"2019-03-21T14:33:26.000Z","updated":"2019-03-21T15:18:46.912Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-StringUtils学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-StringUtils学习笔记/","excerpt":"一、StringUtils字符串工具类1.1.判断是否空字符串 isBlank(final CharSequence cs)：判断是空字符串； isNotBlank(final CharSequence cs)：判断不是空字符串； isEmpty(final CharSequence cs)：判断是空字符串； isNotEmpty(final CharSequence cs)：判断不是空字符串；","text":"一、StringUtils字符串工具类1.1.判断是否空字符串 isBlank(final CharSequence cs)：判断是空字符串； isNotBlank(final CharSequence cs)：判断不是空字符串； isEmpty(final CharSequence cs)：判断是空字符串； isNotEmpty(final CharSequence cs)：判断不是空字符串； 字符串判空示例代码 12345678910StringUtils.isBlank(null); = trueStringUtils.isBlank(\"\"); = trueStringUtils.isBlank(\" \"); = trueStringUtils.isBlank(\"bob\"); = falseStringUtils.isBlank(\" bob \"); = falseStringUtils.isEmpty(null); = trueStringUtils.isEmpty(\"\"); = trueStringUtils.isEmpty(\" \"); = falseStringUtils.isEmpty(\"bob\"); = falseStringUtils.isEmpty(\" bob \"); = false 说明：isBlank和isEmpty的区别在于在于空格字符串的判断不同；简言之，Empty认为空格字符不是空字符串 1.2.判断是否存在空字符串 isAnyEmpty(final CharSequence... css)：判断是否存在空字符串； isNoneEmpty(final CharSequence... css)判断全部都不是空字符串； isAllEmpty(final CharSequence... css)：判断全部为空字符串； isAnyBlank(final CharSequence... css)：判断是否存在空字符串； isNoneBlank(final CharSequence... css)判断全部都不是空字符串； isAllBlank(final CharSequence... css)：判断全部为空字符串； 判断是否存在空字符串示例代码12345678910StringUtils.isAnyBlank(null) = trueStringUtils.isAnyBlank(null, \"foo\") = trueStringUtils.isAnyBlank(null, null) = trueStringUtils.isAnyBlank(\"\", \"bar\") = trueStringUtils.isAnyBlank(\"bob\", \"\") = trueStringUtils.isAnyBlank(\" bob \", null) = trueStringUtils.isAnyBlank(\" \", \"bar\") = trueStringUtils.isAnyBlank(new String[] &#123;&#125;) = falseStringUtils.isAnyBlank(new String[]&#123;\"\"&#125;) = trueStringUtils.isAnyBlank(\"foo\", \"bar\") = false 说明：同理，这里的区别也是在于空格字符串的不同对待； 1.3.去除字符串前后空格 trim(final String str):去除字符串前后空格，同时不改变原字符串； trimToNull(final String str)：去除字符串前后空格，如果去除后是空字符串就转为null； trimToEmpty(final String str)：去除字符串前后空格，如果去除后是空字符串就转为空字符串(null转为&quot;&quot;）; strip(final String str)：这个也可以去除字符串的前后空格，不改变原字符串； stripToNull(String str)：同trimToNull(final String str)类似； stripToEmpty(final String str)：同trimToEmpty(final String str)类似； 去除字符串前后空格示例代码123456StringUtils.trim(null) = nullStringUtils.trim(\" \") = \"\"StringUtils.trimToNull(null) = nullStringUtils.trimToNull(\" \") = nullStringUtils.trimToEmpty(null) = \"\"StringUtils.trimToEmpty(\" \") = \"\" 1.4.字符串截取 truncate(final String str, final int maxWidth)：截取字符串的前maxWidth个字符； 如果str的长度小于maxWidth就直接返回str； 如果maxWidth小于0则抛出IllegalArgumentException异常； truncate(final String str, final int offset, final int maxWidth)：截取指定区域的字符串； 字符串截取示例代码12345678910111213StringUtils.truncate(null, 0) = nullStringUtils.truncate(null, 2) = nullStringUtils.truncate(\"\", 4) = \"\"StringUtils.truncate(\"abcdefg\", 4) = \"abcd\"StringUtils.truncate(null, 0, 0) = nullStringUtils.truncate(null, 2, 4) = nullStringUtils.truncate(\"\", 0, 10) = \"\"StringUtils.truncate(\"\", 2, 10) = \"\"StringUtils.truncate(\"abcdefghij\", 0, 3) = \"abc\"StringUtils.truncate(\"abcdefghij\", 5, 6) = \"fghij\"StringUtils.truncate(\"abcdefghijklmno\", -1, 10) = throws an IllegalArgumentExceptionStringUtils.truncate(\"abcdefghijklmno\", Integer.MIN_VALUE, 10) = \"abcdefghij\"StringUtils.truncate(\"abcdefghijklmno\", 0, Integer.MAX_VALUE) = \"abcdefghijklmno\" 说明：更多的示例代码可以参考StringUtils源码； 1.5.字符串的剥离 strip(String str, final String stripChars)：从str的前后剥离stripChars字符串； stripStart(final String str, final String stripChars)：从开始的地方剥离指定字符串； stripEnd(final String str, final String stripChars)：从结束的地方剥离字符串； String[] stripAll(final String... strs)：对数组中的所有字符串进行去除空格； String[] stripAll(final String[] strs, final String stripChars)：对数组中的每个字符串进行字符串剥离； 字符串的剥离示例代码12345678StringUtils.strip(\"abcde\", \"de\"); = abcStringUtils.strip(\"abcde\", \"ed\"); = abcStringUtils.stripStart(\"deabced\", \"ed\"); = abcdStringUtils.stripStart(\"deabced\", \"de\"); = abcdStringUtils.stripEnd(\" abcyx\", \"xyz\"); = \" abc\"StringUtils.stripEnd(\"120.00\", \".0\"); = \"12\"StringUtils.stripAll([\"abc\", \" abc\"]); = [\"abc\", \"abc\"]StringUtils.stripAll([\"yabcz\", null], \"yz\"); = [\"abc\", null] 1.6.字符串的比较 equals(final CharSequence cs1, final CharSequence cs2):判断两个字符串是否相等； equalsIgnoreCase(final CharSequence str1, final CharSequence str2)：判断两个字符串在忽略大小写下是否相等； compare(final String str1, final String str2)：比较两个字符串长度的大小； compareIgnoreCase(final String str1, final String str2)忽略大小写下比较两个字符串的大小； equalsAny(final CharSequence string, final CharSequence... searchStrings):比较多字符串中是否存在相同的字符串； equalsAnyIgnoreCase(final CharSequence string, final CharSequence...searchStrings)：忽略大小写是否存在相同字符 字符串的比较代码示例12345678910111213141516StringUtils.equals(\"abc\", null) = falseStringUtils.equals(\"abc\", \"abc\") = trueStringUtils.equals(\"abc\", \"ABC\") = falsetringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = trueStringUtils.compare(\"abc\", \"abc\") = 0StringUtils.compare(\"a\", \"b\") &gt; 0StringUtils.compare(\"b\", \"a\") &lt; 0StringUtils.compare(\"a\", \"B\") &lt; 0StringUtils.compare(\"ab\", \"abc\") &lt; 0StringUtils.compareIgnoreCase(\"a\", \"B\") &lt; 0StringUtils.compareIgnoreCase(\"A\", \"b\") &lt; 0StringUtils.compareIgnoreCase(\"ab\", \"ABC\") &lt; 0StringUtils.equalsAny(\"abc\", \"abc\", \"def\") = trueStringUtils.equalsAny(\"abc\", \"ABC\", \"DEF\") = falseStringUtils.equalsAnyIgnoreCase(\"abc\", \"abc\", \"def\") = trueStringUtils.equalsAnyIgnoreCase(\"abc\", \"ABC\", \"DEF\") = true 1.7.字符串的查找 indexOf(final CharSequence seq, final int searchChar)：查找指定字符在字符串中首次出现的位置的索引值； indexOf(final CharSequence seq, final int searchChar, final int startPos)：从指定位置final int startPos开始查找； indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr)：忽略大小写的查找字符串首次出现位置 indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos)：同indexOf`类似； lastIndexOf(final CharSequence seq, final int searchChar)：从尾部开始查找； lastIndexOf(final CharSequence seq, final int searchChar, final int startPos)：同理从尾部开始查找指定位置前的字符 字符串的查找示例代码123456StringUtils.indexOf(\"aabaabaa\", 'b') = 2StringUtils.indexOf(\"aabaabaa\", \"\") = 0StringUtils.indexOf(\"aabaabaa\", \"b\", 3) = 5StringUtils.ordinalIndexOf(\"abababab\", \"abab\", 3) = 4StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0) = 0 1.8.是否包含字符串 contains(final CharSequence seq, final int searchChar：是否包含指定字符串； containsIgnoreCase(final CharSequence str, final CharSequence searchStr：忽略大小写下检查是否包含指定字符串 containsWhitespace(final CharSequence seq)：是否包含空白字符串； containsAny(final CharSequence cs, final char... searchChars)：判断字符窜是否包含后面多个中的任意一个； containsOnly(final CharSequence cs, final char... valid)：判断前面的字符是否全部是后面的字符中的； containsNone(final CharSequence cs, final char... searchChars)：判断前面字符是否不含其后字符的任意一个字符 是否包含字符串示例代码12345678910111213141516StringUtils.contains(\"abc\", 'a') = trueStringUtils.contains(\"abc\", 'z') = falseStringUtils.containsIgnoreCase(\"abc\", \"A\") = trueStringUtils.containsIgnoreCase(\"abc\", \"Z\") = falseStringUtils.containsWhitespace(\"abc\") = falseStringUtils.containsWhitespace(\"a bc\") = trueStringUtils.containsAny(\"zzabyycdxx\",['z','a']) = trueStringUtils.containsAny(\"zzabyycdxx\",['b','y']) = trueStringUtils.containsAny(\"zzabyycdxx\",['z','y']) = trueStringUtils.containsAny(\"aba\", ['z']) = falseStringUtils.containsOnly(\"abab\", 'abc') = trueStringUtils.containsOnly(\"ab1\", 'abc') = falseStringUtils.containsOnly(\"abz\", 'abc') = falseStringUtils.containsNone(\"abab\", 'xyz') = trueStringUtils.containsNone(\"ab1\", 'xyz') = trueStringUtils.containsNone(\"abz\", 'xyz') = false 1.9.截取字符串 substring(final String str, int start)：指定开始为止截取字符串； substring(final String str, int start):指定开始和结束为止截取字符串； left(final String str, final int len)：得到一个字符串最左边的len个字符； right(final String str, final int len)：得到一个字符串最右边的len个字符； mid(final String str, int pos, final int len)：得到中间的指定区域的字符，是左包含； substringBefore(final String str, final String separator)：得到一个字符串中第一个分割符之前的字符串； substringAfter(final String str, final String separator)：同理，得到一个字符串第一个分割符之后的字符串； 截取字符串示例代码1234567891011121314151617181920StringUtils.substring(\"abc\", 2) = \"c\"StringUtils.substring(\"abc\", 4) = \"\"StringUtils.substring(\"abc\", -2) = \"bc\"StringUtils.substring(\"abc\", -4) = \"abc\"StringUtils.substring(\"abc\", 2, 2) = \"\"StringUtils.substring(\"abc\", -2, -1) = \"b\"StringUtils.substring(\"abc\", -4, 2) = \"ab\"StringUtils.left(\"abc\", 2) = \"ab\"StringUtils.left(\"abc\", 4) = \"abc\"StringUtils.right(\"abc\", 2) = \"bc\"StringUtils.right(\"abc\", 4) = \"abc\"StringUtils.mid(\"abc\", 2, 4) = \"c\"StringUtils.mid(\"abc\", 4, 2) = \"\"StringUtils.mid(\"abc\", -2, 2) = \"ab\"StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"StringUtils.substringBefore(\"abc\", \"c\") = \"ab\"StringUtils.substringBefore(\"abc\", \"d\") = \"abc\"StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"StringUtils.substringAfter(\"abc\", \"c\") = \"\"StringUtils.substringAfter(\"abc\", \"d\") = \"\" 1.10.字符串分割 String[] split(final String str)：按照空格分割字符串，返回数组； String[] split(final String str, final char separatorChar)：指定分割符分割字符串； String[] split(final String str, final String separatorChars, final int max)：指定分割符，指定最大分割的数组大小; String[] splitByCharacterTypeCamelCase(final String str)：根据字符串类型分割字符串； 字符串分割示例代码123456789101112StringUtils.split(\"abc def\") = [\"abc\", \"def\"]StringUtils.split(\" abc \") = [\"abc\"]StringUtils.split(\"a..b.c\", '.') = [\"a\", \"b\", \"c\"]StringUtils.split(\"a:b:c\", '.') = [\"a:b:c\"]StringUtils.split(\"a b c\", ' ') = [\"a\", \"b\", \"c\"]StringUtils.split(\"ab:cd:ef\", \":\", 3); = [ab, cd, ef]StringUtils.split(\"ab:cd:ef\", \":\", 2); = [ab:cd:ef]StringUtils.split(\"ab:cd:ef\", \":\", 1); = [ab, cd:ef]StringUtils.splitByCharacterTypeCamelCase(\"number5\") = [\"number\", \"5\"]StringUtils.splitByCharacterTypeCamelCase(\"fooBar\") = [\"foo\", \"Bar\"]StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\") = [\"foo\", \"200\", \"Bar\"]StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\") = [\"ASF\", \"Rules\"] 1.11.字符串连接（数组转字符） join(final T... elements)；普通的连接字符串 join(final Object[] array, final char separator)：指定连接符，连接字符串； 字符串连接示例代码12345StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"StringUtils.join([null, \"\", \"a\"]) = \"a\"StringUtils.join([\"a\", \"b\", \"c\"], ';') = \"a;b;c\"StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"StringUtils.join([null, \"\", \"a\"], ';') = \";;a\" 1.12.删除和替换字符串 removeStart(final String str, final String remove)：删除字符串中的指定的前缀字符串； removeStartIgnoreCase(final String str, final String remove)：同removeStart类似，只是忽略的大小写； removeEnd(final String str, final String remove)：同removeStart相反； deleteWhitespace(final String str)：删除字符串中的空格； remove(final String str, final String remove)：从字符串中移除指定字符串； removeAll(final String text, final String regex)：移除符合正则表达式的所有字符串； replaceOnce(final String text, final String searchString, final String replacement)：将字符串中指定字符替换一个； replaceAll(final String text, final String regex, final String replacement)：将字符串中指定字符替换所有； 删除和替换字符串示例代码1234567891011121314151617181920212223StringUtils.removeStart(\"www.domain.com\", \"www.\") = \"domain.com\"StringUtils.removeStart(\"domain.com\", \"www.\") = \"domain.com\"StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"StringUtils.removeStart(\"abc\", \"\") = \"abc\"StringUtils.deleteWhitespace(\"abc\") = \"abc\"StringUtils.deleteWhitespace(\" ab c \") = \"abc\"StringUtils.removeEnd(\"www.domain.com\", \".com.\") = \"www.domain.com\"StringUtils.removeEnd(\"www.domain.com\", \".com\") = \"www.domain\"StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"StringUtils.remove(\"queued\", \"ue\") = \"qd\"StringUtils.remove(\"queued\", \"zz\") = \"queued\"StringUtils.removeAll(\"any\", \".*\") = \"\"StringUtils.removeAll(\"any\", \".+\") = \"\"StringUtils.removeAll(\"abc\", \".?\") = \"\"StringUtils.removeAll(\"A&amp;lt;__&amp;gt;\\n&amp;lt;__&amp;gt;B\", \"&amp;lt;.*&amp;gt;\") = \"A\\nB\"StringUtils.removeAll(\"A&amp;lt;__&amp;gt;\\n&amp;lt;__&amp;gt;B\", \"(?s)&amp;lt;.*&amp;gt;\") = \"AB\"StringUtils.removeAll(\"ABCabc123abc\", \"[a-z]\") = \"ABC123\"StringUtils.replaceOnce(\"aba\", \"a\", null) = \"aba\"StringUtils.replaceOnce(\"aba\", \"a\", \"\") = \"ba\"StringUtils.replaceOnce(\"aba\", \"a\", \"z\") = \"zba\"StringUtils.replaceAll(\"ABCabc123\", \"[^A-Z0-9]+\", \"_\") = \"ABC_123\"StringUtils.replaceAll(\"ABCabc123\", \"[^A-Z0-9]+\", \"\") = \"ABC123\"StringUtils.replaceAll(\"abc\", \"\", \"ZZ\") = \"ZZaZZbZZcZZ\" 1.13.重复字符串 repeat(final String str, final int repeat)：生成指定重复次数的重复字符串； 重复字符串生成示例代码123StringUtils.repeat(\"a\", 3) = \"aaa\"StringUtils.repeat(\"ab\", 2) = \"abab\"StringUtils.repeat(\"a\", -2) = \"\" 1.14.字符串出现次数 countMatches(final CharSequence str, final CharSequence sub)：获取指定字符串在原字符串中出现的次数； 字符串出现次数示例代码12StringUtils.countMatches(\"abba\", \"a\") = 2StringUtils.countMatches(\"abba\", \"ab\") = 1 二、StringUtils其他常用方法2.1.判断是否是空格或者数字 isNumericSpace(final CharSequence cs) 12StringUtils.isNumericSpace(\"12 3\") = trueStringUtils.isNumericSpace(\"12.3\") = false 2.2.判断是否是空格 isWhitespace(final CharSequence cs) 123StringUtils.isWhitespace(\"\") = trueStringUtils.isWhitespace(\" \") = trueStringUtils.isWhitespace(\"abc\") = false 2.3.判断是否全是小写 isAllLowerCase(final CharSequence cs) 12StringUtils.isAllLowerCase(\"abc\") = trueStringUtils.isAllLowerCase(\"abC\") = false 2.4.判断是否全是大写 isAllUpperCase(final CharSequence cs) 12StringUtils.isAllUpperCase(\"ABC\") = trueStringUtils.isAllUpperCase(\"aBC\") = false 2.5.反转字符串 reverse(final String str) 1StringUtils.reverse(\"bat\") = \"tab\" 2.6.字符串显示省略号 abbreviate(final String str, final int maxWidth) 1234StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\" 2.7.判断字符串是否以什么开头 startsWith(final CharSequence str, final CharSequence prefix) 123StringUtils.startsWith(\"abcdef\", null) = falseStringUtils.startsWith(\"abcdef\", \"abc\") = trueStringUtils.startsWith(\"ABCDEF\", \"abc\") = false 2.7.判断字符串是否以什么结尾 endsWith(final CharSequence str, final CharSequence suffix) 123StringUtils.endsWith(\"ABCDEF\", \"def\") = falseStringUtils.endsWith(\"ABCDEF\", \"cde\") = falseStringUtils.endsWith(\"ABCDEF\", \"\") = true","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Redis学习笔记","slug":"JavaEE基础知识学习-Redis学习笔记","date":"2019-03-21T14:32:51.000Z","updated":"2019-03-21T15:19:01.894Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Redis学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Redis学习笔记/","excerpt":"一、NoSQL简介1.1NoSOL是什么Not only sql，代表的不仅仅是sql，没有声明性查询语言；没有预定义的模式；使用键值对，列存储，文档存储，图形数据库的方式存储；最终一致性，而非ACID属性；CAP定理和高性能，高可用性； 1.2.数据库原理CAP+Base传统关系型数据库的ACID","text":"一、NoSQL简介1.1NoSOL是什么Not only sql，代表的不仅仅是sql，没有声明性查询语言；没有预定义的模式；使用键值对，列存储，文档存储，图形数据库的方式存储；最终一致性，而非ACID属性；CAP定理和高性能，高可用性； 1.2.数据库原理CAP+Base传统关系型数据库的ACID A (Atomicity) 原子性原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 C (Consistency) 一致性一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 I (Isolation) 独立性所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。 D (Durability) 持久性持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。 CAP理论 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性； Base理论 BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。BASE是下面三个术语的缩写：基本可用（Basically Available）、软状态（Soft state）和最终一致（Eventually consistent） 二、Redis简介REmote DIctionary Server(远程字典服务器) ,是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器; 2.1.Redis的特点Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用 ，Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 ，Redis支持数据的备份，即master-slave模式的数据备份 。详细资料参考官网英文官网和Redis中文网。 2.2.Redis安装第一步：连接虚拟机 1ssh root@192.168.1.18 第二步：拷贝本机文件到虚拟机中 1scp redis-5.0.0.tar.gz root@192.168.1.18:/opt 第三步：解压redis 1tar -zxvf redis-5.0.0.tar.gz 第四步：安装编译redis 12[root@localhost redis-5.0.0]# make [root@localhost redis-5.0.0]# make install 第五步：根目录创建我们自己的redis配置文件夹，存放redis的配置文件备份 12345[root@localhost ~]# cd /[root@localhost /]# mkdir myredis[root@localhost /]# cd opt/[root@localhost opt]# cd redis-5.0.0[root@localhost redis-5.0.0]# cp redis.conf /myredis/ 第六步：使用vim修改我们的redis配置文件 12vim redis.confdaemonize yes 如果提示vim命令不存在，则使用以下命令安装 1yum -y install vim* 第七步：查看redis服务是否启动 1[root@localhost myredis]# ps -ef|grep redis 第八步：启动我们的redis服务 12[root@localhost redis-5.0.0]# cd /usr/local/bin/[root@localhost bin]# redis-server /myredis/redis.conf 第九步：进入redis 1[root@localhost bin]# redis-cli -p 6379 第十步：查看redis服务是否被启动 12127.0.0.1:6379&gt; pingPONG 第十一步：退出redis 12127.0.0.1:6379&gt; SHUTDOWNnot connected&gt; exit 2.3.Redis的其他知识在redis中，默认16个数据库，类似数组下表从零开始，初始默认使用零号库 ,使用select命令切换数据库,使用dbsize命令查看当前数据库的key的数量 ，使用flushdb：清空当前库，使用Flushall；通杀全部库，Redis索引都是从零开始。 三、Redis五大数据类型3.1.数据类型简介Redis五大数据类型分别是：string（字符串）、hash（哈希 ）、list（列表） 、set（集合）和zset(sorted set：有序集合) ,可以在Redis常用命令找到自己忘记的redis命令； 3.2.Redis的key使用keys *命令查看当前库key的数量 1127.0.0.1:6379&gt; keys * 使用exists key命令判断当前库是否存在某一个key 1127.0.0.1:6379&gt; EXISTS k1 使用move key db命令将当前库的key移入到指定库中 1127.0.0.1:6379&gt; MOVE k1 2 使用ttl key命令查看指定key的存活时间，-1代表永不过期，-2代表已经过期 1127.0.0.1:6379&gt; ttl k2 使用expipre key second命令指定key的存活时间 1127.0.0.1:6379&gt; EXPIRE k2 10 说明：当key过期后，就已经从内存中移除了，使用keys *不能获取到 使用type key命令判断key的数据类型 1127.0.0.1:6379&gt; type k3 3.3.String数据类型string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。 常用的String命令 12345678910# 设值127.0.0.1:6379&gt; set k5 v5# 取值127.0.0.1:6379&gt; get k5# 删除对应的key127.0.0.1:6379&gt; del k3# 在指定的key后面添加value127.0.0.1:6379&gt; APPEND k5 hello# 获取指定key的长度127.0.0.1:6379&gt; STRLEN k5 value数字的加减操作 12345678# 将指定的key进行加1操作，注意key的value是数字才可以127.0.0.1:6379&gt; INCR k6# 将指定的key进行加指定的数字操作，注意key的value是数字才可以127.0.0.1:6379&gt; INCRBY k6 3# 将指定的key进行减1操作，注意key的value是数字才可以127.0.0.1:6379&gt; DECR k6# 将指定的key进行减指定的数字操作，注意key的value是数字才可以127.0.0.1:6379&gt; DECRBY k6 2 key的截取和替换命令 12345678127.0.0.1:6379&gt; set k1 hello12345# 只获取k1的0到4的value127.0.0.1:6379&gt; GETRANGE k1 0 4\"hello\"# 将k1中的第0位开始替换为word127.0.0.1:6379&gt; SETRANGE k1 0 word127.0.0.1:6379&gt; get k1\"wordo12345\" 向redis中添加key和value 1234# 增加指定存活时间的key-value127.0.0.1:6379&gt; SETEX k5 10 v5# 当key不存在时候才增加对应的key-value,0代表存在，增加不成功，1代表不存在，增加成功127.0.0.1:6379&gt; SETNX k1 v11 合并设置和取值 123456# mset:同时设置一个或多个 key-value 对127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3# mget:获取所有(一个或多个)给定 key 的值127.0.0.1:6379&gt; mget k1 k2 k3# msetnx:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在127.0.0.1:6379&gt; MSETNX k33 v33 k44 v44 3.4.List数据类型Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边），底层实际是个链表 List数据的添加命令 123456789101112131415161718192021# 将一个或多个值插入到列表的表头127.0.0.1:6379&gt; LPUSH list0 1 2 3 4 5# 返回列表中指定区间的元素127.0.0.1:6379&gt; LRANGE list0 0 -11) \"5\"2) \"4\"3) \"3\"4) \"2\"5) \"1\"# # 将一个或多个值插入到列表的表尾127.0.0.1:6379&gt; RPUSH list1 1 2 3 4 5127.0.0.1:6379&gt; LRANGE list1 0 -11) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\"# 移除并返回列表的头元素127.0.0.1:6379&gt; lpop list0# 移除并返回列表的尾元素127.0.0.1:6379&gt; RPOP list1 常用的操作命令 123456789101112# 返回列表中下标为index的元素127.0.0.1:6379&gt; LINDEX list0 1# 返回列表的长度127.0.0.1:6379&gt; LLEN list1# 根据参数 count 的值，移除列表中与参数 value 相等的元素127.0.0.1:6379&gt; LREM list1 3 3# 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。127.0.0.1:6379&gt; LTRIM list1 0 0# 将列表 key 下标为 index 的元素的值设置为 value 127.0.0.1:6379&gt; LSET list1 0 9# LINSERT key BEFORE|AFTER pivot value,将值 value 插入到列表 key 当中，位于值 pivot 之前或之后127.0.0.1:6379&gt; LINSERT list1 after 9 34 3.5.Set集合数据类型常用命令 12345678910111213141516171819202122# 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。127.0.0.1:6379&gt; SADD set0 1 1 2 2 3 3# 返回集合 key 中的所有成员。127.0.0.1:6379&gt; SMEMBERS set0# 判断 member 元素是否集合 key 的成员。1代表存在127.0.0.1:6379&gt; SISMEMBER set0 2# 返回集合 key 的基数(集合中元素的数量)。127.0.0.1:6379&gt; SCARD set0# 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略127.0.0.1:6379&gt; SREM set0 1# 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素127.0.0.1:6379&gt; SRANDMEMBER set0 1# 移除并返回集合中的一个随机元素。127.0.0.1:6379&gt; SPOP set0# 将 member 元素从 source 集合移动到 destination 集合。127.0.0.1:6379&gt; SMOVE set0 set1 2# 返回一个集合的全部成员，该集合是所有给定集合之间的差集。127.0.0.1:6379&gt; SDIFF set0 set1# 返回一个集合的全部成员，该集合是所有给定集合的交集127.0.0.1:6379&gt; SINTER set0 set1# 返回一个集合的全部成员，该集合是所有给定集合的并集127.0.0.1:6379&gt; SUNION set0 set1 3.6.Hash数据类型常用命令 1234567891011121314151617181920212223242526# 将哈希表 user 中的域 id 的值设为 12 。127.0.0.1:6379&gt; hset user id 12# 返回哈希表 user 中给定域 id 的值。127.0.0.1:6379&gt; hget user id# 同时将多个 field-value (域-值)对设置到哈希表 dept 中127.0.0.1:6379&gt; HMSET dept id 12 name deptname age 14# 返回哈希表 key 中，一个或多个给定域的值。127.0.0.1:6379&gt; HMGET dept id name age# 返回哈希表 key 中，所有的域和值127.0.0.1:6379&gt; HGETALL dept# 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。127.0.0.1:6379&gt; HDEL user id# 返回哈希表 key 中域的数量127.0.0.1:6379&gt; HLEN dept# 查看哈希表 key 中，给定域 field 是否存在。127.0.0.1:6379&gt; HEXISTS dept id# 返回哈希表 key 中的所有域。127.0.0.1:6379&gt; HKEYS dept# 返回哈希表 key 中所有域的值。127.0.0.1:6379&gt; HVALS dept# 为哈希表 dept 中的域 age 的值加上增量 5 。增量可以为负数127.0.0.1:6379&gt; HINCRBY dept age 5# 为哈希表 key 中的域 field 加上浮点数增量 increment 。127.0.0.1:6379&gt; HINCRBYFLOAT dept age 12.3# 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。127.0.0.1:6379&gt; HSETNX dept sex 1 3.7.Zset数据类型在set基础上，加一个score值，之前set是k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2。 常用命令 1234567891011121314151617181920# 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。127.0.0.1:6379&gt; ZADD zset0 99 v1 89 v2 54 v3 56 v4 65 v5# 返回有序集 key 中，指定区间内的成员,同时返回SCORES127.0.0.1:6379&gt; ZRANGE zset0 0 -1 WITHSCORES# 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员127.0.0.1:6379&gt; ZRANGEBYSCORE zset0 60 90# 大于60小于等于90127.0.0.1:6379&gt; ZRANGEBYSCORE zset0 60 (90# 大于60 小于90127.0.0.1:6379&gt; ZRANGEBYSCORE zset0 (60 (90# 大于等于60小于等于90 的前两条127.0.0.1:6379&gt; ZRANGEBYSCORE zset0 60 90 limit 2 2# 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略127.0.0.1:6379&gt; ZREM zset0 v3# 返回有序集 key 的基数127.0.0.1:6379&gt; ZCARD zset0# 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。127.0.0.1:6379&gt; ZCOUNT zset0 60 90# 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序127.0.0.1:6379&gt; ZREVRANK zset0 v5 四、Redis配置文件首先，从前面我们就可以看出，redis的配置文件redis.conf位于redis安装包里,但是我们一般都不会修改redis本身的配置文件，而是复制一份修改。 4.1.units单位打开redis.conf文件，我们就可以看见redis的units单位，如下若是 123456# 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes 4.2.GENERAL通用配置 daemonize yes配置，默认情况下，ReIIS不作为守护进程运行。 loglevel notice：日志级别，redis有四种日志级别，分别是debug、verbose、notice、warning port 6379：端口配置。 tcp-backlog：设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。 timeout 0：在客户端空闲N秒后关闭连接（0禁用）。 tcp-keepalive：单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 。 syslog-enabled：是否把日志输出到syslog中 syslog-ident：指定syslog里的日志标志 五、Redis持久化","categories":[{"name":"Redis","slug":"Redis","permalink":"https://caochenhins.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://caochenhins.github.io/tags/Redis/"}]},{"title":"JavaEE基础知识学习-----Mysql学习总结","slug":"JavaEE基础知识学习-Mysql学习总结","date":"2019-03-21T14:32:19.000Z","updated":"2019-03-21T15:19:06.052Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Mysql学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Mysql学习总结/","excerpt":"数据库简介数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 数据库相关概念 DB：数据库，保存一组有组织的数据的容器 DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 SQL:结构化查询语言，用于和DBMS通信的语言","text":"数据库简介数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 数据库相关概念 DB：数据库，保存一组有组织的数据的容器 DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 SQL:结构化查询语言，用于和DBMS通信的语言 数据库存储特点 将数据放到表中，表再放到库中 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。 表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性” 表中的数据是按行存储的，每一行类似于java中的“对象”。 Mysql常用命令查看当前所有的数据库 1show databases; 打开指定的库 1use 库名 查看当前库的所有表 1show tables; 查看其它库的所有表 1show tables from 库名; 创建表 1234create table 表名( 列名 列类型, 列名 列类型 ); 查看表结构 1desc 表名; Mysql语法规范 不区分大小写,但建议关键字大写，表名、列名小写 每条命令最好用分号结尾 每条命令根据需要，可以进行缩进 或换行 注释 单行注释：#注释文字 单行注释：– 注释文字 多行注释：/ 注释文字 / SQL语言分类 DQL（Data Query Language）：数据查询语言，例如：select DML(Data Manipulate Language):数据操作语言，例如：insert 、update、delete DDL（Data Define Languge）：数据定义语言，例如：create、drop、alter TCL（Transaction Control Language）：事务控制语言，例如：commit、rollback DQL语言学习基础查询语法 12SELECT 要查询的东西【FROM 表名】; 特点 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据 语法 123456select 要查询的字段|表达式|常量值|函数from 表where 条件 ; 分类 条件表达式，例如：salary&gt;10000，条件运算符：&gt; &lt; &gt;= &lt;= = != &lt;&gt; 逻辑表达式，例如：salary&gt;10000 &amp;&amp; salary&lt;20000，逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true 模糊查询，例如：last_name like ‘a%’ 排序查询语法 1234567select 要查询的东西from 表where 条件order by 排序的字段|表达式|函数|别名 【asc|desc】 常见函数字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数 数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断 日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符 流程控制函数 if 处理双分支 case语句 处理多分支情况1：处理等值判断 情况2：处理条件判断 分组函数 sum 求和 max 最大值 min 最小值 avg 平均值 count 计数 分组函数说明 以上五个分组函数都忽略null值，除了count(*) sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持：字段、*、常量值，一般放1 分组查询语法 123select 查询的字段，分组函数from 表group by 分组的字段 分组查询特点 可以按单个字段分组 和分组函数一同查询的字段最好是分组后的字段 分组筛选 分组前筛选： 原始表 group by的前面 where 分组后筛选： 分组后的结果集 group by的后面 having 可以按多个字段分组，字段之间用逗号隔开 可以支持排序 having后可以支持别名 多表查询语法 12345678select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 子查询子查询含义 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 子查询特点 子查询都放在小括号内 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧 子查询优先于主查询执行，主查询使用了子查询的执行结果 子查询根据查询结果的行数不同分为以下两类 单行子查询：结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= ，非法使用子查询的情况：子查询的结果为一组值或者子查询的结果为空 多行子查询：结果集有多行，一般搭配多行操作符使用：any、all、in、not in，in： 属于子查询结果中的任意一个就行，any和all往往可以用其他查询代替 分页查询语法 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点 起始条目索引从0开始 limit子句放在查询语句的最后 公式：select from 表 limit （page-1）sizePerPage,sizePerPage 联合查询语法 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点 多条查询语句的查询的列数必须是一致的 多条查询语句的查询的列的类型几乎相同 union代表去重，union all代表不去重 DML语言学习插入语法 12insert into 表名(字段名，...)values(值1，...); 特点 字段类型和值类型一致或兼容，而且一一对应 可以为空的字段，可以不用插入值，或用null填充 不可以为空的字段，必须插入值 字段个数和值的个数必须一致 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法 12update 表名 set 字段=新值,字段=新值【where 条件】 修改多表语法 1234update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件 删除单表删除 1delete from 表名 【where 筛选条件】 多表删除 1234delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 使用truncate语句删除 1truncate table 表名 delelte和truncate区别 truncate不能加where条件，而delete可以加where条件 truncate的效率高一丢丢 truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始 delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 truncate删除不能回滚，delete删除可以回滚 DDL语言学习库和表管理库的管理 1234--创建库create database 库名--删除库drop database 库名 表的管理 123456789101112131415161718192021--创建表CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);DESC studentinfo;--修改表 alterALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;--修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;--修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;--修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;--添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;--删除字段ALTER TABLE studentinfo DROP COLUMN email;--删除表DROP TABLE [IF EXISTS] studentinfo; 数据库事务概念通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点 A：原子性：要么都执行，要么都回滚 C：一致性：保证数据的状态操作前和操作后保持一致 I：隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 D：持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 使用事务步骤 开启事务 编写事务的一组逻辑操作单元（多条sql语句） 提交事务或回滚事务 事务分类隐式事务，没有明显的开启和结束事务的标志 例如：insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 12345671、开启事务 取消自动提交事务的功能 2、编写事务的一组逻辑操作单元（多条sql语句） insert update delete 3、提交事务或回滚事务 关键字1234567set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别当多个事务同时操作同一个数据库的相同数据时就会产生事务并发问题，常见的事务并发问题有如下几种 脏读：一个事务读取到了另外一个事务未提交的数据 不可重复读：同一个事务中，多次读取到的数据不一致 如何避免事务的并发问题 通过设置事务的隔离级别 READ UNCOMMITTED READ COMMITTED 可以避免脏读 REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读 SERIALIZABLE可以避免脏读、不可重复读和幻读 如何设置事务的隔离级别 1set session|global transaction isolation level 隔离级别名; 如何查看事务的隔离级别 1select @@tx_isolation; 视图视图可以理解为一张虚拟的表，视图和表的区别如下 使用方式 占用物理空间 视图 完全相同 不占用，仅保存的是SQL逻辑 表 完全相同 占用 使用视图的好处 sql语句提高重用性，效率高 和表实现了分离，提高了安全性 视图的创建123CREATE VIEW 视图名AS查询语句; 视图操作123456789--查看视图的数据 SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners';--插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);--修改视图的数据UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';--删除视图的数据DELETE FROM my_v4; 不能更新的视图 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all 常量视图 Select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表 视图删除1DROP VIEW test_v1,test_v2,test_v3; 查看视图结构12DESC test_v7;SHOW CREATE VIEW test_v7; 存储过程存储过程：一组经过预先编译的sql语句的集合 使用存储过程的好处 提高了sql语句的重用性，减少了开发程序员的压力 提高了效率 减少了传输次数 存储过程分类 无返回无参 仅仅带in类型，无返回有参 仅仅带out类型，有返回无参 既带in又带out，有返回有参 带inout，有返回有参 注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程1234create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 注意 1234567891011CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $-- 存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end-- 参数前面的符号的意思 -- in:该参数只能作为输入 （该参数不能做返回值） -- out：该参数只能作为输出（该参数只能做返回值） -- inout：既能做输入又能做输出 调用存储过程1call 存储过程名(实参列表)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://caochenhins.github.io/tags/Mysql/"}]},{"title":"JavaEE基础知识学习-----Mysql基础学习笔记","slug":"JavaEE基础知识学习-Mysql基础学习笔记","date":"2019-03-21T14:31:55.000Z","updated":"2019-03-21T15:20:44.724Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Mysql基础学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Mysql基础学习笔记/","excerpt":"一、Mysql基础学习笔记1.1.基本的sql语句select语句1234567891011SELECT DISTINCT USER .id AS userId, USER.user_name AS NAME, USER.age AS age, USER.gender AS gender FROM tbl_user USER WHERE USER.id &lt; 11 ORDER BY USER.id DESC","text":"一、Mysql基础学习笔记1.1.基本的sql语句select语句1234567891011SELECT DISTINCT USER .id AS userId, USER.user_name AS NAME, USER.age AS age, USER.gender AS gender FROM tbl_user USER WHERE USER.id &lt; 11 ORDER BY USER.id DESC 使用select关键字查询，DISTINCT关键字去重，WHERE关键字拼接条件，ORDER BY关键字定排序字段和方式； Update语句12 常用的命令123456789101112131415mysql -h localhost -P 3306 -u root -p # 连接数据库，连接本地可以 mysql -u root -pshow databases; # 查看数据库use test; # 切换数据库show tables; # 查看当前数据库的表show tables from test; # 在当前数据库下查看其他库存在的数据表select database(); # 查看当前库是那个select version(); # 查看数据库版本desc test; # 查看表结构 1.2.sql中查询mysql中的加号在mysql中，加号仅仅是一种运算符，不能作为字符串的连接方式，例如， 1234567select \"hello\" + \"word\"; # 结果：0select \"Hello\" + 100; # 结果：100select \"1\" + 99; # 结果：100select null + 12; # 结果： null ,只有加号两边存在一个null，结果就为null; 字符串的拼接使用concat函数，这是一个可以传入多个参数的可变参数函数，使用方法如下： 12SELECT concat ( \"hello\", \"：\",\"word\" ); # 结果：hello：word IFNULL函数，当值为空时1234SELECT IFNULL(USER.age,0) AS ageFROM tbl_user USER 查询的时候，使用IFNULL函数，可以将查询结果为null的字段赋上我们需要的默认值。 条件查询在开始的的基本sql语句中，我们的查询语句中，就使用了条件查询的关键字where , 在mysql中，条件的查询还存在一下关键字。 条件运算符：&gt;（大于）、&lt;（小于）、 =（等于） 、!=（不等于）、&lt;&gt;（不等于）、&gt;=（大于等于）、&lt;=（小于等于） like（模糊查询）、 between and 、in、is null &amp;&amp; 、||、!、and、 or、not","categories":[{"name":"数据库","slug":"数据库","permalink":"https://caochenhins.github.io/categories/数据库/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://caochenhins.github.io/tags/Mysql/"}]},{"title":"JavaEE基础知识学习-----MapUtils学习笔记","slug":"JavaEE基础知识学习-MapUtils学习笔记","date":"2019-03-21T14:31:14.000Z","updated":"2019-03-21T15:20:35.134Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-MapUtils学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-MapUtils学习笔记/","excerpt":"一、MapUtils学习笔记官方文档传送门：MapUtils 本篇笔记的基础示例数据代码如下： 12345HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(\"name\",\"zhangsan\");map.put(\"sex\",true);map.put(\"age\",34);map.put(\"money\",null); 1.1.MapUtils常用方法","text":"一、MapUtils学习笔记官方文档传送门：MapUtils 本篇笔记的基础示例数据代码如下： 12345HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(\"name\",\"zhangsan\");map.put(\"sex\",true);map.put(\"age\",34);map.put(\"money\",null); 1.1.MapUtils常用方法 获取Map中指定key的value使用getString(final Map map, final Object key)方法，当然，也可使用getString( Map map, Object key, String defaultValue )方法，当我们get属性值时候发生了转换异常的就会报错，为了避免这种报错，可以使用默认值的方法解决。 1String name = MapUtils.getString(map, \"name\"); 当我们获取Integer类型的时候，当类型不能转换时候报java.lang.NullPointerException如下： 1int money = MapUtils.getInteger(map,\"money\"); 就可以使用getInteger( Map map, Object key, Integer defaultValue )方法解决。 1int money = MapUtils.getInteger(map,\"money\",23); MapUtils中其他的get属性值的方法还有如下这些，使用方法和MapUtils.getString一样，这里就不再一一举例说明， Object getObject(final Map map, final Object key)：获取Object类型的值。 String getString(final Map map, final Object key)：获取String类型的值。 Boolean getBoolean(final Map map, final Object key)：获取Boolean类型的值。 Number getNumber(final Map map, final Object key)：获取Number类型的值。 Byte getByte(final Map map, final Object key)：获取Byte类型的值。 Short getShort(final Map map, final Object key)：获取Short类型的值。 Integer getInteger(final Map map, final Object key)：获取Integer类型的值。 Long getLong(final Map map, final Object key)：获取Long类型的值。 Float getFloat(final Map map, final Object key)：获取Float类型的值。 Double getDouble(final Map map, final Object key)：获取Double类型的值。 Map getMap(final Map map, final Object key)：获取Map类型的值。 说明：每一个获取值的方法都有一个带有获取失败使用默认值的方法。 Map判空使用MapUtils.isEmpty方法和MapUtils.isNotEmpty方法对Map进行空判断。 12boolean empty = MapUtils.isEmpty(map);boolean notEmpty = MapUtils.isNotEmpty(map); 将二维数组放入Map中使用MapUtils.putAll方法。 12String[][] user = &#123;&#123;\"names\",\"zhangfsan\"&#125;,&#123;\"sexs\",\"1f\"&#125;&#125;;Map map1 = MapUtils.putAll(map, user); MapUtils类的常用方法基本就是这些，后面设计的MultiMap、LazyMap、BidiMap会在后面的博客中仔细说明，我们在平时的开发中应该多使用开源的工具类，简洁高效我们的代码。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Linux学习笔记","slug":"JavaEE基础知识学习-Linux学习笔记","date":"2019-03-21T14:30:42.000Z","updated":"2019-03-21T15:20:57.381Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Linux学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Linux学习笔记/","excerpt":"#Linux学习笔记","text":"#Linux学习笔记","categories":[{"name":"部署","slug":"部署","permalink":"https://caochenhins.github.io/categories/部署/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://caochenhins.github.io/tags/Linux/"}]},{"title":"JavaEE基础知识学习-----HashMap学习笔记","slug":"JavaEE基础知识学习-HashMap学习笔记","date":"2019-03-21T14:30:10.000Z","updated":"2019-03-21T15:18:52.925Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-HashMap学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-HashMap学习笔记/","excerpt":"一、HashMap学习笔记HashMap采用数组+链表的数据结构，只是在jdk1.7和1.8的实现上有所不同，下面，简单的分析一下，方便自己更加深刻的理解这种典型的key-value的数据结构。 1.1.jdk1.7实现原理简单分析1.7的HashMap数据结构图 也可以这么理解","text":"一、HashMap学习笔记HashMap采用数组+链表的数据结构，只是在jdk1.7和1.8的实现上有所不同，下面，简单的分析一下，方便自己更加深刻的理解这种典型的key-value的数据结构。 1.1.jdk1.7实现原理简单分析1.7的HashMap数据结构图 也可以这么理解 在jdk1.8之前，HashMap由数组 + 链表组成，也就是链表散列，数组是HashMap的主体，链表实则是为了解决哈希冲突而存在的，（拉链法解决哈希冲突） 。 HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 1.7的HashMap类中的常量12345678910111213141516171819202122/** 初始化桶大小，HashMap底层是数组，这个是数组默认的大小 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** 桶的最大值 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** 默认的负载因子 */static final float DEFAULT_LOAD_FACTOR = 0.75f;static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;/** table真正存放数据的数组 */transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;/** map中存放数据的大小 */transient int size;/** 桶大小。可以在初始化的时候显示指定 */int threshold;/** 负载因子，可以在初始化的时候显示指定 */final float loadFactor; loadFactor负载因子默认的HashMap的容量是16，负载因子是0.75，当我们在使用HashMap的时候，随着我们不断的put数据，当数量达到16 * 0.75 = 12的时候，就需要将当前的16进行扩容，而扩容就涉及到数据的复制，rehash等，就消耗性能，所谓的负载因子，也可以叫加载因子，用来控制数组存放数据的疏密程度，loadFactor越趋紧与1，说明数组中存放的entry越多，链表的长度就越长。所以，建议当我们知道HashMap的使用大小时，应该在初始化的时候指定大小，减少扩容带来的性能消耗。 loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 threshold桶大小threshold桶大小，也叫临界值，threshold = capacity \\* loadFactor，当HashMap的Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 threshold是衡量数组是否需要扩增的一个标准。 table存放数据的数组table数组中存放的是Entry类型的数据，下面我们简单看看Entry的定义。 12345678910111213static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** 创建一个新的Entry */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125;&#125; Entry是一个内部类，其中的key就是写入的键，value就是写入的值，由于HashMap由数组+链表的形式，这里的next就是用于实现链表结构。hash存放的事当前key的hashcode值。 put()方法12345678910111213141516171819202122232425262728public V put(K key, V value) &#123; /** 判断当前数组是否需要初始化 */ if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; /** 如果key为空，则put一个空值进去 */ if (key == null) return putForNullKey(value); /** 根据key计算出hashcode值 */ int hash = hash(key); /** 根据计算的hashcode值定位所在的桶 */ int i = indexFor(hash, table.length); /** 如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等， */ for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; /** 如果相等则进行覆盖，并返回原来的值 */ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; /** 如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置 */ addEntry(hash, key, value, i); return null;&#125; 新增一个Entry1234567891011121314151617void addEntry(int hash, K key, V value, int bucketIndex) &#123; /** 判断当前HashMap的size与临界值的大小，判断是否需要扩容操作 */ if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; /** 如果需要扩容，就进行2倍扩容 */ resize(2 * table.length); /** 将当前的key重新hash并定位 */ hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; /** 创建一个Entry,如果当前桶存在元素，就形成链表 */ createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; put()方法简单将如下： get()方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; /** 如果key为null,就去数组[0]的位置找 */ if (key == null) return getForNullKey(); /** 根据key获取Entry */ Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; /** 如果当前HashMap的size都为0，那就直接返回null */ if (size == 0) &#123; return null; &#125; /** 根据key计算hashcode值,然后定位到具体的桶中 */ int hash = (key == null) ? 0 : hash(key); /** 判断是否是链表，为链表则需要遍历直到 key 及 hashcode 相等时候就返回值*/ for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; /** 不是链表就根据 key、key 的 hashcode 是否相等来返回值*/ if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; /** 啥都没取到就直接返回 null */ return null;&#125; 1.2.jdk1.8实现原理简单分析在jdk1.7中HashMap实现原理分析，我们知道当hash冲突很严重的时候，链表的长度就会很长，我们也知道数组和链表的优缺点，简单总结一下： 数组：数据存储是连续的，占用内存很大，所以空间复杂度较高，但是二分查找的时间复杂度为O(1)，简单讲就是，数组寻址容易，插入和删除较为困难。 链表：存储区间零散，所以内存较为宽松，故空间复杂度较低，但是时间复杂的高，为O(n)，简单讲就是，链表寻址困难，插入和删除较为容易。 所以，在jdk1.8中，对HashMap的实现做了相应的修改，jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。 1.8的HashMap的数据结构图 1.8的HashMap类的常量1234567891011121314151617181920212223242526272829303132333435/** 默认的初始容量16 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** 最大的容量 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** 默认的填充因子 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** 当桶上的节点数量大于8时，会将链表转为红黑树 */static final int TREEIFY_THRESHOLD = 8;/** 当桶上的节点数量小于6时，会将红黑树转为链表 */static final int UNTREEIFY_THRESHOLD = 6;/**桶中的结构转为红黑树对应的最小数组大小为64 */static final int MIN_TREEIFY_CAPACITY = 64;/** 存储元素的数组，总是2的幂次倍 */transient Node&lt;K,V&gt;[] table;/** 存放具体元素的集合 */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** 存放元素的个数，注意的是这个值不等于数组的长度 */transient int size;/** 每次扩容或者更改map结构的计数器 */transient int modCount;/** 临界值，当实际大小（容量 * 负载因子）超过临界值的时候，就会进行扩容操作 */int threshold;/** 负载因子 */final float loadFactor; 对比1.7中的常量，我们就会发现1.8中做了如下的改变。 增加了TREEIFY_THRESHOLD，当链表的长度超过这个值的时候，就会将链表转换红黑树。 Entry修改为Node，虽然Node的核心也是key、value、next。 Node类123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; // 哈希值 final K key; // key V value; // value Node&lt;K,V&gt; next; // 指向下一个节点&#125; 树节点类1234567static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; boolean red; // 判断颜色&#125; put()方法123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; /** 判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化） */ if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /** 根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空， * 为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。 */ if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; /** 如果当前桶有值（ Hash 冲突）， * 那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e */ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; /** 如果当前桶为红黑树，那就要按照红黑树的方式写入数据*/ else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; /** 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）*/ for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); /** 接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树 */ if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; /** 如果在遍历过程中找到 key 相同时直接退出遍历 */ if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; /** 如果 e != null 就相当于存在相同的 key,那就需要将值覆盖 */ if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; /** 最后判断是否需要进行扩容 */ if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; put方法图解 get()方法12345public V get(Object key) &#123; Node&lt;K,V&gt; e; /** 首先将 key hash 之后取得所定位的桶 */ return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 123456789101112131415161718192021222324final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; /** 如果桶为空则直接返回 null */ if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; /** 否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value */ if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; /** 如果第一个不匹配，则判断它的下一个是红黑树还是链表 */ if ((e = first.next) != null) &#123; /** 红黑树就按照树的查找方式返回值 */ if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); /** 链表就遍历匹配返回值 */ do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 小结从上面的简单分析中，我们可以知道在jdk1.8之后，对HashMap的实现做了改变，主要在于将链表的长度超过临界值的时候，就将链表转为红黑树，利用红黑树的优点，可以更好的查找元素，使得查询的时间复杂度变为O(logn) 但是，jdk1.8并未有修改HashMap之前的线程安全问题，我们都知道HashMap是线程不安全的，涉及到线程安全的时候，我们应该使用ConcurrentHashMap，有关ConcurrentHashMap的知识将在下一片博客中学习，这里简单的分析一下，为什么HashMap会造成线程不安全尼？ 1.3.HashMap线程不安全的原因resize造成死循环在1.7中，当数据put进HashMap的时候，都会比较和thredhold的大小，当超过临界值的时候，就会进行扩容操作，就会调用resize()方法。而resize()中调用了transfer方法。下面简单的看看transfer方法。 但是在1.8中，resize()方法的实现和1.7有一些不一样，没有使用transfer方法，可以说1.8中hashmap不会因为多线程put导致死循环，但是依然有其他的弊端，比如数据丢失等。因此多线程情况下还是建议使用concurrenthashma, Jdk1.7中transfer方法如下： 123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; transfer方法的的作用就是： 对索引数组中的元素遍历 对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。 循环2，直到链表节点全部转移 循环1，直到所有索引数组全部转移 转移的时候是逆序的。假如转移前链表顺序是1-&gt;2-&gt;3，那么转移后就会变成3-&gt;2-&gt;1。死锁问题不就是因为1-&gt;2的同时2-&gt;1造成的吗？所以，HashMap 的死锁问题就出在这个transfer()函数上。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Guava MultiSet学习笔记","slug":"JavaEE基础知识学习-Guava-MultiSet学习笔记","date":"2019-03-21T14:29:48.000Z","updated":"2019-03-21T15:20:07.036Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Guava-MultiSet学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Guava-MultiSet学习笔记/","excerpt":"一、MultiSet学习笔记首先，我们来假定一个场景，统计一个词在文档中出现了多少次，传统的做法是这样的：。 我们可以这样来实现, 123456789Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();for (String word : words) &#123; Integer count = counts.get(word); if (count == null) &#123; counts.put(word, 1); &#125; else &#123; counts.put(word, count + 1); &#125;&#125;","text":"一、MultiSet学习笔记首先，我们来假定一个场景，统计一个词在文档中出现了多少次，传统的做法是这样的：。 我们可以这样来实现, 123456789Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();for (String word : words) &#123; Integer count = counts.get(word); if (count == null) &#123; counts.put(word, 1); &#125; else &#123; counts.put(word, count + 1); &#125;&#125; 1.1.什么是MultiSetGuava提供了一个新集合类型 Multiset，它可以多次添加相等的元素，我们可以这样来看待MultiSet 没有元素顺序限制的ArrayList&lt;E&gt;,也就是说Multiset {a, a, b}和{a, b, a}是相等的。 Map&lt;E, Integer&gt;，键为元素，值为计数。 没有元素顺序限制的ArrayList&lt;E&gt;当把Multiset看成普通的Collection时，它表现得就像无序的ArrayList add(E)添加单个给定元素 iterator()返回一个迭代器，包含Multiset的所有元素（包括重复的元素） size()返回所有元素的总个数（包括重复的元素） 12345678910public void testHashMultiset()&#123; HashMultiset&lt;String&gt; hashMultiset = HashMultiset.create(); hashMultiset.add(\"zhangsan\"); hashMultiset.add(\"lisi\"); System.out.println(hashMultiset.size()); Iterator&lt;String&gt; iterator = hashMultiset.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125;&#125; 当把Multiset看作Map&lt;E, Integer&gt;时，它也提供了符合性能期望的查询操作： count(Object)返回给定元素的计数。HashMultiset.count的复杂度为O(1)，TreeMultiset.count的复杂度为O(log n)。 entrySet()返回Set&lt;Multiset.Entry&lt;E&gt;&gt;，和Map的entrySet类似。 elementSet()返回所有不重复元素的Set&lt;E&gt;，和Map的keySet()类似。 所有Multiset实现的内存消耗随着不重复元素的个数线性增长。 1234567891011121314public void testHashMultiset()&#123; HashMultiset&lt;String&gt; hashMultiset = HashMultiset.create(); hashMultiset.add(\"zhangsan\",12); hashMultiset.add(\"lisi\",5); System.out.println(hashMultiset.count(\"lisi\")); Set&lt;Entry&lt;String&gt;&gt; entrySet = hashMultiset.entrySet(); for (Entry&lt;String&gt; entry : entrySet) &#123; System.out.println(entry.getElement() + \"===\" + entry.getCount()); &#125; Set&lt;String&gt; elementSet = hashMultiset.elementSet(); for (String element : elementSet) &#123; System.out.println(element); &#125; &#125; 注意，Multiset.addAll(Collection)可以添加Collection中的所有元素并进行计数，这比用for循环往Map添加元素和计数方便多了。 Multiset常用方法 方法 描述 count(E) 给定元素在Multiset中的计数 elementSet() Multiset中不重复元素的集合，类型为Set&lt;E&gt; entrySet() 和Map的entrySet类似，返回Set&lt;Multiset.Entry&lt;E&gt;&gt;，其中包含的Entry支持getElement()和getCount()方法 add(E, int) 增加给定元素在Multiset中的计数 remove(E, int) 减少给定元素在Multiset中的计数 setCount(E, int) 设置给定元素在Multiset中的计数，不可以为负数 size() 返回集合元素的总个数（包括重复的元素） 1.2.Multiset的各种实现 Map 对应的Multiset 是否支持null元素 HashMap HashMultiset 是 TreeMap TreeMultiset 是 LinkedHashMap LinkedHashMultiset 是 ConcurrentHashMap ConcurrentHashMultiset 否 ImmutableMap ImmutableMultiset 否","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Git学习笔记","slug":"JavaEE基础知识学习-Git学习笔记","date":"2019-03-21T14:29:14.000Z","updated":"2019-03-21T15:20:48.851Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Git学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Git学习笔记/","excerpt":"一、版本控制Git学习笔记1.1.Git的工作流程","text":"一、版本控制Git学习笔记1.1.Git的工作流程 常用的git命令","categories":[{"name":"Git","slug":"Git","permalink":"https://caochenhins.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://caochenhins.github.io/tags/Git/"}]},{"title":"JavaEE基础知识学习-----docker学习笔记","slug":"JavaEE基础知识学习-docker学习笔记","date":"2019-03-21T14:28:43.000Z","updated":"2019-03-21T15:20:52.274Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-docker学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-docker学习笔记/","excerpt":"一、docker学习笔记","text":"一、docker学习笔记","categories":[{"name":"docker","slug":"docker","permalink":"https://caochenhins.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://caochenhins.github.io/tags/docker/"}]},{"title":"JavaEE基础知识学习-----DateUtils学习笔记","slug":"JavaEE基础知识学习-DateUtils学习笔记","date":"2019-03-21T14:27:40.000Z","updated":"2019-03-21T15:20:31.442Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-DateUtils学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-DateUtils学习笔记/","excerpt":"一、DateUtils常用方法1.1.常用的日期判断 isSameDay(final Date date1, final Date date2)：判断两个时间是否是同一天； isSameInstant(final Date date1, final Date date2)：判断两个时间是否为同一毫秒 常用的时间判断示例代码12DateUtils.isSameDay(new Date(),new Date());DateUtils.isSameInstant(new Date(), new Date());","text":"一、DateUtils常用方法1.1.常用的日期判断 isSameDay(final Date date1, final Date date2)：判断两个时间是否是同一天； isSameInstant(final Date date1, final Date date2)：判断两个时间是否为同一毫秒 常用的时间判断示例代码12DateUtils.isSameDay(new Date(),new Date());DateUtils.isSameInstant(new Date(), new Date()); 1.2.日期的基本操作String转DateparseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException 1DateUtils.parseDate(\"20181223 12:34:23\", Locale.TRADITIONAL_CHINESE,\"yyyy-MM-dd HH:mm:ss\"); Date转String可以使用DateFormatUtils.format()方法 1DateFormatUtils.format(new Date(),\"yyyy-MM-dd HH:mm:ss\"); 日期加减addYears(final Date date, final int amount),对日期进行加减年分操作，amount为正数表示加，负数表示减。同理，还有addMonths加减月份，addDays加减日，addWeeks加减周，addHours加减小时，addMinutes加减分钟等方法，具体使用可以参看源码。 1Date date = DateUtils.addYears(new Date(), 3); 日期设置setYears(final Date date, final int amount)，给指定的日期设置指定的年份，同理，setMonths设置月份，setDays设置日，setHours设置小时等等方法。 1Date date1 = DateUtils.setYears(new Date(), 2018); 日期四舍五入round(final Date date, final int field),将指定的日期中指定的部分四舍五入，四舍五入的 常量有Calendar.YEAR和Calendar.MONTH、Calendar.HOUR_OF_DAY、Calendar.DAY_OF_MONTH、Calendar.HOUR、Calendar.MINUTE等； 12/*当前时间：2018-11-25 00:50:57,结果为：2019-01-01 00:00:00*/ Date round = DateUtils.round(new Date(), Calendar.YEAR); 日期截取truncate(final Date date, final int field)和round差距在于不会四舍五入，截取的常量字段有Calendar.YEAR和Calendar.MONTH、Calendar.HOUR_OF_DAY、Calendar.DAY_OF_MONTH、Calendar.HOUR、Calendar.MINUTE等。 12/*当前时间：2018-11-25 00:58:03 ,结果为：2018-01-01 00:00:00*/Date truncate = DateUtils.truncate(new Date(), Calendar.YEAR); 获取指定时间的天数getFragmentInDays(final Date date, final int fragment)获取指定时间的天数，fragment可以是Calendar.YEAR获取年已经过了多少天，同理，Calendar.MONTH月份过去了多少天，当然还有getFragmentInSeconds过去多少秒，getFragmentInMinutes过去多少分钟，getFragmentInHours过去多少小时等。 12/*当前时间：2018-11-25 00:58:03 ,结果为：329*/long fragmentInDays = DateUtils.getFragmentInDays(new Date(), Calendar.YEAR); 比较日历字段是否相等truncatedEquals(final Date date1, final Date date2, final int field)可以比较年，月，日等日历字段。 1boolean b = DateUtils.truncatedEquals(new Date(), new Date(), Calendar.YEAR);","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Collections包学习笔记","slug":"JavaEE基础知识学习-Collections包学习笔记","date":"2019-03-21T14:26:41.000Z","updated":"2019-03-21T15:19:38.687Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Collections包学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Collections包学习笔记/","excerpt":"一、apache.Collections-Map学习笔记在Java Collections API中，我们经常会使用到list、map、Collection、Arrays、Collections等等。今天，我们就来学习总结一下org.apache.commons.collections的常用类。 org.apache.commons.collections– Commons Collections自定义的一组公用的接口和工具类 org.apache.commons.collections.bag – 实现Bag接口的一组类 org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类 org.apache.commons.collections.buffer – 实现Buffer接口的一组类 org.apache.commons.collections.collection – 实现java.util.Collection接口的一组类 org.apache.commons.collections.comparators – 实现java.util.Comparator接口的一组类 org.apache.commons.collections.functors– Commons Collections自定义的一组功能类 org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类 org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类 org.apache.commons.collections.list – 实现java.util.List接口的一组类 org.apache.commons.collections.map – 实现Map系列接口的一组类 org.apache.commons.collections.set – 实现Set系列接口的一组类","text":"一、apache.Collections-Map学习笔记在Java Collections API中，我们经常会使用到list、map、Collection、Arrays、Collections等等。今天，我们就来学习总结一下org.apache.commons.collections的常用类。 org.apache.commons.collections– Commons Collections自定义的一组公用的接口和工具类 org.apache.commons.collections.bag – 实现Bag接口的一组类 org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类 org.apache.commons.collections.buffer – 实现Buffer接口的一组类 org.apache.commons.collections.collection – 实现java.util.Collection接口的一组类 org.apache.commons.collections.comparators – 实现java.util.Comparator接口的一组类 org.apache.commons.collections.functors– Commons Collections自定义的一组功能类 org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类 org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类 org.apache.commons.collections.list – 实现java.util.List接口的一组类 org.apache.commons.collections.map – 实现Map系列接口的一组类 org.apache.commons.collections.set – 实现Set系列接口的一组类 二、collections.map常用类 2.1.双向Map-BidiMap双向Map，可以通过key找到value，也可以通过value找到key，需要注意的是BidiMap当中不光key不能重复，value也不可以重复。 12345BidiMap bidiMap = new DualHashBidiMap();bidiMap.put(\"name\",\"zhangsan\");bidiMap.put(\"age\",34);System.out.println(bidiMap.get(\"name\"));System.out.println(bidiMap.getKey(\"zhangsan\")); 2.2.一对多Map-MultiMap无论是在HashMap中，还是刚说到的BidiMap中，都是简单的一个key对应一个value，MultiMap就是说一个key不在是简单的指向一个对象，而是一组对象，add()和remove()的时候跟普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的往一个key上放数量不定的对象，也就实现了一对多。 MultiMap示例说明当我们需要存放一个小学不同年级和人的时候，我相信大家以前肯定都会想到用年级作key，用List&lt;Student&gt;作value，现在我们使用MultiMap接口中的一个ArrayListMultimap实现类来说明。 导入ArrayListMultimap的Maven坐标12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.0-jre&lt;/version&gt;&lt;/dependency&gt; 编写学生实体类1234public class Student&#123; String name; int age;&#125; 编写测试类123456789101112131415161718192021222324public class MultimapTest &#123; private static final String CLASS_NAME_1 = \"小学五年级\"; private static final String CLASS_NAME_2 = \"小学六年级\"; Multimap&lt;String, Student&gt; multimap = ArrayListMultimap.create(); public void testStudent() &#123; for (int i = 0; i &lt; 5; i++) &#123; Student student = new Student(); student.name = \"小学五年级学生，学号为：5000\" + i; student.age = 6; multimap.put(CLASS_NAME_1, student); &#125; for (int i = 0; i &lt; 5; i++) &#123; Student student = new Student(); student.name = \"小学六年级学生，学号为：6000\" + i; student.age = 7; multimap.put(CLASS_NAME_2, student); &#125; System.out.println(multimap); for (Student stu : multimap.get(CLASS_NAME_1)) &#123; System.out.println(\"小学五年级学生 name:\" + stu.name + \" age:\" + stu.age); &#125; &#125;&#125; 测试代码1234public static void main(String[] args) &#123; MultimapTest multimapTest = new MultimapTest(); multimapTest.testStudent();&#125; 测试结果12345小学五年级学生 name:小学五年级学生，学号为：50000 age:6小学五年级学生 name:小学五年级学生，学号为：50001 age:6小学五年级学生 name:小学五年级学生，学号为：50002 age:6小学五年级学生 name:小学五年级学生，学号为：50003 age:6小学五年级学生 name:小学五年级学生，学号为：50004 age:6 其实，这里我们可以输出multimap，可以看到如下信息： 1234&#123;小学五年级学生=[com.luo.commontsdemo.bean.MultimapTest$Student@4ec6a292, ...], 小学六年级学生=[com.luo.commontsdemo.bean.MultimapTest$Student@5a01ccaa, ...]&#125; 当然，还有很多其他常用方法 12345678//判断键是否存在if(multimap.containsKey(CLASS_NAME_1))&#123; System.out.println(\"键值包含：\"+CLASS_NAME_1);&#125;//”键-单个值映射”的个数System.out.println(multimap.size());//不同键的个数System.out.print(multimap.keySet().size()); 注意：不会有任何键映射到空集合：一个键要么至少到一个值，要么根本就不在Multimap中； Multimap.get(key)总是返回非null、但是可能空的集合 2.3.新集合类型MultisetGuava提供了一个新集合类型Multiset，它可以多次添加相等的元素，且和元素顺序无关。Multiset继承于JDK的Cllection接口，而不是Set接口。 123456Multiset&lt;String&gt; hashMultiset = HashMultiset.create();hashMultiset.add(\"zhangsan\");hashMultiset.add(\"zhangsan\");for (String key : hashMultiset.elementSet()) &#123; System.out.println(key + \"--&gt;\" + hashMultiset.count(key));&#125; Multiset常用方法 add(E element) :向其中添加单个元素 add(E element,int occurrences) : 向其中添加指定个数的元素 count(Object element) : 返回给定参数元素的个数 remove(E element) : 移除一个元素，其count值 会响应减少 remove(E element,int occurrences): 移除相应个数的元素 elementSet() : 将不同的元素放入一个Set中 entrySet(): 类似与Map.entrySet 返回Set&lt;Multiset.Entry&gt;。包含的Entry支持使用getElement()和getCount() setCount(E element ,int count): 设定某一个元素的重复次数 setCount(E element,int oldCount,int newCount): 将符合原有重复个数的元素修改为新的重复次数 retainAll(Collection c) : 保留出现在给定集合参数的所有的元素 removeAll(Collectionc) : 去除出现给给定集合参数的所有的元素 12345//向集合中添加若干个元素wordMultiset.add(\"and\", 10);for (String key : wordMultiset.elementSet()) &#123; System.out.println(key + \"--&gt;\" + wordMultiset.count(key));&#125; 1234wordMultiset.remove(\"that\");for (String key : wordMultiset.elementSet()) &#123; System.out.println(key + \"--&gt;\" + wordMultiset.count(key));&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----ArrayUtils学习笔记","slug":"JavaEE基础知识学习-ArrayUtils学习笔记","date":"2019-03-21T14:26:15.000Z","updated":"2019-03-21T15:20:00.297Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-ArrayUtils学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-ArrayUtils学习笔记/","excerpt":"一、ArrayUtils方法解读1.1.数组的常用判断方法 isEmpty(final Object[] array)：判断数组是否为空； isNotEmpty(final float[] array)：判断数组是否不为空； isSameLength(final char[] array1, final char[] array2)：判断两个数组的长度是否相同，要同类型； isSameType(final Object array1, final Object array2)：判断两个数组的类型是否相同； isSorted(final int[] array)：判断数组是否以自然顺序排序；","text":"一、ArrayUtils方法解读1.1.数组的常用判断方法 isEmpty(final Object[] array)：判断数组是否为空； isNotEmpty(final float[] array)：判断数组是否不为空； isSameLength(final char[] array1, final char[] array2)：判断两个数组的长度是否相同，要同类型； isSameType(final Object array1, final Object array2)：判断两个数组的类型是否相同； isSorted(final int[] array)：判断数组是否以自然顺序排序； 数组的常用判断示例代码 12345678String[] arr = &#123;\"Hello\",\"Word\"&#125;;String[] arr2 = &#123;\"34\",\"35\",\"36\"&#125;;int[] intarr = &#123;12,13,14&#125;;ArrayUtils.isEmpty(arr); = falseArrayUtils.isNotEmpty(arr); = trueArrayUtils.isSameLength(arr2,arr); = falseArrayUtils.isSameType(intarr,arr); = falseArrayUtils.isSorted(intarr); = true 1.2.数组的基本操作 add(final T[] array, final T element)：该方法向指定的数组中添加一个元素； remove(final T[] array, final int index)：移除数组红指定索引位置的元素； addAll(final T[] array1, final T... array2)：合并两个数组； removeAll(final char[] array, final int... indices)：移除数组红指定的多个索引位置的元素； removeElement(final char[] array, final char element)：从数组中删除第一次出现的指定元素； removeAllOccurences(final char[] array, final char element)：从数组中移除指定的元素； removeElements(final char[] array, final char... values)：从数组中移除指定数量的元素，返回新数组； getLength(final Object array)：获取数组的长度； contains(final Object[] array, final Object objectToFind)：判断数组中是否包含某一个元素； indexOf(final Object[] array, final Object objectToFind)：查找数组中是否存在某元素，返回索引位置； lastIndexOf(final Object[] array, final Object objectToFind)：从尾部开始查找指定元素； insert(final int index, final T[] array, final T... values)：向数组指定索引位置添加元素； 数组的基本操作示例代码123456789101112131415ArrayUtils.add(arr, \"你好\");ArrayUtils.remove(arr,1);ArrayUtils.removeAll([2, 6, 3], 0, 2) = [6]ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']ArrayUtils.removeAllOccurences(arr,\"Hello\");ArrayUtils.removeElements(arr,1,2,3);ArrayUtils.addAll([], []) = []ArrayUtils.addAll([null], [null]) = [null, null]ArrayUtils.addAll(arr,arr2);ArrayUtils.getLength(arr);ArrayUtils.contains(arr,\"word\");ArrayUtils.indexOf(arr,\"word\");ArrayUtils.lastIndexOf(arr, \"word\");ArrayUtils.insert(0, arr, \"谢谢你\"); 说明：数组的很多操作都是返回新的数组，不会对原有数组进行改变； 1.3.数组的转换操作 nullToEmpty(final String[] array)：将null数组转换为对应类型的空数组； toMap(final Object[] array)：将二维数组转换为map，一维数组转换抛出异常； reverse(final char[] array)：反转数组，不返回新数组,可以指定反转的区域； subarray(final char[] array, int startIndexInclusive, int endIndexExclusive)：数组的截取；包头不包尾； swap(final char[] array, final int offset1, final int offset2)：交换数组中指定位置的两个元素； toObject(final int[] array)：将原始数据类型的数组转换为对象类型的数组； toPrimitive(final Integer[] array)：将对象数据类型的数组转换为原始数据类型的数组 toStringArray(final Object[] array)：将Object类型的数组转换为String类型的数组； 数组的转换操作示例代码12345678910111213ArrayUtils.nullToEmpty((String[])null);String[][] maparr = &#123;&#123;\"name\",\"zhangsan\"&#125;,&#123;\"age\",\"23\"&#125;,&#123;\"money\",\"6700\"&#125;&#125;;Map&lt;Object, Object&gt; objectObjectMap = ArrayUtils.toMap(maparr);String[] rearr = &#123;\"1\", \"2\", \"3\", \"4\"&#125;; ArrayUtils.reverse(rearr, 0, 3); = [3, 2, 1, 4]String[] subarray = ArrayUtils.subarray(rearr, 1, 2);ArrayUtils.swap([1, 2, 3], 1, 0) = [2, 1, 3]ArrayUtils.swap([1, 2, 3], 0, 5) = [1, 2, 3]ArrayUtils.swap([1, 2, 3], -1, 1) = [2, 1, 3]int[] intarr = &#123;12,11,14&#125;;Integer[] integers = ArrayUtils.toObject(intarr);int[] ints = ArrayUtils.toPrimitive(integers);String[] strings = ArrayUtils.toStringArray(integers); 简单总结上面所提到的方法都是平时开发时候经常使用的，可以大大的简化我们对数组的基本操作，需要注意的是方法是否返回新数组，是否是对原有数组进行操作。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"JavaEE基础知识学习-----Apache Commons学习笔记","slug":"JavaEE基础知识学习-Apache-Commons学习笔记","date":"2019-03-21T14:25:49.000Z","updated":"2019-03-21T15:20:11.163Z","comments":true,"path":"2019/03/21/JavaEE基础知识学习-Apache-Commons学习笔记/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/JavaEE基础知识学习-Apache-Commons学习笔记/","excerpt":"一、Apache Commons常用类库1.1.简介Apache Commons包含了很多开源的工具类，用于减少代码的的重复性，其中共包含类以下42个包，如下所示：","text":"一、Apache Commons常用类库1.1.简介Apache Commons包含了很多开源的工具类，用于减少代码的的重复性，其中共包含类以下42个包，如下所示：| 包名 | 说明 | 常用类 || :————– | :——————— | ————————————— || BCEL | | || BeanUtils | | || BSF | | || Chain | | || CLI | | || Codec | | || Collections | | CollectionUtils || Compress | | || Configuration | | || Crypto | | || CSV | | || Daemon | | || DBCP | | || DbUtils | | || Digester | | || Email | | || Exec | | || FileUpload | | || Functor | | || Geometry | | || Imaging | | || IO | 是一个 I/O 工具集合 | FilenameUtils、IOUtils、FileUtils || JCI | | || JCS | | || Jelly | | || Jexl | | || JXPath | | || Lang | 提供了很多通用的工具类 | StringUtils、ArrayUtils、 || Logging | | || Math | | || Net | | || Numbers | | || OGNL | | || Pool | | || Proxy | | || RDF | | || RNG | | || SCXML | | || Validator | | || VFS | | || Weaver | | | 二、Commons lang包下的常用类2.1.StringUtilsl类字符串判空","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"Java8新特性学习总结","slug":"Java8新特性学习总结","date":"2019-03-21T14:24:42.000Z","updated":"2019-03-21T15:18:08.187Z","comments":true,"path":"2019/03/21/Java8新特性学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/Java8新特性学习总结/","excerpt":"lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 语法格式1.无参数，无返回值（）-&gt; System.out.print(“Hello Word”);","text":"lambda表达式在Java8中引入了一个新的操作符“-&gt;”,该操作符称为箭头操作符或Lambda操作符。左侧：Lambda表示式的参数列表右侧：Lambda表达式中所要执行的功能 语法格式1.无参数，无返回值（）-&gt; System.out.print(“Hello Word”); 12345678910111213@Testpublic void test1()&#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.print(\"Hello Word\"); &#125; &#125;; r.run(); System.out.print(\"===============================\"); Runnable r1 = () -&gt; System.out.print(\"Hello Word\"); r1.run();&#125; 2.一个参数，无返回值（x）-&gt; System.out.print(x);12345@Testpublic void test2()&#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept(\"Hello Word\");&#125; 如果只有一个参数，无返回值可以省略小括号不写。 3.两个参数，有返回值，并且有多条执行语句123456789@Testpublic void test3()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt;&#123; System.out.println(\"函数式接口\"); return Integer.compare(x,y); &#125;; int max = com.compare(4,5); System.out.println(max);&#125; 4.如果只有一条返回语句1234@Testpublic void test4()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);&#125; 注意说明lambda表达式中的参数类型可以省略不写，JVM可以根据上下文推断出类型 Lambda表达式需要函数式接口的支持。 函数式接口接口中只有一个抽象方法的接口，就叫函数式接口。可以使用注解@FunctionalInterface检查是否为函数式接口。 1234@FunctionalInterfacepublic interface MyPredicat &lt;T&gt;&#123; public boolean test(T t);&#125; 函数式接口示例1.定义一个函数式接口1234@FunctionalInterfacepublic interface MyFun &#123; public Integer getValue(Integer num);&#125; 2.定义一个方法，方法的参数为函数式接口123public Integer operation(Integer num,MyFun mf)&#123; return mf.getValue(num); &#125; 3.使用Lambda表达式12345@Testpublic void test5()&#123; Integer num = operation(100,(x)-&gt; x*x); System.out.println(num);&#125; Lambda表达式左侧是函数式接口的参数，右侧是函数式接口的实现。 Lambda练习练习一将集合中的员工排序，按照年龄从小到大排序，如果年龄相同就按照名称排序 123456789101112131415161718192021public class TestLambda &#123; List&lt;Employee&gt; emps = Arrays.asList( new Employee(\"张三\",13,9999.99), new Employee(\"李四\",67,444.44), new Employee(\"王五\",45,55.55), new Employee(\"赵六\",45,6666.66) ); @Test public void test1()&#123; Collections.sort(emps,(e1,e2) -&gt; &#123; if(e1.getAge() == e2.getAge())&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return Integer.compare(e1.getAge(),e2.getAge()); &#125; &#125;); for(Employee emp:emps)&#123; System.out.println(emp); &#125; &#125;&#125; 练习二对字符串进行处理 1.申明一个函数式接口，用于处理字符串1234@FunctionalInterfacepublic interface MyFunction &#123; public String getValue(String str);&#125; 2.申明一个处理字符串的方法，返回处理后的结果123public String strHandle(String str,MyFunction mf)&#123; return mf.getValue(str);&#125; 3.调用处理方法，使用Lambda表达式实现字符串的不同处理123456789101112@Testpublic void test2()&#123; //将传入的字符串做去除空格处理 String trimStr = strHandle(\" \\t\\t\\t\\tHello Word\",(str) -&gt; str.trim()); System.out.println(trimStr); //将传入的字符串做大写转换处理 String uper = strHandle(\"abce\",(str) -&gt; str.toUpperCase()); System.out.println(uper); //将传入的字符串做截取处理 String subStr = strHandle(\"我要好好学习，成为一个大神\",(str) -&gt; str.substring(1,5)); System.out.println(subStr);&#125; 练习三计算两个long型参数做处理 1.声明一个函数式接口1234@FunctionalInterfacepublic interface MyFunction2 &lt;T,R&gt;&#123; public R getValue(T t1,T t2);&#125; 2.定义处理方法123public void operator(Long l1,Long l2,MyFunction2&lt;Long,Long&gt; mf)&#123; System.out.println(mf.getValue(l1,l2));&#125; 3.使用Lambda表达式12345@Testpublic void test4()&#123; operator(100L,200L,(x,y) -&gt; x+y); operator(100L,200L,(x,y) -&gt; x*y);&#125; lambda表达式总结从上述代码中，我们可以看出Lambda表达式的好处，但是我们会发现，每次使用都会新建一个函数式接口，增加了很多麻烦，所以，Java8给我们增加了很多函数式接口， 四大核心函数接口 Consumer消费型接口： 参数类型 T 返回类型 void 对类型T的对象应用操作 Supplier供给型接口： 参数类型 无 返回类型 T 返回类型为T的对象 Function&lt;T,R&gt;函数型接口： 参数类型 T 返回类型 R 对了类型为T的对象应用操作，并返回结果 Predicate断言型接口： 参数类型 T 返回类型 boolean 确定类型为T的对象是否满足某约束，并返回布尔值。 Consumer示例1234567@Testpublic void test1()&#123; happy(10000,(m) -&gt; System.out.println(\"购买笔记本电脑，每次消费\"+m+\"元\"));&#125;public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; Supplier示例123456789101112131415@Testpublic void test2()&#123; List&lt;Integer&gt; list = getNumList(10, () -&gt; (int)(Math.random()*100)); for(Integer num: list)&#123; System.out.println(num); &#125;&#125;public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;num ; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; 上述使用Lambda表达式就是产生10个100以内的随机数。 Function示例12345678@Testpublic void test3()&#123; String upperStr = strHandle(\"abce\",(str) -&gt; str.toUpperCase()); System.out.println(upperStr);&#125;public String strHandle(String str, Function&lt;String,String&gt; fun)&#123; return fun.apply(str);//对str进行处理，具体处理方式调用的时候使用Lambda表达式指定&#125; Predicate示例将满足条件的字符串添加到集合中 123456789101112131415161718@Testpublic void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"Hello\",\"www.baidu.com\",\"zhangsan\",\"lisi\"); List&lt;String&gt; strList = filterStr(list,(s) -&gt; s.length() &gt; 4); for(String str: strList)&#123; System.out.println(str); &#125;&#125;public List&lt;String&gt; filterStr(List&lt;String&gt; list , Predicate&lt;String&gt; per)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str: list) &#123; if(per.test(str))&#123;//对str进行过滤操作，具体操作调用的时候才执行 strList.add(str); &#125; &#125; return strList;&#125; 函数接口总结 Consumer消费型是传入一个参数，进行处理 Supplier供给型是得到一些结果 Function函数型是传入一个参数，处理后返回一个结果 Predicate断言型就是做一些判断操作 有无参数和返回值是指Predicate per等调用的方法需不需要参数和有无返回值，例如：per.test(str)、fun.apply(str)、sup.get()等。 方法引用当要传递给Lambda体的操作，已经有了实现的方法，可以使用方法引用.(实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致)。方法引用：使用操作符“::”将方法名和对象或类的名字分割开，例如： 对象::实例方法 类::静态方法 类::实例方法 对象::实例方法示例1234567@Testpublic void test1()&#123; //注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 Consumer&lt;String&gt; com = (x) -&gt; System.out.println(x); PrintStream ps = System.out; Consumer&lt;String&gt; con = ps::println;&#125; 例如打印一个字符串： 12345@Testpublic void test1()&#123; Consumer&lt;String&gt; con = System.out::println; con.accept(\"Hello Word\");&#125; 注意：con.accept()中的accept的参数类型和返回值和println参数类型和返回值一致 类::静态方法方法引用的实质就是使用更简单的方式代替Lambda表达式。下述代码就是类::静态方法的一个实例。 123456@Testpublic void test2()&#123; Comparator&lt;Integer&gt; con = (x,y) -&gt; Integer.compare(x,y); //上述代码中Lambda表达体中的compare方法已经被实现，可以简写为 Comparator&lt;Integer&gt; con1 = Integer::compare;&#125; 类::实例方法如下123456@Testpublic void test3()&#123; BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); //上述代码简写为 BiPredicate&lt;String,String&gt; bp2 = String::equals;&#125; 构造器引用12345678@Testpublic void test4()&#123; Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); //构造器引用 Supplier&lt;Employee&gt; sup2 = Employee::new; Employee employee = sup.get(); System.out.println(employee.getName());&#125; 其中构造器方法调用哪一个构造器取决与接口Supplier中的方法参数，Supplier就是调用的无参构造器，例如Function函数接口就是传入一个参数，并返回一个结果。如下 12345678@Testpublic void test5()&#123; Function&lt;String,Employee&gt; fun = (x) -&gt; new Employee(x); //构造器引用 Function&lt;String,Employee&gt; fun2 = Employee::new; Employee emp = fun2.apply(\"王五\"); System.out.println(emp);&#125; Function&lt;String,Employee&gt;中的String是传入参数类型，Employee是返回结果类型。如果我们想传入两个参数，并返回一个结果，就必须要在Employee中创建两个含两个参数的构造器，如下 123456@Testpublic void test6()&#123; BiFunction&lt;String,Integer,Employee&gt; fun = Employee::new; Employee emp = fun.apply(\"赵六\",123); System.out.println(emp);&#125; 注意：Employee中构造器参数列表和接口中的方法fun.apply(“赵六”,123);参数列表保持一致。 数组引用数组引用格式type[]::new 123456@Testpublic void test7()&#123; Function&lt;Integer,String[]&gt; fun = (x) -&gt; new String[x]; String[] str= fun.apply(10); System.out.println(str.length);&#125; 上述代码就是使用Lambda表达式传入一个数组大小，从而创建一个指定大小和类型的数组。使用数组引用为： 123Function&lt;Integer,String[]&gt; fun2 = String[]::new;String[] str2 = fun2.apply(10);System.out.println(str2.length); StreamAPIStream简介Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行测操作，可以执行非常复杂的查找，过滤和映射数据的操作，使用Stream API对集合数据进行操作就类似于使用SQL执行的数据库查询查询，Stream API提供了一种高效且易于使用的处理数据的方式。流（Stream）是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列，“集合讲的是数据，流讲的是计算”，需要注意的是以下三点 Stream自己不会存储元素 Stream不会改变源对象，相会，他们会返回一个持有结果的新的Stream Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。 Stream使用方法 创建Stream：一个数据源（集合、数组）获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作：一个终止操作，执行中间操作链，并产生结果。 创建Stream的方法 通过Collection系列提供的stream()或parallelStream()，如下： 通过Arrays中的静态方法stream()方法获取流 通过Stream类中的静态方法of() 创建无限流 创建Stream的方法示例12345678910111213141516171819202122232425@Testpublic void test1()&#123; // 1.通过Collection系列提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); // 2.通过Arrays中的静态方法stream()方法获取流 Employee[] emps = new Employee[10]; Stream&lt;Employee&gt; stream1 = Arrays.stream(emps); // 3.通过Stream类中的静态方法of() Stream&lt;String&gt; stream2 = Stream.of(\"AA\",\"BB\",\"CC\"); // 4.创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0,(x) -&gt; x+2); //只要前10个（中间操作） stream3.limit(10).forEach(System.out::println); //打印了所有的中间流操作 //stream3.forEach(System.out::println); //4.2生成 Stream.generate(() -&gt; Math.random()) .limit(10) .forEach(System.out::println);&#125; 中间操作 filter—-接受lambda,从流中排除某一些元素 limit—-截断流，使其元素不超过给定的数量 skip(n)—-跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流 distinct—-筛流，通过流生成元素的hashcode()和equals()去除重复元素 filter示例1234567891011@Testpublic void test1()&#123; //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; &#123; System.out.println(\"中间操作\"); return e.getAge() &gt; 16; &#125;); //终止操作 stream.forEach(System.out::println);&#125; 惰性求值和内部迭代 如果没有终止操作，是不会打印中间操作的，这就是流只有需要结果的时候才会被调用，这就是惰性求值。 上述打印是Stream自己给我们迭代输出的，这个就是内部迭代。 筛选和切片示例如下1234567891011@Testpublic void test1()&#123; //中间操作 Stream&lt;Employee&gt; stream = employees.stream() .filter((e) -&gt; e.getAge() &gt; 15) .limit(4) .skip(1) .distinct(); //终止操作 stream.forEach(System.out::println);&#125; 说明：由于distinct是根据hashcode()和equals()去重，所以Employee中要重写equals和hashCode方法。 映射 map(Function f) 接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 map示例1234567891011@Testpublic void test2()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println);System.out.println(\"================\"); employees.stream() .map(Employee::getName) .forEach(System.out::println);&#125; flatMap示例123456789101112131415@Testpublic void test3()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); Stream&lt;Character&gt; sm = list.stream() .flatMap(TestMiddle::filterCharacter); sm.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(Character ch: str.toCharArray())&#123; list.add(ch); &#125; return list.stream();&#125; 排序sorted()-自然排序（comparable）12345678@Test public void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"ccc\",\"aaa\",\"bbb\",\"eee\"); list.stream() .sorted() .forEach(System.out::println); &#125;&#125; sorted(Comparator com)-定制排序（Comparator）1234567891011@Testpublic void test5()&#123; employees.stream() .sorted((e1,e2) -&gt; &#123; if(e1.getAge().equals(e2.getAge()))&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e2.getAge().compareTo(e2.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作终止操作会从流的流水线生成结果，该结果可以是任何不是流的值，例如：List、Integer、void。 查找和匹配 allMatch(Predicate p) 检查是否匹配所有的元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有的元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素个数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestStreamAPI &#123; List&lt;Employee&gt; employees = Arrays.asList( new Employee(\"张三\",16,9999.99, Employee.Status.FREE), new Employee(\"李四\",18,8888.99, Employee.Status.VOCATION), new Employee(\"王五\",20,7777.99, Employee.Status.BUSY), new Employee(\"赵六\",22,6666.99, Employee.Status.FREE), new Employee(\"田七\",24,5555.99, Employee.Status.BUSY), new Employee(\"小八\",26,4444.99, Employee.Status.VOCATION), new Employee(\"陈九\",28,3333.99, Employee.Status.VOCATION), new Employee(\"王五\",32,9999.99, Employee.Status.BUSY), new Employee(\"王五\",34,9999.99, Employee.Status.FREE), new Employee(\"王五\",36,9999.99, Employee.Status.BUSY) ); @Test public void test1()&#123; //检查是否所有的状态为BUSY状态 Boolean b1 = employees.stream() .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否至少匹配一个元素 Boolean b2 = employees.stream() .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //检查是否没有匹配元素 Boolean b3 = employees.stream() .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); //先按照工资排序，再去除第一个元素放在Option容器中 Optional&lt;Employee&gt; op = employees.stream() .sorted((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())) .findFirst(); System.out.println(op.get()); //findAny返回当前流中的任意元素，先过滤再返回一个， //mployees.stream()实现的是串行流，每次返回的值一定的。 //employees.parallelStream()实现的是并行流 ，返回的就是满足条件的随机结果。 Optional&lt;Employee&gt; op2 = employees.parallelStream() .filter((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)) .findAny(); System.out.println(op2.get()); //返回流中元素个数 Long count = employees.stream() .count(); //返回流中最大值 Optional&lt;Employee&gt; op1 = employees.stream() .max((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay())); System.out.println(op1.get()); //返回流中最低工资 Optional&lt;Double&gt; op3 = employees.stream() .map(Employee::getSalay) .min(Double::compare); System.out.println(op3.get()); &#125;&#125; 归约reduce(T iden,BinaryOperator b)可以将流中元素反复结合起来，得到一个值，返回T,示例如下： 123456789101112@Testpublic void test2()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0,(x,y) -&gt; x+y); System.out.println(sum); //计算工资的总和 Optional&lt;Double&gt; op = employees.stream() .map(Employee::getSalay) .reduce(Double::sum); System.out.println(op.get());&#125; 上述代码中使用map得到所有的工资，再有reduce将所有的工资累加，map和reduce配合使用情况比较多。 收集collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。Colletor接口中的方法实现决定了如何对流执行收集操作（如收集到List，Set,Map）,但是Collectors实用类提供了很多静态的方法，可以方便的创建常用收集器实例，具体方法与实例如下： toList 返回List 将流中元素搜集到List toSet 返回Set 将流中元素手机到Set toCollection 返回Collection 把流中元素收集到创建的集合中 counting 返回Long 计算流中元素的个数 summinglnt 返回Integer 对流中元素的整数属性求和 averaginglnt 返回Double 计算流中元素Integer属性的平均值 summarizinglnt 返回IntSummaryStatistics 计算流中Integer属性的统计值，如平均值。 joining 返回String 连接流中每一个字符串 maxBy 返回Optional 根据比较器选择最大值 minBy 返回Optional 根据比较器选择最小值 reducing 归约产生的类型 collectionAndThen 转换函数返回的类型 实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Testpublic void test3()&#123; //将名字添加到list中 List&lt;String&gt; list = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); //将名字添加到Set中 Set&lt;String&gt; set = employees.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); //将名字添加到特定的数据结构中 HashSet&lt;String&gt; hashSet = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); //总数 Long count = employees.stream() .collect(Collectors.counting()); //平均数 Double avg = employees.stream() .collect(Collectors.averagingDouble(Employee::getSalay)); //总和 Double sum = employees.stream() .collect(Collectors.summingDouble(Employee::getSalay)); //最大值，返回工资最大的员工信息 Optional&lt;Employee&gt; max = employees.stream() .collect(Collectors.maxBy((e1,e2) -&gt; Double.compare(e1.getSalay(),e2.getSalay()))); //最小值，返回最小工资 Optional&lt;Double&gt; min = employees.stream() .map(Employee::getSalay) .collect(Collectors.minBy(Double::compare)); //按照状态分组 Map&lt;Employee.Status,List&lt;Employee&gt;&gt; map = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus)); map.get(Employee.Status.BUSY); //多级分组 Map&lt;Employee.Status,Map&lt;String,List&lt;Employee&gt;&gt;&gt; map1 = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus,Collectors.groupingBy((e) -&gt;&#123; if(((Employee)e).getAge() &lt;= 18)&#123; return \"少年\"; &#125;else if(((Employee)e).getAge() &lt;= 26)&#123; return \"中年\"; &#125;else&#123; return \"老年\"; &#125; &#125;))); System.out.println(map1); //分区。满足条件一个区，不满足条件的一个区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map2 = employees.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalay() &gt;5000)); System.out.println(map2); //其他的一种获取方式 DoubleSummaryStatistics dss = employees.stream() .collect(Collectors.summarizingDouble(Employee::getSalay)); System.out.println(dss.getSum()); System.out.println(dss.getAverage()); System.out.println(dss.getMax()); //连接字符串 String str = employees.stream() .map(Employee::getName) .collect(Collectors.joining(\",\",\"====\",\"===\"));&#125; StreamAPI练习1.给定一个数字列表，返回一个由每一个数的平方构成的列表。12345678@Testpublic void test()&#123; Integer[] nums = new Integer[]&#123;1,2,3,4,5&#125;; Arrays.stream(nums) .map((x) -&gt; x*x) .forEach(System.out::println);&#125; 2.使用map和reduce方法数一数流中有多少个Employee1234567@Testpublic void test1()&#123; Optional&lt;Integer&gt; count = employees.stream() .map((e) -&gt; 1) .reduce(Integer::sum); System.out.println(count.get());&#125; 交易员类1234567891011121314151617181920212223242526272829303132333435public class Trader &#123; private String name; private String city; public Trader() &#123; &#125; public Trader(String name, String city) &#123; this.name = name; this.city = city; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; @Override public String toString() &#123; return \"Trader [name=\" + name + \", city=\" + city + \"]\"; &#125;&#125; 交易类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Transaction &#123; private Trader trader; private int year; private int value; public Transaction() &#123; &#125; public Transaction(Trader trader, int year, int value) &#123; this.trader = trader; this.year = year; this.value = value; &#125; public Trader getTrader() &#123; return trader; &#125; public void setTrader(Trader trader) &#123; this.trader = trader; &#125; public int getYear() &#123; return year; &#125; public void setYear(int year) &#123; this.year = year; &#125; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Transaction [trader=\" + trader + \", year=\" + year + \", value=\" + value + \"]\"; &#125;&#125; 练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class TestTransaction &#123; List&lt;Transaction&gt; transactions = null; @Before public void before()&#123; Trader raoul = new Trader(\"Raoul\", \"Cambridge\"); Trader mario = new Trader(\"Mario\", \"Milan\"); Trader alan = new Trader(\"Alan\", \"Cambridge\"); Trader brian = new Trader(\"Brian\", \"Cambridge\"); transactions = Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); &#125; //1. 找出2011年发生的所有交易， 并按交易额排序（从低到高） @Test public void test1()&#123; transactions.stream() .filter((t) -&gt; t.getYear() == 2011)//过滤2011年的交易 .sorted((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())) .forEach(System.out::println); &#125; //2. 交易员都在哪些不同的城市工作过？ @Test public void test2()&#123; transactions.stream() .map((t) -&gt; t.getTrader().getCity()) .distinct() .forEach(System.out::println); &#125; //3. 查找所有来自剑桥的交易员，并按姓名排序 @Test public void test3()&#123; new ArrayList&lt;Integer&gt;(); transactions.stream() .filter((t) -&gt; t.getTrader().getCity().equals(\"Cambridge\")) .map(Transaction::getTrader) .sorted((t1,t2) -&gt; t1.getName().compareTo(t2.getName())) .distinct() .forEach(System.out::println); &#125; //4. 返回所有交易员的姓名字符串，按字母顺序排序 @Test public void test4()&#123; transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .forEach(System.out::println); System.out.println(\"====================================\"); String str = transactions.stream() .map((t) -&gt; t.getTrader().getName()) .sorted() .reduce(\"\",String::concat); System.out.println(str); &#125; //5. 有没有交易员是在米兰工作的？ @Test public void test5()&#123; Boolean b1 = transactions.stream() .anyMatch((t) -&gt; t.getTrader().getCity().equals(\"Milan\")); System.out.println(b1); &#125; //6. 打印生活在剑桥的交易员的所有交易额 @Test public void test6()&#123; Optional&lt;Integer&gt; sum = transactions.stream() .filter((e) -&gt; e.getTrader().getCity().equals(\"Cambridge\")) .map(Transaction::getValue) .reduce(Integer::sum); System.out.println(sum.get()); &#125; //7. 所有交易中，最高的交易额是多少 @Test public void test7()&#123; Optional&lt;Integer&gt; max = transactions.stream() .map((t) -&gt; t.getValue()) .max(Integer::compare); System.out.println(max); &#125; //8. 找到交易额最小的交易 @Test public void test8()&#123; Optional&lt;Transaction&gt; op = transactions.stream() .min((t1,t2) -&gt; Integer.compare(t1.getValue(),t2.getValue())); System.out.println(op.get()); &#125;&#125; LocalDateTimeLocalDateTime是一个不可变的日期时间对象，代表日期时间，通常被视为年 - 月 - 日 - 时 - 分 - 秒。 方法摘要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687Temporal adjustInto(Temporal temporal) 调整指定的时间对象与此对象具有相同的日期和时间。 OffsetDateTime atOffset(ZoneOffset offset) 将此日期时间与偏移量相结合以创建 OffsetDateTime 。 ZonedDateTime atZone(ZoneId zone) 将此日期时间与时区相结合以创建 ZonedDateTime 。 int compareTo(ChronoLocalDateTime&lt;?&gt; other) 将此日期时间与其他日期时间进行比较。 boolean equals(Object obj) 检查这个日期时间是否等于另一个日期时间。 String format(DateTimeFormatter formatter) 使用指定的格式化程序格式化此日期时间。 static LocalDateTime from(TemporalAccessor temporal) 从时间对象获取一个 LocalDateTime的实例。 int get(TemporalField field) 从此日期时间获取指定字段的值为 int 。 int getDayOfMonth() 获取月份字段。 DayOfWeek getDayOfWeek() 获取星期几字段，这是一个枚举 DayOfWeek 。 int getDayOfYear() 获得日期字段。 int getHour() 获取时间字段。 long getLong(TemporalField field) 从此日期时间获取指定字段的值为 long 。 int getMinute() 获取小时字段。 Month getMonth() 使用 Month枚举获取月份字段。 int getMonthValue() 将月份字段从1到12。 int getNano() 获得纳秒第二场。 int getSecond() 获得第二分钟的字段。 int getYear() 获取年份字段。 int hashCode() 这个日期时间的哈希码。 boolean isAfter(ChronoLocalDateTime&lt;?&gt; other) 检查这个日期时间是否在指定的日期之后。 boolean isBefore(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否在指定的日期时间之前。 boolean isEqual(ChronoLocalDateTime&lt;?&gt; other) 检查此日期时间是否等于指定的日期时间。 boolean isSupported(TemporalField field) 检查指定的字段是否受支持。 boolean isSupported(TemporalUnit unit) 检查指定的单位是否受支持。 LocalDateTime minus(long amountToSubtract, TemporalUnit unit) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minus(TemporalAmount amountToSubtract) 返回此日期时间的副本，并减去指定的金额。 LocalDateTime minusDays(long days) 返回此 LocalDateTime的副本，其中指定的时间间隔以天为单位。 LocalDateTime minusHours(long hours) 以指定的时间段返回此 LocalDateTime的副本，以减少的小时数。 LocalDateTime minusMinutes(long minutes) 返回此 LocalDateTime的副本，以指定的时间间隔减去。 LocalDateTime minusMonths(long months) 返回此 LocalDateTime的副本，指定的时间以月为单位减去。 LocalDateTime minusNanos(long nanos) 返回这个 LocalDateTime的副本，以指定的时间减去纳秒。 LocalDateTime minusSeconds(long seconds) 返回此 LocalDateTime的副本，其中指定的时间间隔以秒为单位。 LocalDateTime minusWeeks(long weeks) 返回此 LocalDateTime的副本，其中指定的周期以周为单位减去。 LocalDateTime minusYears(long years) 返回此 LocalDateTime的副本，并以减去的年份为单位。 static LocalDateTime now() 从默认时区的系统时钟获取当前的日期时间。 static LocalDateTime now(Clock clock) 从指定的时钟获取当前的日期时间。 static LocalDateTime now(ZoneId zone) 从指定时区的系统时钟获取当前的日期时间。static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得LocalDateTime的实例，将第二和纳秒设置为零。static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) 获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) 从年，月，日，小时和分钟获得 LocalDateTime的实例，将第二和纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) 从年，月，日，小时，分钟和秒获得 LocalDateTime的实例，将纳秒设置为零。 static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)获取的实例 LocalDateTime从年，月，日，小时，分钟，秒和纳秒。 static LocalDateTime of(LocalDate date, LocalTime time) 从日期和时间获取 LocalDateTime一个实例。 static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) 使用从1970-01-01T00：00：00Z的时代开始的秒数获得一个 LocalDateTime的实例。 static LocalDateTime ofInstant(Instant instant, ZoneId zone) 从 Instant和区域ID获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text) 从一个文本字符串（如 2007-12-03T10:15:30获取一个 LocalDateTime的实例。 static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) 使用特定的格式化 LocalDateTime从文本字符串获取 LocalDateTime的实例。 LocalDateTime plus(long amountToAdd, TemporalUnit unit) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plus(TemporalAmount amountToAdd) 返回此日期时间的副本，并添加指定的金额。 LocalDateTime plusDays(long days) 返回此 LocalDateTime的副本，并以指定的时间段添加天数。 LocalDateTime plusHours(long hours) 以指定的时间（以小时为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMinutes(long minutes) 以指定的时间（以分钟为单位）返回此 LocalDateTime的副本。 LocalDateTime plusMonths(long months) 返回这个 LocalDateTime的副本，其中指定的时间段以月为单位。 LocalDateTime plusNanos(long nanos) 返回这个 LocalDateTime的副本，其指定时间以纳秒为单位。 LocalDateTime plusSeconds(long seconds) 以指定的时间段返回此 LocalDateTime的副本，以秒为单位。 LocalDateTime plusWeeks(long weeks) 返回这个 LocalDateTime的副本，并以指定的周期添加周数。 LocalDateTime plusYears(long years) 返回这个 LocalDateTime的副本，其中指定的时间段以添加的年数表示。 &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) 使用指定的查询查询此日期时间。 ValueRange range(TemporalField field) 获取指定字段的有效值的范围。 LocalDate toLocalDate() 获得这个日期时间的 LocalDate一部分。 LocalTime toLocalTime() 获得这个日期时间的 LocalTime一部分。 String toString() 将此日期时间输出为 String ，例如 2007-12-03T10:15:30 。 LocalDateTime truncatedTo(TemporalUnit unit) 返回此 LocalDateTime的副本， LocalDateTime时间。 long until(Temporal endExclusive, TemporalUnit unit) 根据指定的单位计算到另一个日期时间的时间量。 LocalDateTime with(TemporalAdjuster adjuster) 返回此日期时间的调整副本。 LocalDateTime with(TemporalField field, long newValue) 返回此日期时间的副本，并将指定的字段设置为新值。 LocalDateTime withDayOfMonth(int dayOfMonth) 返回此 LocalDateTime的副本。 LocalDateTime withDayOfYear(int dayOfYear) 返回这个 LocalDateTime的副本，并更改日期。 LocalDateTime withHour(int hour) 返回此日期值更改的 LocalDateTime的副本。 LocalDateTime withMinute(int minute) 返回这个 LocalDateTime的副本，小时值更改。 LocalDateTime withMonth(int month) 返回此年份更改的 LocalDateTime的副本。 LocalDateTime withNano(int nanoOfSecond) 返回这个 LocalDateTime的副本，纳秒变化值。 LocalDateTime withSecond(int second) 返回这个 LocalDateTime的副本，其中 LocalDateTime了第二分钟的值。 LocalDateTime withYear(int year) 返回这个 LocalDateTime的副本，年份被更改。","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/tags/Java/"}]},{"title":"CSS3学习总结","slug":"CSS3学习总结","date":"2019-03-21T14:23:42.000Z","updated":"2019-03-21T15:17:52.194Z","comments":true,"path":"2019/03/21/CSS3学习总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/CSS3学习总结/","excerpt":"CSS3学习笔记前言 css的全称是什么？——casccading style sheets 样式表的组成？——选择器+声明块 浏览器杜宇编译css的顺序？——div ul li #test从右往左 选择器","text":"CSS3学习笔记前言 css的全称是什么？——casccading style sheets 样式表的组成？——选择器+声明块 浏览器杜宇编译css的顺序？——div ul li #test从右往左 选择器 基本选择器 通配符选择器——* {margin:0;} 元素选择器——body {background: #eee} 类选择器——.list {list-style: square} ID选择器——#list {width: 500ox} 后代选择器——.list li {margin-top: 10px} 子元素选择器也可以叫后代直接选择器，此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素 1#wrap &gt; .inner &#123;color: pink;&#125; Html实例 123456789&lt;div id=\"wrap\"&gt; &lt;div&gt;1 &lt;div&gt;1-1&lt;/div&gt; &lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/div&gt; CSS实例 1234#wrap &gt; div&#123; color: brown; border: 5px solid;&#125; 注意：选择的是#wrap下的所有直接后代div,但是color是可继承的，所以1-1颜色也会改变，border却不会。 相邻兄弟选择器它只会匹配紧跟着的兄弟元素 1#wrap &gt; #first + .inner&#123;color: #A52A2A;&#125; Html实例 1234567&lt;div id=&quot;wrap&quot;&gt;&lt;div class=&quot;inner&quot;&gt;1&lt;/div&gt;&lt;div id=&quot;first&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;5&lt;/div&gt;&lt;/div&gt; 注意：改变的只是3号div，如果3号之前存在一个&lt;div&gt;&lt;/div&gt;,那么将不会改变 通用兄弟选择器它会匹配所有的兄弟元素（不需要紧跟） 1#wrap #first ~div&#123;border: 1px solid cornflowerblue;&#125; 注意：HTML结构和相邻兄弟选择器一样，改变的是3,4,5号div 属性选择器存在和值属性选择器html结构 12345&lt;div id=\"wrap\"&gt; &lt;div name=\"zhangsan\"&gt;1&lt;/div&gt; &lt;div name=\"li luo\"&gt;2&lt;/div&gt; &lt;div name=\"li\"&gt;3&lt;/div&gt;&lt;/div&gt; [attr]：该选择器选择包含attr属性的所有元素，无论attr的值是什么 1div[name]&#123;border: 1px solid blueviolet;&#125; /*选中的是所有div*/ [attr = val]：该选择器仅选择attr属性被赋值val的所有元素 1div[name = \"li\"]&#123;border: 1px solid coral;&#125; /*选中的是2,3号div*/ [attr ~= val]：表示带有以attr命名的属性的元素，并且该属性是以一个空格作为分割的值列表，其中至少一个为val 1div[name ~= \"luo\"]&#123;border: 1px solid coral;&#125; /*选中的是2号div*/ 子串值属性选择器html结构 123456&lt;div id=\"wrap\"&gt; &lt;div name=\"luo-zhangsan\"&gt;1&lt;/div&gt; &lt;div name=\"li luo\"&gt;2&lt;/div&gt; &lt;div name=\"luo-li\"&gt;3&lt;/div&gt; &lt;div name=\"luoliluo\"&gt;4&lt;/div&gt;&lt;/div&gt; [attr |= val]：选择的是attr属性的值是val（包括val）或者以val-开头的元素 1div[name |= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,3号元素*/ [attr ^= val]：选择的是attr属性的值以val开头（包括val）的元素 1div[name ^= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,4号元素*/ [attr $= val]：选择的是attr属性的值以val结尾（包括val）的元素 1div[name $= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有2,4号元素*/ [attr *= val]：选择的是attr属性的值中包含字符串val的元素 1div[name *= \"luo\"]&#123;border: 1px solid coral;&#125; /*匹配的只有1,2,3,4号元素*/ 伪类与伪元素选择器链接伪类:link：表示作为超链接，并指向一个为访问的地址的所有锚 :visited：表示作为超链接，并指向一个已访问的地址的所有锚 123a&#123;text-decoration: none;&#125;a:link&#123;color: deeppink;&#125;#test :link&#123;background: pink;&#125; :target：代表一个特殊元素，它的id是URL的片段标识符 :target实例-选项卡,html结构如下 1234567891011121314&lt;body&gt; &lt;a href=\"#div1\"&gt;div1&lt;/a&gt; &lt;a href=\"#div2\"&gt;div2&lt;/a&gt; &lt;a href=\"#div3\"&gt;div3&lt;/a&gt; &lt;div id=\"div1\"&gt; div1 &lt;/div&gt; &lt;div id=\"div2\"&gt; div2 &lt;/div&gt; &lt;div id=\"div3\"&gt; div3 &lt;/div&gt;&lt;/body&gt; css结构如下 12345678910111213141516171819*&#123; margin: 0; padding: 0;&#125;a&#123; text-decoration: none; color: deeppink;&#125;div&#123; width: 200px; height: 200px; background: pink; display: none; text-align: center; font: 50px/200px \"微软雅黑\";&#125;:target&#123; display: block;&#125; 注意：:link，:visited，:target是作用与链接元素的 动态伪类:hover：表示悬浮到元素上 :active：表示匹配被用户激活的元素（点击按住） 由于a标签的：link和：visited可以覆盖了所有的a标签的状态，所以当：link,:visited,:hover,:active同时出现在a标签身上时，：link和：visited不能放在最后 注意：:hover和:active基本可以作用于所有的元素 表单相关伪类:enabled：匹配可编辑的表单:disable：匹配被禁用的表单:checked：匹配被选中的表单:focus ：匹配获焦的表单 实例如下 12345678910111213input:enabled&#123; background: deeppink;&#125;input:disabled&#123; background: blue;&#125;input:checked&#123; width: 200px; height: 200px;&#125;input:focus&#123; background: darkcyan;&#125; html结构如下 123&lt;input type=\"text\" /&gt;&lt;input type=\"text\" disabled=\"disabled\" /&gt;&lt;input type=\"checkbox\" /&gt; 小例子-自定义单选按钮 123456789101112&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"mj\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt; css代码如下 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;label&#123; position: relative; float: left; width: 100px; height: 100px; border: 2px solid; overflow: hidden; border-radius: 50%;&#125;label &gt; span&#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0;&#125;input&#123; position: absolute; left: -50px; top: -50px;&#125;input:checked + span&#123; background: pink;&#125; 结构性伪类选择器:nth-child(index)系列 :first-child :last-child nth-last-child(index):表示从后面开始计数 only-child(相当于:first-child:last-child或者:noth-child(1):nth-last-child(1)) :nth-child(index)实例 1234/*找到#warp底下的所有li子元素,并且选中第一个子元素，并且这个子元素必须是li*/#wrap li:nth-child(1)&#123; color: deeppink;&#125; 注意：1.index的值从1开始计数；2.index可以为变量n(只能是n)；3.index可以为even或者odd :nth-of-type系列 :first-of-type last-of-type nth-last-type(index):表示从后面开始计数 only-of-type 123#wrap li:nth-of-type(1)&#123; color: deeppink;&#125; 注意：nth-child(index)和nth-of-type(index)的区别：前者找某某下的第一个适配元素，后者找某某下的出现第一次的适配元素。 nth-child和nth-of-type的区别（坑） html结构如下 1234567&lt;div id=\"warp\"&gt; &lt;div class=\"inner\"&gt;div&lt;/div&gt; &lt;span class=\"inner\"&gt;span&lt;/span&gt; &lt;p class=\"inner\"&gt;p&lt;/p&gt; &lt;h1 class=\"inner\"&gt;h1&lt;/h1&gt; &lt;h2 class=\"inner\"&gt;h2&lt;/h2&gt;&lt;/div&gt; 使用nth-child如下，这个没什么问题，选中的是#warp下的class为.inner的第一个元素div 123#warp .inner:nth-child(1)&#123; color: deeppink;&#125; 使用nth-of-type如下，选中的却是所有元素，这是因为nth-of-type是以元素为中心 123#warp .inner:nth-of-type(1)&#123; color: deeppink;&#125; not 123div &gt; a:not(:last-of-type)&#123; border-right: 1px solid red;&#125; enpty(内容必须是空的，有空格都不行) 伪元素选择器伪元素包含这几种，::after，::before，::firstLetter，::firstLine，::selection ::after实例如下 1234567#warp::after&#123; content: \"\"; display: block; width: 200px; height: 200px; background: deeppink;&#125; ::firstLetter实例如下:将第一个字改变 1&lt;div&gt;我是谁？&lt;/div&gt; 12345div::first-letter&#123; color: deeppink; font-size: 24px; font-weight: bold;&#125; ::firstLine实例如下：将第一行改变 1234&lt;div&gt; 我是谁？&lt;br&gt; 我来自哪里？&lt;br&gt;&lt;/div&gt; 12345div::first-line&#123; color: deeppink; font-size: 24px; font-weight: bold;&#125; ::selection实例如下：改变鼠标选中时的状态 1&lt;div&gt;我是谁？我来自哪里？&lt;/div&gt; 1234div::selection&#123; color: deeppink; background: white;&#125; 自定义字体实例如下 1234@font-face &#123; font-family:; src: url();&#125; 新增UI方案文本新增样式opacity：改变透明度123456789101112#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: pink; opacity: 0.1;&#125;#inner&#123; width: 100px; height: 100px; background: deeppink;&#125; 12345&lt;div id=\"warp\"&gt; &lt;div id=\"inner\"&gt; inner &lt;/div&gt;&lt;/div&gt; 新增颜色模式rgba123456#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: rgba(0,0,0,.8);&#125; 说明：rgba其实就是rgb颜色加一个透明度 实例，背景透明，文字不透明12345678910#warp&#123; width: 300px; height: 300px; margin: 100px auto; background: rgba(0,0,0,0.8); color: #FFFFFF; font-size: 30px; line-height: 300px; text-align: center;&#125; 如果是文字透明，背景不透明，将color换成rgba,background使用#形式的颜色模式 文字阴影text-shadow用来为文字添加阴影，而且可以添加多层，阴影之间用逗号隔开（多个阴影时，第一个在最上面） 12345h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; text-shadow: gray 10px 10px 10px;&#125; 实例-浮雕文字123456h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; color: white; text-shadow: black 1px 1px 10px;&#125; 实例-文字模糊效果12345678910h1&#123; text-align: center; font: 100px/200px \"微软雅黑\"; color: black; transition: 1s;&#125;h1:hover&#123; color: rgba(0,0,0,0); text-shadow: black 0 0 100px;&#125; 实例-模糊背景12345678910111213141516171819#warp&#123; height: 100px; background: rgba(0,0,0,.5); position: relative;&#125;#warp #bg&#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0; background: url(img/2_1.jpg) no-repeat; background-size: 100% 100%; z-index: -1; filter: blur(10px);/*元素模糊*/&#125;img&#123; margin: 24px 0 0 24px;&#125; 1234&lt;div id=\"warp\"&gt; &lt;img src=\"img/2_1.jpg\" width=\"64\" height=\"64\" /&gt; &lt;div id=\"bg\"&gt;&lt;/div&gt;&lt;/div&gt; 文字描边123456h1&#123; font: 100px/200px \"微软雅黑\"; text-align: center; color: white; -webkit-text-stroke: pink 4px;&#125; 文字排版实例，省略过长内容显示为… 123456789div&#123; width: 200px; height: 100px; border: 1px solid; margin: 0 auto; white-space: nowrap;/*不换行*/ overflow: hidden;/*省略溢出内容*/ text-overflow: ellipsis;&#125; 注意：这个的使用的前提是：不能让元素的大小靠内容撑大，也就是不能使用display: inline;属性 盒模型新增样式盒模型阴影1box-shadow: inset 10px 10px 10px 0px black ; 说明：box-shadow较text-shadow多了两个参数，第一个是阴影方向，第五个是阴影大小 1234567891011121314151617#warp&#123; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; width: 100px; height: 100px; background: pink;/*以上所有样式就是让盒子水平和垂直居中*/ text-align: center; line-height: 100px; transition: 1s;&#125;#warp:hover&#123; box-shadow: 10px 10px 10px 0px black ;&#125; 倒影-webkit-box-reflect1234img&#123; vertical-align: middle; -webkit-box-reflect: right;&#125; resize:允许你控制一个元素的可调整性，需要overflow：auto配合使用 12345678#warp&#123; display: inline-block; width: 200px; height: 200px; background: pink; resize: both; overflow: auto;&#125; box-sizingbox-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素， 123456789#warp &gt; div&#123; margin: 10px; width:130px ; height: 130px; background: deeppink; float: left; border: 1px solid; box-sizing: border-box;&#125; 在上面的css代码中使用 float: left;如果要使用 border: 1px solid;就必须添加box-sizing: border-box;才不会改变布局 新增UI样式圆角12345678910111213#warp&#123; position: absolute; height: 70px; width: 200px; border: 1px solid; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ border-radius: 30px;&#125; border-radius: 30px;这种是简写方式，border-radius: 30px 20px 10px 40px; 是分别对应四角的写法 注意：圆角最好使用px值，不要使用百分比 圆角实例-旋转的风车1234567891011121314151617181920212223242526272829303132333435363738*&#123; margin: 0; padding: 0;&#125;html,body&#123; height: 100%; overflow: hidden;/*这两个是禁止滚动条*/&#125;#warp&#123; position: absolute; height: 300px; width: 300px; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ transition: 2s;&#125;#warp &gt; div&#123; margin: 10px; width:130px ; height: 130px; background: deeppink; float: left; border: 1px solid; box-sizing: border-box;&#125;#warp &gt; div:nth-child(1),#warp &gt; div:nth-child(4)&#123; border-radius: 0 60%;&#125;#warp &gt; div:nth-child(2),#warp &gt; div:nth-child(3)&#123; border-radius: 60% 0;&#125;#warp:hover&#123; transform: rotate(120deg);/*旋转函数*/&#125; 123456&lt;div id=\"warp\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 边框图片1234567891011121314151617#warp&#123; position: absolute; height: 200px; width: 200px; border: 1px solid; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;/*以上都是让元素水平和垂直居中的方法*/ border: 50px solid; border-image-source: url(img/border-image.png); border-image-slice: 33.3333%; border-image-repeat: round; border-image-width: 20px;&#125; 1&lt;div id=\"warp\"&gt;&lt;/div&gt; 线性渐变双颜色值的线性渐变 1background-image:linear-gradient(red,blue); 多颜色值的线性渐变 1background-image:linear-gradient(red,blue,pink,black); 改变渐变方向 1background-image:linear-gradient(to top left,red,blue); 使用角度 1background-image:linear-gradient(0deg,red,blue); 控制颜色节点的分布 1background-image:linear-gradient(90deg,red 10%,orange 15%,yellow 20%,green 30%,blue 50%,indigo 70%,violet 80%); 透明度的渐变 1background-image:linear-gradient(90deg,rgba(255,0,0,0) 50%,rgba(255,0,0,0.5),rgba(255,0,0,1) 60%); 重复渐变 1background: repeating-linear-gradient(90deg,red 10%,blue 30%); 渐变实例-发廊灯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; overflow: hidden; &#125; #warp&#123; height: 300px; width: 40px; border: 1px solid; margin: 100px auto; overflow: hidden; &#125; #warp &gt; .inner&#123; height: 600px;/*这是是颜色所在的高度。远比能看见的要高*/ background: repeating-linear-gradient(135deg,black 0px,black 10px,white 10px,white 20px); &#125; #warp:hover .inner&#123; margin-top: -300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"warp\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var inner = document.querySelector(\"#warp &gt; .inner\");/*获取元素*/ var flag = 0;/*循环结束后归零*/ setInterval(function()&#123; flag++; if(flag == 300)&#123; flag = 0; &#125; inner.style.marginTop = -flag+\"px\"; &#125;,1000/60)/*设置定时器循环*/ &lt;/script&gt;&lt;/html&gt; 渐变实例-光斑动画1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; overflow: hidden; background: black; text-align: center;/*配合h1的display: inline-block;属性让h1这个元素居中*/ &#125; h1&#123; display: inline-block; color: rgba(255,255,255,.3); font: bold 80px \"微软雅黑\"; background: linear-gradient(120deg,rgba(255,255,255,0) 100px,rgba(255,255,255,1) 180px,rgba(255,255,255,0) 260px); background-repeat: no-repeat; -webkit-background-clip: text; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;码酱博客-专注与总结分享&lt;/h1&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var h1 = document.querySelector(\"h1\");/*获取元素*/ var flag = -160;/*循环结束后归零*/ setInterval(function()&#123; flag+=10; if(flag == 900)&#123; flag = -160; &#125; h1.style.backgroundPosition = flag+\"px\"; &#125;,30)/*设置定时器循环*/ &lt;/script&gt;&lt;/html&gt; 径向渐变双颜色值的径向渐变 1background-image:radial-gradient(red,blue); 多颜色值的径向渐变 1background-image: radial-gradient(red,blue,pink,black); 不均匀分布 1background-image:radial-gradient(red 50%,blue 70%); 改变渐变形状 1background-image:radial-gradient(ellipse,red,blue); 渐变形状的尺寸大小 1background-image:radial-gradient(farthest-corner ellipse,red,blue); 改变圆心 1background-image:radial-gradient(closest-corner circle at 10px 10px,red,blue); 重复渐变 1background-image:repeating-radial-gradient(closest-corner circle,red 30%,blue 50%); 过渡transition CSS transition 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义 transition是一个简写属性，用于 transition-property,transition-duration,transition-timing-function, 和transition-delay。 注意：在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay transition分为一下属性：transition-property，transition-duration，transition-timing-function，transition-delay transition-property指定应用过渡属性的名称，默认值为 all，表示所有可被动画的属性都表现出过渡动,可以指定多个 property 注意：不是所有的属性都可以添加动画过渡的，过渡时间必须带单位s秒 那些属性可以添加动画过渡，参看这个连接 默认值： none： 没有过渡动画。 all ：所有可被动画的属性都表现出过渡动画。 transition-duration属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s (一定要带单位)，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 默认值： 属性值： 以毫秒或秒为单位的数值&lt;time&gt; 类型。表示过渡属性从旧的值转变到新的值所需要的时间。 如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。一定要加单位(不能写0 一定要写0s 1s,0s,1s)！ transition-timing-functionCSS属性受到 transition的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变 属性值： ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier： 贝塞尔曲线 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(&lt;integer&gt;,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） transition-delay规定了在过渡效果开始作用之前需要等待的时间。默认值：0s; 你可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始 当属性值的列表长度不一致时1234transition-property: background,width,height;transition-duration: 3s,2s;transition-delay:3s,2s;transition-timing-function:linear; 实际效果如下 1234transition-property: background,width,height;transition-duration: 3s,2s,3s;transition-delay:3s,2s,3s;transition-timing-function:linear,ease,ease; 说明： 1.超出的情况下是会被全部截掉的2.不够的时候，关于时间的会重复列表，transition-timing-function的时候使用的是默认值ease 2D变换（变形）transformtransform 属性允许你修改CSS视觉格式模型的坐标空间，transform 属性 , 只对 block 级元素生效！ 旋转（rotate） 平移（translate） 倾斜（skew） 缩放（scale） 基点的变换 矩阵（matrix） 旋转 平移 倾斜 缩放 旋转（rotate）1transform:rotate(angle); 正值:顺时针旋转 rotate(360deg), 负值:逆时针旋转 rotate(-360deg) 只能设单值。正数表示顺时针旋转，负数表示逆时针旋转 平移（translate）X方向平移:transform: translateX(tx)，Y方向平移:transform: translateY(ty)二维平移：transform: translate(tx, ty)； 如果ty没有指定，它的值默认为0。 说明：可设单值，可设双值，正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变， 12transform: translate(100px,200px);// 斜着移动transform: translate(100px,0); 倾斜（skew）X方向倾斜:transform: skewX(angle) 1transform: skewX(45deg) // 参数值以deg为单位 代表与y轴之间的角度 Y方向倾斜:transform: skewY(angle) 1transform: skewY(45deg) // 参数值以deg为单位 代表与x轴之间的角度 二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜 1transform:skew(45deg,15deg);// 第一个参数代表与y轴之间的角度, 第二个参数代表与x轴之间的角度 缩放（scale）X方向缩放:transform: scaleX(sx); 1transform: scaleX(2); Y方向缩放:transform: scaleY(sy); 1transform: scaleY(.5); 二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 1transform: scale(2,.5); 要缩小请设0.01～0.99之间的值，要放大请设超过1的值。单值时表示只X轴,Y轴上缩放粒度一样，如transform: scale(2);等价于transform: scale(2,2); 注意：以上的变换都是基于中心原点变换，改变基点，使用transform-origin: 100% 100%;属性 基点变换transform-origintransform-origin CSS属性让你更改一个元素变形的基点。 矩阵（matrix）在 2D变换 中，矩阵变换函数 matrix() 接受 6个值，语法形式如下：transform: matrix(a, b, c, d, e, f); 对某一元素应用旋转变换 rotate(θ)，使用矩阵实现 matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0) 对某一元素应用旋转变换 translate(X, Y)，使用矩阵实现： matrix(1, 0, 0, 1, X, Y) 对某一元素应用倾斜变换 skew(α, β)，使用矩阵变换函数 matrix(1, tanβ, tanα,1, 0, 0)。 对某一元素应用缩放变换 scale(scaleX, scaleY)，使用矩阵变换函数 matrix(scaleX, 0, 0, scaleY, 0, 0) 3D变形在浏览器中，X轴是从左到右，Y轴是从上到下，Z轴是从里到外 3D缩放transform: scale3d(scaleX,scaleY,scaleZ);或者transform: scaleZ(number) 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 3D旋转CSS3中的3D旋转主要包括四个功能函数：rotateX(angle)、 rotateY(angle)、rotateZ(angle)、rotate3d(x,y,z,angle) x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值 3D平移transform: translateZ(length)是3D Transformaton特有的，其他两个2D中就有 translateZ 它不能是百分比值; 那样的移动是没有意义的。 transform: translate3d(translateX,translateY,translateZ); translateZ 它不能是百分比值; 那样的移动是没有意义的。 景深（perspective）动画（Animation）css3动画就是使元素从一种样式逐渐变化为另一种样式的效果，animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 关键帧（@keyframes）语法如下： 12345 @keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125; animiationName:必写项，定义动画的名称, keyframes-selector：必写项，动画持续时间的百分比， from：0%to：100%， css-style：css声明 示例如下： 1234567891011#wran&#123; animation-name :move&#125;@keyframes move&#123; from&#123; transform:rotate(0deg); &#125; to&#123; transform:rotate(360deg); &#125;&#125; animation-nameanimation-name属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 animation-durationanimation-duration属性指定一个动画周期的时长。默认值为0s，表示无动画。一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 注意：负值无效，浏览器会忽略该声明，但是一些早起的带前缀的声明会将负值当作0s animation-timing-functionanimation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始，到关键帧结束。动画的默认效果：由慢变快再变慢 linear:线性过渡，等同于贝塞尔曲线（0,0,1,1） ease:平滑过渡，等同于贝塞尔曲线（0.25,0.1,0.25,1.0） ease-in:由慢到快，等同于贝塞尔曲线（0.42,0,1,1） ease-out:由快到慢，等同于贝塞尔曲线（0,0,0.58,1） ease-in-out:由慢到快再到慢，等同于贝塞尔曲线（0.42,0,0.58,1） cubic-bezier(1,1,2,3) steps(n,[start|end]) 传入一到两个参数，第一个参数意思是把动画分成 n 等分，然后动画就会平均地运行。 第二个参数 start 表示从动画的开头开始运行，相反，end 就表示从动画的结尾开始运行， 默认值为 end。 animation-delay定义动画开始前等待的时间,以秒或毫秒计(属于动画外的范畴),值为time, 从动画样式应用到元素上到元素开始执行动画的时间差。该值可用单位为秒(s)和毫秒(ms)。如果未设置单位，定义无效 animation-iteration-count定义了动画执行的次数（属于动画内的范畴）,值为infinite表示 无限循环播放动画.&lt;number&gt;表示动画播放的次数 不可为负值. animation-direction定义了动画执行的方向 normal： 每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，默认属性。 alternate：动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向， 比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭 代 reverse：反向运行动画，每周期结束动画由尾到头运行。 alternate-reverse：反向交替， 反向开始交替 animation-fill-mode属于动画外的范畴，定义动画在动画外的状态 animation-play-state定义了动画执行的运行和暂停， running表示当前动画正在运行。paused表示当前动画以被停止。 布局扩展老版本布局CSS3 弹性盒子(Flexible Box 或 Flexbox)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行/列。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。 老版本的我们通常称之为box， 新版本的我们通常称之为flex 注意：项目永远在主轴的正方向排列 老版容器的布局方向 -webkit-box-orient: horizontal; x轴 -webkit-box-orient: vertical; y轴 123display: -webkit-box;/*-webkit-box-orient属性控制的主轴是那个*/-webkit-box-orient: vertical; 注意：项目永远在主轴的正方向排列 老版容器的排列方向 -webkit-box-direction: normal; -webkit-box-direction: reverse; -webkit-box-direction属性本质上改变了主轴的方向 1234display: -webkit-box;-webkit-box-orient: vertical;/*-webkit-box-direction控制主轴的方向*/-webkit-box-direction: reverse; 老版本富裕空间管理（主轴上）1-webkit-box-pack:start; 不会给项目区分配空间，只是确定富裕空间的位置 start：表示富裕空间在右边 end：表示富裕空间在左边 center：表示富裕空间在两边 justify：表示富裕空间在项目之间 老版本富裕空间管理（侧轴上）1-webkit-box-align:center; /*不会给项目区分配空间，只是确定富裕空间的位置*/ start：侧轴为x轴，富裕空间位于右边，侧轴为y轴，富裕空间位于下边 end：侧轴为x轴，富裕空间位于左边，侧轴为y轴，富裕空间位于上边 center ：富裕空间位于两边 新版本flex布局新版本的布局方向 flex-direction: row; flex-direction: column; 123display: flex;/*flex-direction决定主轴方向*/flex-direction: row; 新版本的排列方向 flex-direction:row-reverse; flex-direction:column-reverse; 123display: flex;/*flex-direction既控制主轴是那个，也控制主轴方向*/flex-direction: row-reverse 新版本富裕空间管理（主轴上）1justify-content: flex-start; /*更强大的富裕空间的管理（主轴）*/ flex-start：富裕空间在主轴的正方向 flex-end：富裕空间在主轴的反方向 center：富裕空间在主轴的两边 space-between：富裕空间在项目之间 space-around(box 没有的)：富裕空间在项目两边 新版本富裕空间管理（侧轴上）1align-items: stretch; flex-start：富裕空间在侧轴的正方向 flex-end：富裕空间在侧轴的反方向 center：富裕空间在侧轴的两边 baseline(box 没有的)：按照基线对齐 stretch(box 没有的)：等高布局 有关布局的HTML结构如下 1234567&lt;div id=\"warp\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;div class=\"item\"&gt;5&lt;/div&gt;&lt;/div&gt; 说明：id=”warp”为容器，&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;为项目 flex布局总结 明确什么是容器，什么是项目，什么是主轴，什么是侧轴 项目永远排列在主轴上 flex布局分为两个版本：-webkit-box-和flex 老版本容器 容器的布局方向：-webkit-box-orient:horizontal/vertical,控制主轴是哪一根， horizontal：x轴，vertical ：y轴 容器的排列方向：-webkit-box-direction：normal/reverse控制主轴的方向， normal：从左往右（正方向）reverse：从右往左（反方向） 富裕空间的管理：只决定富裕空间的位置，不会给项目区分配空间 主轴：-webkit-box-pack 主轴是x轴 start：在右边 end: 在左边 center：在两边 justify：在项目之间 主轴是y轴 start：在下边 end：在上边 center：在两边 justify：在项目之间 侧轴：-webkit-box-algin 侧轴是x轴 start：在右边 end： 在左边 center：在两边 侧轴是y轴 start：在下边 end： 在上边 center：在两边 项目 弹性空间管理：-webkit-box-flex：弹性因子（默认值为0） 新版本容器容器的布局方向和容器的排列方向使用一个属性flex-direction,控制主轴是哪一根，控制主轴的方向 row; 从左往右的x轴 row-reverse;从右往左的x轴 column; 从上往下的y轴 column-reverse;从下往上的y轴 富裕空间的管理：只决定富裕空间的位置，不会给项目区分配空间 主轴justify-content flex-start： 在主轴的正方向 flex-end: 在主轴的反方向 center： 在两边 space-between： 在项目之间 space-around： 在项目两边 侧轴align-items flex-start：在侧轴的正方向 flex-end： 在侧轴的反方向 center： 在两边 baseline 基线对齐 stretch 等高布局（项目没有高度） 新版flex布局详解容器 flex-wrap：控制的是侧轴的方向 123align-items: flex-start;/*对单行单列的富裕空间管理*/flex-wrap: wrap-reverse;/*当容器的宽度小于项目的宽度时控制是否换行显示，也就是控制侧轴的方向*/align-content: flex-start;/*对多行多列富裕空间的管理*/ align-content 属性定义弹性容器的侧轴方向上有额外空间时，如何排布每一行/列。当弹性容器只有一行/列时无作用 align-content值如下： flex-start：所有行/列从侧轴起点开始填充。第一行/列的侧轴起点边和容器的侧轴起点边对齐。 接下来的每一行/列紧跟前一行/列。 flex-end：所有弹性元素从侧轴末尾开始填充。最后一个弹性元素的侧轴终点和容器的侧轴终点对齐。同时所有后续元素与前一个对齐。 center：所有行/列朝向容器的中心填充。每行/列互相紧挨，相对于容器居中对齐。 容器的侧轴起点边和第一行/列的距离相等于容器的侧轴终点边和最后一行/列的距离。 space-between：所有行/列在容器中平均分布。相邻两行/列间距相等。 容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的边对齐。 space-around：所有行/列在容器中平均分布，相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的距离是相邻两行/列间距的一半。 stretch：拉伸所有行/列来填满剩余空间。剩余空间平均的分配给每一行/列 flex-flow 属性 flex-flow 属性是设置“flex-direction”和“flex-wrap”的简写,默认值：row nowrap 不可继承 控制主轴和侧轴的位置以及方向 项目order 属性 order 属性规定了弹性容器中的可伸缩项目在布局时的顺序。元素按照 order 属性的值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局,order越大越后 123456#warp &gt; .item:nth-child(1)&#123; order: 5;&#125;#warp &gt; .item:nth-child(2)&#123; order: 3;&#125; align-self 属性 align-self 会对齐当前 flex 行中的 flex 元素，并覆盖 align-items 的值. 如果任何 flex 元素的侧轴方向 margin 值设置为 auto，则会忽略 align-self。 auto：设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch。 flex-start：flex 元素会对齐到 cross-axis 的首端。 flex-end：flex 元素会对齐到 cross-axis 的尾端。 center： flex 元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出。 baseline：所有的 flex 元素会沿着基线对齐， stretch：flex 元素将会基于容器的宽和高，按照自身 margin box 的 cross-size 拉伸 12345678#warp &gt; .item:nth-child(2)&#123; order: 3; align-self: flex-end;&#125;#warp &gt; .item:nth-child(3)&#123; order: 2; align-self: center;&#125; flex-shrink属性 flex-grow 属性定义弹性盒子项（flex item）的拉伸因子。 可用空间 = (容器大小 - 所有相邻项目flex-basis的总和) 可扩展空间 = (可用空间/所有相邻项目flex-grow的总和) 每项伸缩大小 = (伸缩基准值 + (可扩展空间 x flex-grow值)) flex-shrink 属性指定了 flex 元素的收缩因子 默认值为1 计算收缩因子与基准值乘的总和 计算收缩因数： 收缩因数=（项目的收缩因子*项目基准值）/第一步计算总和 移除空间的计算：移除空间= 项目收缩因数 x 负溢出的空间 flex-basis属性 flex-basis 指定了 flex 元素在主轴方向上的初始大小，默认值 ：auto 不可继承 注意： 在flex简写属性中 flex-basis的默认值为0 flex实例等分布局 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; #warp&#123; width:500px; height: 300px; border: 1px solid; margin: 100px auto; display: flex; &#125; #warp &gt; .item&#123; height: 50px; background: pink; text-align: center; line-height: 50px; flex-shrink: 1; flex-grow: 1;/*将富裕空间等分，并没有将项目等分*/ flex-basis: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"warp\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;22&lt;/div&gt; &lt;div class=\"item\"&gt;333&lt;/div&gt; &lt;div class=\"item\"&gt;4444&lt;/div&gt; &lt;div class=\"item\"&gt;55555&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex简写属性语法糖 12345flex-shrink: 1;flex-grow: 1;/*将富裕空间等分，并没有将项目等分*/flex-basis: 0;/*上述三个属性和下列属性语法一样*/flex: 1; 等分布局实例，天猫导航栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; a&#123; text-decoration: none; color: gray; display: block;/*设置a标签不仅仅是可以点击文字，还可以点击div块*/ &#125; #nav .row&#123; display: flex; &#125; #nav &gt;.row &gt; .item&#123; flex: 1; text-align: center; &#125; #nav &gt; .row &gt; .item &gt; a:before&#123; content: \"\"; display: block; width: 86px; height: 86px; margin: 0 auto; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(1) &gt; a:before&#123; background: url(../img/01.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(2) &gt; a:before&#123; background: url(../img/02.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(3) &gt; a:before&#123; background: url(../img/03.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(4) &gt; a:before&#123; background: url(../img/04.png) no-repeat; &#125; #nav &gt;.row:nth-child(1) &gt; .item:nth-child(5) &gt; a:before&#123; background: url(../img/05.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(1) &gt; a:before&#123; background: url(../img/06.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(2) &gt; a:before&#123; background: url(../img/07.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(3) &gt; a:before&#123; background: url(../img/08.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(4) &gt; a:before&#123; background: url(../img/09.png) no-repeat; &#125; #nav &gt;.row:nth-child(2) &gt; .item:nth-child(5) &gt; a:before&#123; background: url(../img/10.png) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"nav\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;聚划算&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫国际&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;外卖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫超时&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;充值中心&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;天猫旅行&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;领金币&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;拍卖&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"javascript;\"&gt;分类&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://caochenhins.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://caochenhins.github.io/tags/CSS/"}]},{"title":"Mybatis知识总结","slug":"Mybatis知识总结","date":"2019-03-21T14:14:28.000Z","updated":"2019-03-21T15:17:02.220Z","comments":true,"path":"2019/03/21/Mybatis知识总结/","link":"","permalink":"https://caochenhins.github.io/2019/03/21/Mybatis知识总结/","excerpt":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. Mybatis与其他持久化方式对比 MyBatis是一个半自动化的持久化框架 JDBC是SQL夹在Java代码中，耦合度高导致硬编码，维护不易且实际开发中SQL会经常变化 Hibernate和JPA是内部自动产生的SQL语句，不容易做特殊优化，长而复杂的SQL，hibernate处理也不容易，是基于全映射的全自动化框架，大量子弹的pojo进行部分映射比较困难，导致数据库性能下降 对于开发人员，核心SQL需要自己优化，所以需要SQL和java编码分开，功能界面明显，一个专注业务，一个专注数据 文档资料下载地址：https://github.com/mybatis/mybatis-3 中文文档：http://www.mybatis.org/mybatis-3/zh/index.html","text":"MyBatis简介MyBatis概述 MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. Mybatis与其他持久化方式对比 MyBatis是一个半自动化的持久化框架 JDBC是SQL夹在Java代码中，耦合度高导致硬编码，维护不易且实际开发中SQL会经常变化 Hibernate和JPA是内部自动产生的SQL语句，不容易做特殊优化，长而复杂的SQL，hibernate处理也不容易，是基于全映射的全自动化框架，大量子弹的pojo进行部分映射比较困难，导致数据库性能下降 对于开发人员，核心SQL需要自己优化，所以需要SQL和java编码分开，功能界面明显，一个专注业务，一个专注数据 文档资料下载地址：https://github.com/mybatis/mybatis-3 中文文档：http://www.mybatis.org/mybatis-3/zh/index.html MyBatis的HelloWord概述随着Maven的流行，现在几乎很少有使用jar的方式来搭建开发环境，这里也就不在单个使用Mybatis去操作数据库，不会的可以自行百度，MyBatis只是一个持久化框架，只有和其他框架整合才能更好的使用，例如SpringMVC，SpringBoot等，与Spring整合后，Mybatis的一些配置文件都会交于Spring管理。 MyBatis的全局配置文件概述MyBatis的全局配置文件可以配置的属性如下 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 properties属性MyBatis使用properties来引入外部properties配置文件的内容，resource：引入类路径下的资源，url引入网络路径或者磁盘路径下的资源。可以用于将数据源连接信息放在properties文件中，与Spring整合后就写在Spring的配置文件中。 引入外部properties文件 1&lt;properties resource=\"org/mybatis/example/config.properties\"&gt;&lt;/properties&gt; 使用引入的properties文件 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; settings运行时设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。 设置参数 描述 有效值 默认值 cacheEnabled 全局开启或关闭配置文件中的所有映射器任何缓存 true \\ false true lazyLoadingEnabled 延迟加载的全局开关 true \\ false false aggressiveLazyLoading 开启，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 true \\ false false multipleResultSetsEnabled 是否允许单一语句返回多结果集 true \\ false true useColumnLabel 使用列标签代替列名。 true \\ false true useGeneratedKeys 允许 JDBC 支持自动生成主键 如果设置为 true 则这个设置强制使用自动生成主键 true \\ false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出提醒 NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 任意正整数 defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 任意正整数 safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。 true \\ false False safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。 true \\ false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true \\ false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION \\ STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始) callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 true \\ false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始） true \\ false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象用到的代理工具。 CGLIB \\ JAVASSIST 常用的Setting设置 设置参数 描述 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名规则映射A_COLUNM到aColumn false defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 Settings设置示例1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases别名类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余,但是往往我们不会使用别名，是为了方便查看代码。 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，给包和子包下的所有类起一个默认的别名（类名小写） 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。 12@Alias(\"author\")public class Author &#123;&#125; typeHandlers 类型处理器无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 类型处理器 Java类型 JDBC类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SHORT INTEGER IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 LONG INTEGER FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）。 InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR or LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE plugins插件MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments环境配置MyBatis可以配置多种环境，default代表指定使用某种环境，这样就可以快速切换环境，尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一 ，所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例 。每个数据库对应一个 SqlSessionFactory 实例 环境配置实例 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 环境配置说明 默认的环境 ID（比如:default=”development”）。 每个 environment 元素定义的环境 ID（比如:id=”development”）。 事务管理器的配置（比如:type=”JDBC”）。 数据源的配置（比如:type=”POOLED”）。 MyBatis映射文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在 。SQL 映射文件有很少的几个顶级元素 ，如下 cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 Select查询查询语句是 MyBatis 中最常用的元素之一 ，简单查询的 select 元素是非常简单的。比如 123&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 该查询接受一个 int（或 Integer）类型的参数，返回一个 HashMap 类型的对象，键是列名，值是结果行中的对应值。 select 元素有很多属性允许你配置，来决定每条语句的作用细节 ，如下 123456789101112&lt;select id=\"selectPerson\" parameterType=\"int\" parameterMap=\"deprecated\" resultType=\"hashmap\" resultMap=\"personResultMap\" flushCache=\"false\" useCache=\"true\" timeout=\"10000\" fetchSize=\"256\" statementType=\"PREPARED\" resultSetType=\"FORWARD_ONLY\"&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 insert update delete数据变更语句 insert，update 和 delete 的实现非常接近 ,如下 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" keyColumn=\"\" useGeneratedKeys=\"\" timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 属性说明 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 示例 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 多行插入 1234567&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username, password, email, bio) values &lt;foreach item=\"item\" collection=\"list\" separator=\",\"&gt; (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;) &lt;/foreach&gt;&lt;/insert&gt; 自动生成主键 12345&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 映射文件小结 Mybatis允许增删改直接定义的返回值：Integer，Long，Boolean,返回的是改变数据库表的记录数和true和false 支持自动生成主键的字段，设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。 数据库还支持多行插入, 你也可以传入一个数组或集合，并返回自动生成的主键 映射文件参数处理 单个参数：MyBatis不会做特殊处理，#{参数名/任意名}：取出参数值 多个参数：MyBatis会做特殊处理，多个参数被封装为一个map,key：param1…param10或者参数的索引 命名参数，多个参数使用#{param1}来取值导致错乱，故使用命名参数，明确指定封装map的key,如下 1public Person getPerson(@Param(\"id\") Integer id,@Param(\"name\") String laseName); 这个时候在xml文件中可以使用#{id}和#{name}来取值 如果传入多个参数正好是POJO：可以使用#{属性名}直接获取。 如果传入多个参数不是POJO,为了方便，我们可以传入map,如下 1public Person getPerson(Map&lt;String,Object&gt; map); 这个时候也就可以在xml文件中使用#{key}直接取出传入map的key对应的值 如果传入多个参数不是POJO,但是查询频率高，使用map不方便，可以编写一个TO(数据传输对象) 如果传入了一个Collection（list，set）类型或者数组，也会特殊处理，也是吧list或者数组封装到map中，传入的类型不一样，对应的key如下：Collection（collection）,List（list），数组（array）,示例如下 1public Person get(List&lt;Integer&gt; ids); 传入的是一个list集合，在xml文件中，我们如果需要取出list中的第一个元素为：#{list[0]} #和$取值区别 取值的方式#{}是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}:取出的值直接拼装在sql语句中；会有安全问题；大多情况下，我们去参数的值都应该去使用#{}； 原生jdbc不支持占位符的地方我们就可以使用${}进行取值比如分表、排序。；按照年份分表拆分 12select * from $&#123;year&#125;_salary where xxx;select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125; select查询返回类型 返回一个集合：resultType写集合中元素的类型 返回一条记录的map，key为列名，value为列对应的值，例如 1public Map&lt;String ,Object&gt; getPersonByMap(Integer id); 123&lt;select id = \"getPersonByMap\" resultType=\"map\"&gt; select * from person where id = #&#123;id&#125;&lt;/select&gt; 返回多条记录封装的一个map，Map&lt;Integer,Person&gt;:key是这条记录的主键，值是记录封装后的pojo,如下 12@MapKey(\"id\")public Map&lt;Integer,Person&gt; getPersonByName(String name); 123&lt;select id = \"getPersonByName\" resultType=\"com.test.Person\"&gt; select * from person where last_name like #&#123;name&#125;&lt;/select&gt; @MapKey(“id”)注解表示使用那个属性作为返回结果map的key。 resultMap自定义结果集示例 1234567&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt;&lt;/restMap&gt;&lt;select id=\"getPerson\" restMap=\"baseMap\"&gt; select * from person&lt;/select&gt; resultMap关联属性_级联属性封装结果集 例如：员工有部门属性，联合查询返回封装结果 123456&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;result column=\"dept_id\" property=\"dept.id\" &gt;&lt;/result&gt; &lt;result column=\"dept_name\" property=\"dept.name\" &gt;&lt;/result&gt;&lt;/restMap&gt; 使用association指定联合的java对象 12345678&lt;restMap id=\"baseMap\" type=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;/association&gt;&lt;/restMap&gt; 使用collection定义关联集合的封装规则 例如，查询部门的时候，查询出当前部门下的所有员工 12345678&lt;restMap id=\"baseMap\" type=\"com.test.DepartMent\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"name\" &gt;&lt;/result&gt; &lt;collection property=\"persons\" javaType=\"com.test.Person\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\" &gt;&lt;/result&gt; &lt;/collection&gt;&lt;/restMap&gt; sql标签这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如： 1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如： 1234567&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;, &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; MyBatis的动态SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 如下 if choose (when, otherwise) trim (where, set) foreach if的使用动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如 注意：在xml文件中特殊符号，像&lt;，&gt;要使用转义字符 12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; choose，when，otherwise有时我们不想应用到所有的条件语句，而只想从中择其一项 ，如下 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim, where, set在前面，如果所有的条件都是动态sql,那么可能会出现一下情况的SQL语句 12SELECT * FROM BLOG WHERESELECT * FROM BLOG WHERE AND title like ‘someTitle’ 出现以上错误的sql语句，MyBatis提供了一种解决方式 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除 。注意：WHERE只会去掉开头第一个AND或OR 使用where会出错的情况，And放在后面 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; AND &lt;/if&gt; &lt;if test=\"title != null\"&gt; title like #&#123;title&#125; AND &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 另外一种解决办法就是使用标签，使用where，也可能造成最后一个and，使用trim方法如下 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ... &lt;/trim&gt; prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容（移除前面多余的AND 或者OR），并且插入 prefix 属性中指定的内容。 使用suffixOverrides会移除后面多余的AND或者OR。 set标签与if结合实现动态更新 12345678910&lt;update id=\"updateAuthorIfNecessary\"&gt; update Author &lt;set&gt; &lt;if test=\"username != null\"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=\"password != null\"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"bio != null\"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号,也可以使用trim，注意这里我们删去的是后缀值，同时添加了前缀值。 123&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; ...&lt;/trim&gt; foreach动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： 123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 说明: collection：指定要遍历的集合 item：将当前遍历的每一个元素赋给指定的变量 separator：每一个元素之间的分隔符 open：遍历出所有的结果拼接一个开始的字符 close：遍历出所有的结果拼接一个结束的字符 index：遍历list的就是索引，遍历map的时候就是map的key,item是map的值 Mysql下的批量插入1public void addEmp(@Param(\"emps\") List&lt;Employee&gt; emps); 1234567&lt;insert id=\"addEmp\"&gt; INSERT into employee(name,age)values &lt;foreach item=\"emp\" index=\"index\" collection=\"emps\" open=\"(\" separator=\",\" close=\")\" index=\"i\"&gt; #&#123;emp.name&#125;, #&#123;emp.age&#125; &lt;/foreach&gt;&lt;/insert&gt; bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如 12345&lt;select id=\"selectBlogsLike\" resultType=\"Blog\"&gt; &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 如果是模糊查询，使用下面的方式是行不通的，如下 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%#&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之一，可以使用$符号(不安全) 123456&lt;select&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like '%$&#123;lastName&#125;%' &lt;/if&gt;&lt;/select&gt; 解决方式之二，使用bind标签 1234567&lt;select&gt; &lt;bind name=\"_lastName\" value=\"'%'+lastName+'%'\"&gt;&lt;/bind&gt; select * from person &lt;if test=\"lastName != null\"&gt; where lastName like #&#123;_lastName&#125; &lt;/if&gt;&lt;/select&gt; 1&lt;bind name=\"_lastName\" value=\"'_'+lastName+'%'\"&gt;&lt;/bind&gt;&lt;!--表示以什么开始，后面是参数的模糊查询--&gt; MyBatis的缓存机制概述MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。MyBatis系统中默认定义了两级缓存，一级缓存和二级缓存。 默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存（本地缓存）与数据库同一次会话期间查询的数据会放在本地缓存中，以后如果需要获取相同数据，直接从缓存中拿，不再查询数据库 一级缓存失效的四种情况 一级缓存是sqlSession级别的缓存，也就说一个sqlSession拥有自己的一级缓存，一级缓存是一直开启的，没有使用一级缓存的情况 不同的sqlSession对应不同的一级缓存 同一个sqlSession,但是查询条件不一样 同一个sqlSession两次查询期间执行了任何一次增删改操作 同一个sqlSession两次查询期间手动清空了缓存 二级缓存（全局缓存） 二级缓存基于namespace默认不开启，需要手动配置 MyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口 二级缓存在SqlSession 关闭或提交之后才会生效 工作机制 一个会话，查询一条数据，这个数据就会放在当前会话的一级缓存中 如果会话关闭，一级缓存中的数据就会保存到二级缓存中，新的查询信息，就参照二级缓存 使用步骤 全局配置文件中开启二级缓存 1&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 需要使用二级缓存的映射文件mapper.xml处使用cache配置缓存 1&lt;cach&gt;&lt;/cach&gt; 注意：POJO需要实现Serializable接口 Mybatis提供了整合ehcache缓存，具体整合方法参考官网文档， MyBatis的逆向工程概述MyBatis Generator：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写 官方文档地址：http://www.mybatis.org/generator/ 官方工程地址：https://github.com/mybatis/generator/releases MBG使用步骤 编写MBG的配置文件（重要几处配置） jdbcConnection配置数据库连接信息 javaModelGenerator配置javaBean的生成策略 sqlMapGenerator配置sql映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置要逆向解析的数据表 tableName：表名 domainObjectName：对应的javaBean名 运行代码生成器生成代码 注意： Context标签targetRuntime=“MyBatis3“可以生成带条件的增删改查targetRuntime=“MyBatis3Simple“可以生成基本的增删改查如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。 MBG配置文件12345678910111213141516171819202122232425&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; //数据库连接信息配置 &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/bookstore0629\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; //javaBean的生成策略 &lt;javaModelGenerator targetPackage=\"com.atguigu.bean\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; //映射文件的生成策略 &lt;sqlMapGenerator targetPackage=\"mybatis.mapper\" targetProject=\".\\conf\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; //dao接口java文件的生成策略 &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.atguigu.dao\" targetProject=\".\\src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; //数据表与javaBean的映射 &lt;table tableName=\"books\" domainObjectName=\"Book\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 生成器代码1234567891011public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new efaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; QBC风格的带条件查询123456789101112131415@Testpublic void test01()&#123; SqlSession openSession = build.openSession(); DeptMapper mapper = openSession.getMapper(DeptMapper.class); DeptExample example = new DeptExample(); //所有的条件都在example中封装 Criteria criteria = example.createCriteria(); //select id, deptName, locAdd from tbl_dept WHERE //( deptName like ? and id &gt; ? ) criteria.andDeptnameLike(\"%部%\"); criteria.andIdGreaterThan(2); List&lt;Dept&gt; list = mapper.selectByExample(example); for(Dept dept : list) &#123; System.out.println(dept);&#125; Mybatis的插件开发PageHelper分页插件项目地址：https://github.com/pagehelper/Mybatis-PageHelper 文档地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md 使用步骤12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 在 MyBatis 配置 xml 中配置拦截器插件 1234567&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=\"param1\" value=\"value1\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 代码中使用方法12345678910111213141516171819202122232425262728293031323334353637//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 常用方法介绍RowBounds方式的调用 1List&lt;Country&gt; list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页 PageHelper.startPage静态方法调用 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 PageInfo用法 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); Mybatis批量保存在MyBatis的全局设置中有设置，defaultExecutorType 配置默认的执行器 SIMPLE 就是普通的执行器； REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新 但是，如果在全局设置中设置批量执行器，那么每一个mapper中的方法都会执行批量操作，所以我们一般都是在与Spring整合后在Application.xml中配置一个可以执行批量操作的sqlSession,如下 123456789101112&lt;!--创建出SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- configLocation指定全局配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!--mapperLocations: 指定mapper文件的位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"executorType\" value=\"BATCH\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 在Service中自动注入SQLSession 123456@Autowiredprivate SqlSession sqlSession;public List&lt;Employee&gt; getEmps()&#123; EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); return mapper.getEmps();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://caochenhins.github.io/categories/Java/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochenhins.github.io/tags/Mybatis/"}]},{"title":"win10 Linux子系统 完美搭建","slug":"win10-Linux子系统-完美搭建","date":"2019-03-20T12:53:18.000Z","updated":"2019-03-21T15:16:10.190Z","comments":true,"path":"2019/03/20/win10-Linux子系统-完美搭建/","link":"","permalink":"https://caochenhins.github.io/2019/03/20/win10-Linux子系统-完美搭建/","excerpt":"1.Xshell完美连接win10 Linux子系统配置SSH服务sudo apt-get remove –purge openssh-server ## 先删sshsudo apt-get install openssh-server ## 在安装ssh sudo rm /etc/ssh/ssh_config ## 删配置文件，让ssh服务自己想办法链接sudo service ssh –full-restart","text":"1.Xshell完美连接win10 Linux子系统配置SSH服务sudo apt-get remove –purge openssh-server ## 先删sshsudo apt-get install openssh-server ## 在安装ssh sudo rm /etc/ssh/ssh_config ## 删配置文件，让ssh服务自己想办法链接sudo service ssh –full-restart 上面命令执行完之后，在xshell中输入用户名和ip就可以通过xshell登录自己电脑的Linux。 配置永久解决方案通过上面的方法，我们可以通过xshell登录自己电脑的Linux。 1.修改配置文件sudo nano /etc/sudoers加上这句:hins ALL=NOPASSWD: ALLctrl+o 保存ctrl+x 退出 2.新建bat命令:bash -c ‘sudo service ssh –full-restart’ 3.Win10设置开启启动shell:startup将新建的bat命令文件丢入开始文件夹 2.修改root密码:passwd root 3.linux下开启SSH，允许root用户远程登录1. 允许root用户远程登录修改ssh服务配置文件sudo vi /etc/ssh/sshd_config调整PermitRootLogin参数值为yes，如下图： 2. 允许无密码登录同上，修改ssh服务配置文件，两种情况：1） 将PermitEmptyPasswords yes前面的#号去掉2） 将PermitEmptyPasswords 参数值修改为yes，如下图： 无论哪种，最后PermitEmptyPasswords参数值为yes以上两种配置，均需要重启ssh服务service sshd restart # 或者/etc/initd.d/sshd restart 4.win10 Linux子系统安装rz命令执行以下命令安装: sudo add-apt-repository main sudo add-apt-repository universe sudo add-apt-repository restricted sudo add-apt-repository multiverse sudo apt-get update sudo apt-get install lrzsz 5.安装Jdk如果Java当前未安装，你将看到以下输出：Command ‘java’ not found, but can be installed with: apt install default-jreapt install openjdk-11-jre-headlessapt install openjdk-8-jre-headlessapt install openjdk-9-jre-headless 执行以下命令来安装OpenJDK：sudo apt install default-jre 该命令将安装Java运行时环境（JRE）。这将允许你运行几乎所有的Java软件。验证安装：java -version","categories":[{"name":"部署","slug":"部署","permalink":"https://caochenhins.github.io/categories/部署/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://caochenhins.github.io/tags/Linux/"}]}]}